<project name="ThemeBuildImports" xmlns:if="ant:if" xmlns:unless="ant:unless">
	<description>Common properties and macros needed for sub builds</description>

	<import file="build-import-overrides.xml" optional="true"/>

	<!-- GLOBAL PROPERTIES: used in both input and output tasks -->
	<property name="tmp.dir" location="${theme.tmp.dir}"/>
	<property name="maven.project.name" value="${project.name}"/>
	<property name="build.number" value="${project.version}"/>
	<property name="npm.loglevel" value="warn"/>

	<!-- INPUT PROPERTIES: relating to the artefacts used as inputs by this build -->
	<property name="theme.src.dir" location="${component.rootdir}/src"/>
	<property name="common.src.rootdir" location="${theme.src.dir}/main"/>
	<property name="common.test.rootdir" location="${theme.src.dir}/test"/>
	<property name="lde_config_dir" location="${component.rootdir}/lde"/>
	<property name="impl.src.rootdir" location="${theme.impl.dir}"/>
	<property name="impl.src.dir" location="${impl.src.rootdir}/${implementation.name}"/>
	<property name="impl.src.main.dir" location="${impl.src.dir}/src/main"/>
	<property name="common.debugFiles.name.pattern" value="wc.debug.*"/>
	<property name="javascript.globals" value="&quot;KeyEvent&quot;"/>

	<!-- OUTPUT PROPERTIES: relating to the artefacts generated by this build -->
	<property name="output.webresources.root.dir" value="theme"/>
	<property name="scratch.dir" location="${build.rootdir}/tmp"/><!-- In general do not use. Use tmp.dir instead. Used for temporary files that are needed across phases (from build to test).-->
	<property name="output.dir" location="${build.rootdir}/classes/${output.webresources.root.dir}"/><!-- WComponents expects files to be here so don't change it at all -->
	<property name="test.output.dir" location="${build.rootdir}/test-classes"/>
	<property name="target.rootdir" location="${output.dir}/${implementation.name}"/>
	<property name="test.target.rootdir" location="${test.output.dir}/${implementation.name}"/>

	<property name="properties.target.dir" location="${scratch.dir}" /><!-- Not tmp dir as it needs to persist from build to test -->
	<property name="properties.build.constants" location="${properties.target.dir}/all.${implementation.name}.properties" />

	<property name="images.target.dir.name" value="images"/>
	<property name="images.to.base64.dataurls" value="true"/>

	<property name="images.build.target.dir" location="${target.rootdir}/${images.target.dir.name}"/>
	<property name="images.tmp.src.dir" location="${tmp.dir}/images"/>
	<property name="i18n.build.target.dir" location="${tmp.dir}/i18n"/>

	<property name="debug.target.file.name.suffix" value="_debug"/>
	<property name="script.target.dir.name" value="scripts"/>
	<property name="script.debug.target.dir.name" value="${script.target.dir.name}${debug.target.file.name.suffix}"/>
	<property name="css.target.dir.name" value="style"/>
	<property name="xml.target.dir.name" value="xml"/>
	<property name="xslt.target.dir.name" value="xslt"/>
	<property name="images.target.dir.name" value="images"/>
	<property name="res.target.dir.name" value="resource"/>
	<property name="examples.target.dir.name" value="examples"/>
	<property name="plugins.target.dir.name" value="plugins"/>
	<property name="excludesfile" location="${impl.src.dir}/excludes.txt"/>
	<property name="style.build.target.dir" location="${target.rootdir}/${css.target.dir.name}"/>
	<property name="script.debug.build.target.dir" location="${target.rootdir}/${script.debug.target.dir.name}"/>
	<!--
		Note, the pattern "script.*.target.file.name" is important to the build scripts.
		* compat scripts are loaded before the core
		* fix scripts are loaded after
	-->
	<property name="script.core.target.file.name" value="all"/>
	<property name="script.debug.target.file.name" value="wc.debug"/>
	<property name="script.fix.ie.target.file.name.prefix" value="wc."/><!-- for example, wc.ie7.js will be created for ie7 fixes-->
	<property name="css.target.file.name" value="screen"/>
	<property name="css.target.file.name.print" value="print"/>
	<property name="css.target.file.name.debug" value="debug"/>
	<property name="xslt.target.file.name" value="all"/>
	<property name="xslt.target.debug.file.name" value="debug.xsl"/>
	<property name="coverage.target.file.name.suffix" value="-instrumented"/>
	<property name="jsLint.conf.file" location="${tmp.dir}/jsl.wc.conf"/>

	<!-- image properties used to build css -->
	<property name="images.rootdir" location="${common.src.rootdir}/images"/>
	<property name="impl.images.rootdir" location="${impl.src.main.dir}/images"/>

	<!-- ENVIRONMENT PROPERTIES -->
	<property environment="env"/>
	<hostinfo/>
	<property name="env.HOSTNAME" value="${NAME}"/><!-- HOSTNAME on nix, COMPUTERNAME on windows -->

	<tstamp>
		<format property="build.number" pattern="yyyyMMdd_HHmmss"/>
	</tstamp>

	<!--
		Regarding default.i18n.locale...
		Must match one of the locales we have provided source properties for in i18n directory.
		Pick a locale that has a complete set of messages because any incomplete locales will
		"inherit" missing messages from the default.
	-->
	<property name="default.i18n.locale" value="en"/>

	<path id="project.class.path">
		<path path="${maven.plugin.classpath}"/>
	</path>
	<!-- TASKDEFS and MACRODEFS -->
	<taskdef resource="net/sf/antcontrib/antcontrib.properties" classpathref="project.class.path"/>
	<taskdef resource="net/sf/antcontrib/antlib.xml" classpathref="project.class.path"/>

	<!-- "PRIVATE" properties, for use by macros inside this file - don't play with them -->
	<var name="private.unique.id.increment.count" value="0"/>







	<!--
		Converts a Path to an excludes file. The resulting file will contain a list of file names,
		one name per line. The full file path will be stripped from the file name, leaving only the
		actual name of the file itself.

		excludesFileName The name of the file to write
		pathId The id of the path to write to file
	-->
	<macrodef name="pathToExcludesFile" description="Writes the contents of a path element to an excludes file">
		<attribute name="excludesFileName"/>
		<attribute name="pathId"/>
		<sequential>
			<var name="tmp.pathToExcludesFile" unset="true"/>
			<property name="tmp.pathToExcludesFile" refid="@{pathId}"/>
			<propertyregex property="tmp.pathToExcludesFile.prop"
							override="true"
							input="${tmp.pathToExcludesFile}"
							regexp="${path.separator}"
							replace="&#10;"
							casesensitive="false"/>
			<if>
				<isset property="tmp.pathToExcludesFile.prop"/>
				<then>
					<echo message="${tmp.pathToExcludesFile.prop}" file="@{excludesFileName}"/>
					<replaceregexp file="@{excludesFileName}" match="^.*\${file.separator}" replace="" byline="true"/>
				</then>
				<else>
					<fail>Not a path: @{pathId}</fail>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!--
		Merges (concatenates) two properties files in such a way that any properties
		which are defined in both "properties0" and "properties1" will honor the
		version defined in "properties0"

	-->
	<macrodef name="mergeProperties">
		<attribute name="format" default="text" description="One of text or xml. Determines the output format. Defaults to text."/>
		<attribute name="properties0" description="Path to primary proerties file (properties here take precedence)"/>
		<attribute name="properties1" description="Path to secondary properties file"/>
		<attribute name="destFile" description="Path to output file (the result of merging the two)"/>
		<sequential>
			<echo>Merging @{properties0} and @{properties1} to @{destFile}</echo>
			<var name="unique.id" unset="true"/>
			<var name="unique.id" value="propertyMerge + ${private.unique.id.increment.count}"/>
			<var name="private.unique.id.increment.count" value="1 + ${private.unique.id.increment.count}"/>
			<loadproperties srcFile="@{properties0}" prefix="${unique.id}"/>
			<loadproperties srcFile="@{properties1}" prefix="${unique.id}"/>
			<echoproperties destfile="@{destFile}" format="@{format}">
				<propertyset>
					<propertyref prefix="${unique.id}."/>
					<mapper type="glob" from="${unique.id}.*" to="*"/>
				</propertyset>
			</echoproperties>
		</sequential>
	</macrodef>

	<!--
		Checks that all properties have been expanded during the build.
		Unexpanded properties are a common source of build errors so this
		is an important check.
	-->
	<target name="checkPropertiesExpanded">
		<path id="unexpanded.properties">
			<fileset dir="${output.dir}">
				<include name="**/*.js"/>
				<include name="**/*.css"/>
				<include name="**/*.xsl"/>
				<include name="**/*.xml"/>
				<contains text="${"/><!-- this would be much better as a regex-->
			</fileset>
		</path>
		<property name="unexpanded" refid="unexpanded.properties"/>
		<fail message="UNEXPANDED PROPERTIES FOUND: ${unexpanded}">
			<condition>
				<resourcecount when="greater" count="0" refid="unexpanded.properties" />
			</condition>
		</fail>
	</target>

	<macrodef name="buildJsLintConf">
		<attribute name="process"/>
		<attribute name="define"/>
		<sequential>
			<copy file="${component.rootdir}/jsl.wc.conf" todir="${tmp.dir}" overwrite="true"/>
			<!-- The base config file should contain warning switches but no process directive -->
			<echo append="true" file="${jsLint.conf.file}">${line.separator}@{define}</echo>
			<echo append="true" file="${jsLint.conf.file}">${line.separator}+recurse </echo>
			<echo append="true" file="${jsLint.conf.file}">${line.separator}+process </echo>
			<echo append="true" file="${jsLint.conf.file}">@{process}</echo>
		</sequential>
	</macrodef>

	<!-- simple dynamic excludes builder: used by build-xslt.xml and build-css.xml -->
	<macrodef name="simpleAddPatternToExcludes">
		<attribute name="destfile"/>
		<attribute name="pattern"/>
		<sequential>
			<echo message="${line.separator}@{pattern}" append="true" file="@{destfile}"/>
		</sequential>
	</macrodef>

	<!--
		Does two things:
		1. Sets the property ie.version.list with a list of the versions of ie specific source files in the sourceDir
		   For example if you have: foo.ie8.js, bar.ie8.js, bar.ie9.js files in your sourceDir you will get a list like this: "ie8,ie9"
		2. Writes the major version number of the lowest supported version of IE found to the global properties file.
		   For example, if you have For example if you have: foo.ie8.js, bar.ie8.js, bar.ie9.js the number "8" will be written to
		   the properties file as property @nameOfLowestVerionPropToSet.
	-->
	<macrodef name="gatherIeVersionInfo">
		<attribute name="sourceDir"/><!-- Path to directory containing source files -->
		<attribute name="sourceFileExt"/><!-- e.g. ".js" -->
		<attribute name="nameOfLowestVersionPropToSet"/><!-- Name of property to set -->
		<sequential>
			<var name="ie.version.list" value=""/>
			<var name="ie.support.lowest.version" unset="true"/><!-- Just in case someone is trying to get smart... -->
			<var name="ie.support.lowest.version" value="11"/><!-- 11 is just the latest version at the time of writing -->
			<for param="file">
				<fileset dir="@{sourceDir}" includes="*@{sourceFileExt}">
					<filename regex="\.ie[0-9]{1,2}\.|ieAll\."/>
				</fileset>
				<sequential>
					<var name="base.name" unset="true"/>
					<var name="ie.version" unset="true"/>
					<var name="ie.version.number" unset="true"/>
					<basename suffix="@{sourceFileExt}" property="base.name" file="@{file}"/><!-- base.name is now the file name without the path and the extension -->
					<propertyregex property="ie.version"
						input="${base.name}"
						regexp="^.+\.(.+)$"
						select="\1"
						casesensitive="false" />
					<if>
						<not>
							<contains string="${ie.version.list}" substring="${ie.version}"/>
						</not>
						<then>
							<if>
								<length string="${ie.version.list}" length="0"/>
								<then>
									<var name="ie.version.list" value="${ie.version}"/>
								</then>
								<else>
									<var name="ie.version.list" value="${ie.version.list},${ie.version}"/>
								</else>
							</if>
							<propertyregex property="ie.version.number"
								input="${ie.version}"
								regexp="\d+"
								select="\0" />
							<if>
								<and>
									<isset property="ie.version.number"/>
									<scriptcondition language="javascript" value="false">
										var arg1 = parseInt(project.getProperty("ie.version.number")),
											arg2 = parseInt(project.getProperty("ie.support.lowest.version"));
										self.setValue(arg1 &lt; arg2);
									</scriptcondition>
								</and>
								<then>
									<var name="ie.support.lowest.version" value="${ie.version.number}"/>
								</then>
							</if>
						</then>
					</if>
				</sequential>
			</for>
			<echo>Setting @{nameOfLowestVersionPropToSet} to: ${ie.support.lowest.version}</echo>
			<propertyfile file="${properties.build.constants}">
				<entry key="@{nameOfLowestVersionPropToSet}" value="${ie.support.lowest.version}"/>
				<entry key="ie.css.list" value="${ie.version.list}"/>
			</propertyfile>
		</sequential>
	</macrodef>

	<!--
	PLUGINS
	-->
	<property name="common.src.plugin.dir" location="${common.src.rootdir}/plugins"/>
	<property name="impl.src.plugin.dir" location="${impl.src.main.dir}/plugins"/>
	<condition property="plugin.includesfile" value="${impl.src.dir}/plugins.include.txt" else="${component.rootdir}/plugins.include.txt">
		<available file="${impl.src.dir}/plugins.include.txt"/>
	</condition>
	<property name="plugin.includesfile" location="${impl.src.dir}/plugins.include.txt"/>

	<!--
		Runs static analysis on javascript code.

		Note we deliberately overwrite the config file so it's harder to change.
		This is so we all code to the same standard - if you agree this is a noble goal then please work within this constraint.
		If you don't like the standard get in touch and we can look at changing it.
	-->
	<macrodef name="javascript.lint">
		<attribute name="jsdir" description="The directory that contains javascript to lint."/>
		<attribute name="failonerror" default="true"/>
		<sequential>
			<property name="jshint.executable" location="${basedir}/node_modules/eslint/bin/eslint.js"/>
			<property name="jshintrc" location="${basedir}/.eslintrc"/>
			<property name="jshintignore" location="${basedir}/.eslintignore"/>
			<echo file="${jshintrc}" force="true">{
	"env": {
		"browser": true,
		"amd": true
	},
	"rules": {
		"no-console": 0,
		"no-use-before-define": 0,
		"no-shadow": 0,
		"dot-notation": 0,
		"no-underscore-dangle": 0,
		"no-mixed-spaces-and-tabs": 0,
		"no-labels": 0,
		"no-constant-condition": 0,
		"no-return-assign": 0,
		"no-extend-native": 0,
		"no-debugger": 0,
		"no-alert": 0,
		"brace-style": [2, "stroustrup", { "allowSingleLine": false }],
		"space-before-blocks": [2, "always"],
		"spaced-comment": [2, "always"],
		"space-after-keywords": [2, "always"],
		"indent": [2, "tab", { "SwitchCase": 1 } ],
		"quotes": 0
	},
	"globals": {
		"KeyEvent": true
	}
}
</echo>
			<echo file="${jshintignore}" force="true"># Only ignore third-party scripts
**/lib/**
</echo>
			<echo>
				If the build fails here it means static analysis has detected Javascript issues.
				Please read the issues below and remedy them.
				All issue descriptions will yield results on Google, or contact your tech lead for help.

				If you have "'variable' is not defined" then please fix it (your forgot to use 'var' or you have a typo).
				In AMD there should be no global variables besides 'require' and 'define'.
			</echo>
			<echo>node ${jshint.executable} @{jsdir} --config ${jshintrc} --ignore-path ${jshintignore}</echo>
			<nodejs.exec cwd="${basedir}" failonerror="@{failonerror}">
				<arguments>
					<arg value="${jshint.executable}"/>
					<arg value="@{jsdir}"/>
					<arg value="--config"/>
					<arg value="${jshintrc}"/>
					<arg value="--ignore-path"/>
					<arg value="${jshintignore}"/>
				</arguments>
			</nodejs.exec>
		</sequential>
	</macrodef>

<!--	<macrodef name="loadJsDebugMap">
		<attribute name="propertyToSet"/>
		<sequential>
			<loadfile property="@{propertyToSet}" srcFile="${tmp.dir}/config/map.txt"/>
		</sequential>
	</macrodef>-->

	<!--
		Does what "npm install" does.
	-->
	<macrodef name="npm.install">
		<attribute name="package" default="" description="The name of the package to install."/>
		<attribute name="cwd" default="${basedir}" description="The working directory"/>
		<attribute name="failonerror" default="false"/>
		<sequential>
			<local name="npm.command"/>
			<property name="npm.command" value="install"/>
			<echo>npm ${npm.command} @{package}</echo>
			<npm.exec cwd="@{cwd}">
				<arg-elements>
					<arg value="${npm.command}"/>
					<arg value="@{package}"/>
				</arg-elements>
			</npm.exec>
		</sequential>
	</macrodef>

	<!--
	This macro knows how to call the npm executable on different platforms.
	It is primarily a helper for other macros in this library.

	Expects the following ant properties to be set:
		project.build.directory - the default working directory (target) - may be overriden with cwd arg
	-->
	<macrodef name="npm.exec">
		<attribute name="cwd" default="${basedir}" description="The working directory"/>
		<attribute name="failonerror" default="false"/>
		<element name="arg-elements" description="Ant 'arg' elements representing the args to pass to the npm command."/>
		<sequential>
			<local name="onwin"/>
			<property environment="env"/>
			<condition property="onwin">
				<os family="windows"/>
			</condition>
			<echo>
				If npm hangs then make sure you have set your ${user.home}/.npmrc file correctly.
			</echo>
			<nodejs.exec cwd="@{cwd}" failonerror="@{failonerror}">
				<arguments>
					<arg value="${npmjs.dir}/npm-cli.js"/>
					<arg-elements />
					<arg value="--loglevel"/>
					<arg value="${npm.loglevel}"/>
				</arguments>
			</nodejs.exec>
		</sequential>
	</macrodef>

	<!--
	This macro knows how to call the nodejs executable on different platforms.
	It is primarily a helper for other macros in this library.

	Expects the following ant properties to be set:
		nodejs.dir - the directory that contains the node executable
		project.build.directory - the default working directory (target) - may be overriden with cwd arg
	-->
	<macrodef name="nodejs.exec">
		<attribute name="cwd" default="${basedir}" description="The working directory"/>
		<attribute name="failonerror" default="false"/>
		<attribute name="spawn" default="false"/>
		<element name="arguments" description="Ant 'arg' elements representing the args to pass to the nodejs command."/>
		<sequential>
			<local name="node.ok"/>
			<local name="nodejs.dir.location"/>
			<property environment="env"/>
			<property name="nodejs.dir.location" location="${nodejs.dir}"/>
			<condition property="node.ok">
				<available file="${nodejs.dir.location}" type="dir"/>
			</condition>
			<fail unless="node.ok">
				Could not find nodejs.
				Current value is: ${nodejs.dir.location}
			</fail>
			<if>
				<os family="windows"/>
				<then>
					<exec dir="@{cwd}" executable="${nodejs.dir.location}/node" failonerror="@{failonerror}" spawn="@{spawn}">
						<env key="Path" path="${npmjs.dir};${nodejs.dir.location};${env.Path}"/>
						<env key="NVM_NODEJS_ORG_MIRROR" value="${node.download.root}"/><!-- TODO externalize. This is to get SASS to build. -->
						<env key="SASS_BINARY_SITE" value="${node.sass.download.root}"/><!-- TODO externalize. This is to get SASS to build. -->
						<arguments />
					</exec>
				</then>
				<else>
					<exec dir="@{cwd}" executable="${nodejs.dir.location}/node" failonerror="@{failonerror}" spawn="@{spawn}">
						<env key="PATH" path="/usr/bin:${npmjs.dir}:${nodejs.dir.location}:${env.PATH}"/>
						<env key="NVM_NODEJS_ORG_MIRROR" value="${node.download.root}"/><!-- TODO externalize. This is to get SASS to build. -->
						<env key="SASS_BINARY_SITE" value="${node.sass.download.root}"/><!-- TODO externalize. This is to get SASS to build. -->
						<arguments />
					</exec>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!--
		General purpose way to invoke an executable.
	-->
	<macrodef name="wc.exec">
		<attribute name="executable" description="The path to the executable"/>
		<attribute name="cwd" default="${basedir}" description="The working directory"/>
		<attribute name="failonerror" default="false"/>
		<attribute name="spawn" default="false"/>
		<attribute name="needscmd" default="true"/>
		<element name="arguments" description="Ant 'arg' elements representing the args to pass to the command."/>
		<sequential>
			<if>
				<os family="windows"/>
				<then>
					<if>
						<equals arg1="@{needscmd}" arg2="true"/>
						<then>
							<exec dir="@{cwd}" executable="cmd" failonerror="@{failonerror}" spawn="@{spawn}">
								<env key="Path" path="${npmjs.dir};${nodejs.dir};${basedir}\node_modules\.bin;${env.Path}"/>
								<arg line="/c &quot;@{executable}&quot;"/>
								<arguments />
							</exec>
						</then>
						<else>
							<exec dir="@{cwd}" executable="@{executable}" failonerror="@{failonerror}" spawn="@{spawn}">
								<env key="Path" path="${npmjs.dir};${nodejs.dir};${basedir}\node_modules\.bin;${env.Path}"/>
								<arguments />
							</exec>
						</else>
					</if>

				</then>
				<else>
					<exec unless:set="onwin" dir="@{cwd}" executable="@{executable}" failonerror="@{failonerror}" spawn="@{spawn}">
						<env key="PATH" path="/usr/bin:${npmjs.dir}:${nodejs.dir}:${basedir}/node_modules/.bin:${env.PATH}"/>
						<arguments />
					</exec>
				</else>
			</if>
		</sequential>
	</macrodef>

	<!--

	This macro performs a transform from XML to JSON using xsltjson: https://github.com/bramstein/xsltjson.

	EXAMPLE:

	<wc.xsltjson
		xsltjsonDir="target/xsltjson"
		xmlDir="${src.dir}/xml"
		jsonDir="target/json"/>

	-->
	<macrodef name="wc.xsltjson">
		<attribute name="xsltjsonDir" description="The directory that contains the xsltjson zip"/>
		<attribute name="xmlDir" description="The directory that contains the XML to transform"/>
		<attribute name="jsonDir" default="@{xmlDir}" description="The directory to hold the result of the transform"/>
		<attribute name="destDir" default="@{xsltjsonDir}" description="The directory in which we will unzip xsltjson."/>
		<attribute name="xslName" default="xml-to-json.xsl" description="The name of the xslt file to use for the transform."/>
		<attribute name="useBadgerfish" default="false"/>
		<attribute name="useRabbitfish" default="false"/>
		<attribute name="useRayfish" default="false"/>
		<attribute name="extension" default=".xml"/>

		<sequential>
			<unzip dest="@{destDir}">
				<patternset>
					<include name="**/*.xsl"/>
					<include name="**/*.jar"/><!-- Not expecting this to exist, belt and braces... -->
				</patternset>
				<fileset dir="@{xsltjsonDir}">
					<include name="*.zip"/>
				</fileset>
				<mapper type="flatten"/>
			</unzip>
			<path id="saxon.classpath">
				<fileset dir="@{destDir}">
					<include name="saxon*.jar"/>
				</fileset>
			</path>
			<mkdir dir="@{jsonDir}"/>
			<xslt basedir="@{xmlDir}" destdir="@{jsonDir}" style="@{destDir}/@{xslName}">
				<classpath>
					<path refid="saxon.classpath"/>
				</classpath>
				<!--
					Any one of these can be switched on.
					With all of them off we produce "basic" JSON where there is no distinction
					between attributes and elements and it would not be possible to transform back to XML.

					Rabbitfish is the same but adds "@" to attributes.

					I believe basic is best for us, but rabbitfish could be an option too.
				-->
				<param name="use-badgerfish" expression="@{useBadgerfish}" type="BOOLEAN"/>
				<param name="use-rabbitfish" expression="@{useRabbitfish}" type="BOOLEAN"/>
				<param name="use-rayfish" expression="@{useRayfish}" type="BOOLEAN"/>
				<mapper type="glob" from="*@{extension}" to="*.json"/>
			</xslt>
		</sequential>
	</macrodef>
</project>
