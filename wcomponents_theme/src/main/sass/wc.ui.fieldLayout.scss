/*
  wc.ui.fieldLayout.scss
  The "label" of a WField may not be transformed to a HTML Label element. It is a label if the component in the ui:input
  is labelable EXCEPT when the input is a WCheckBox or WRadioButton. In all other cases it is a span (even when the
  ui:label is not present in the XML).

  We allow the "label" part of a WField to always have a presence in the transformed output even when it is not in the
  XML or is moved to be after a WCheckBox or WRadioButton. This has much simplified the CSS.
 */
@import "wc.ui.fieldLayout_vars.scss" ;

ul.fieldLayout { /* field layouts may be an ordered list, in which case we want to expose the numbers */
	list-style-type: none;
	padding: 0;
	margin: 0;
}

.field + .field {
 	margin-top: $vgap_normal
 }


/* Flat is the most common use, but shouldn't be (due to a11y concerns which are not covered by WCAG 2.0)
 * NOTE the use of the .fieldLayout class here because .flat comes from an XML arttribute value and is used all over the
 * place. */
.fieldLayout.flat > .field {
	> * {
		display: inline-block;
		vertical-align: text-top;
	}
	> :first-child { //the first child is the label or standing or merely an empty placeholder/spacer
		width: $labelWidth;
		> .wc_req { // Position the required marker next to the input.
			position: relative;
			padding-right: 1em; //Padding right is for the required marker.
			@include borderBox;
			&:after { // this is the required marker
				position: absolute;
				right: 0;
				top: 0
			}
		}
	}
	> .input {
		width: $inputWidth;
		max-width: $inputWidth;
	}
	> :first-child, > .input {
		@include respond(phone) {
			@include borderBox;
			display: block;
			max-width: 100% !important;
			width: 100% !important;
		}
	}
	> .wc_off + .input { // if the label is off screen we need some margin.
		margin-left: $labelWidth;
		@include respond(phone) {
			margin-left: 0 !important;
		}
	}
	> .wc_fld_pl { //this is the placeholder for a null or moved label - moved for checkbox or radio
		@include respond(phone) {
			display: none;
		}
	}
}


/* stacked is pretty easy, just need to put in a vertical spacer between the label
 * and the controls. This should probably be smaller than the gap between fields. */
.fieldLayout.stacked > .field {
	 > label + .input, > .label + .input {
		margin-top: $vgap_small;
	}
	> .input {
		@include respond(phone) {
			@include borderBox;
			margin-left: 0 !important;
			max-width:100% !important;
			width: 100% !important;
		}
	}
}

/*
 * InputWidth is placed inline but a class is added to the input part of the
 * field to signify that an inputWidth is in use so we can size the components
 */
.input.inputWidth {
	> [type="text"],
	> [type="date"],
	> .dateField,
	> [type="password"],
	> [type="email"],
	> [type="tel"],
	> [type="number"],
	> textarea,
	> select,
	> fieldset {
		@include borderBox;
		width: 100%;
	}
	> .dateField[role="combobox"] {
		width: auto;
	}
}
/*end  wc.ui.fieldLayout.scss */