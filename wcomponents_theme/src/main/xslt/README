	####################################################################################################################
	# READ THIS IF YOU ARE EVEN THINKING ABOUT CHANGING THE XSLT
	####################################################################################################################

	WComponents inserts a DOCTYPE definition into the XML to allow lazy use of &nbsp; The upshot of this is that IE
	believes the XML is HTML and this has a flow on effect with some elements. Any HTML shorttag elements will cause a
	problem if the XSLT contains a <shorttag></shorttag> as IE (at least up to IE8) will output

		<shorttag></shorttag></shorttag><//shorttag/>.

	To mitigate against accidentally doing this we use <xsl:element> for element contruction and the build process XSLT
	compression includes a step to reducethe verbosity of this for elements which are not HTML self-closing.

	Example

		<input>
			<xsl:attribute...>
		</input>

		will be output by IE as
		<input attributes /></input/>

		So when you make any HTML element in XSLT please use
		<xsl:element name="elementname">
			<xsl:attribute...> etc
		</xsl:element>
		unless you are absolutely sure it is safe (preferably do not be lazy); then the XSLT compressor will make it
		into <elementname attribute=".." /> if it is safe to do so.

	####################################################################################################################
	# Default Namespace
	####################################################################################################################

	xmlns="http://www.w3.org/1999/xhtml"
	removed due to bug: https://bugzilla.mozilla.org/show_bug.cgi?id=631455

	NOTE: This line also causes MASSIVE bugs in IE, these bugs do not show symptoms very often in IE but when you hit
	the right combination then you have some very serious issues to deal with so basically NEVER put it back.

	Hmm ok this line also caused serious problems in Chrome. Caused line breaks to double up for example. Maybe we were
	wrong to ever put this in.

	####################################################################################################################
	# Applying templates
	####################################################################################################################

	If the schema for an element indicates that the element has only element children (for example ui:menu) then using
	<xsl:apply-templates /> to apply those templates should be safe enough. However, if the XML is indented or has any
	extraneous space then this space is a text node and will be copied through. This shouldn't matter in HTML, but
	sometimes, and in some browsers, it does. Therefore, if we are applying templates in an element which should not
	have non-element children we prefer to use <apply-templates select="*"/> to ensure we do not get these extraneous
	text nodes. They can play havoc with content wrapping in closely styled buttons (such as those in a BAR menu) in
	Chrome, for example.

	####################################################################################################################
	# Why online XSLT tutorials are dangerous
	####################################################################################################################

	If you ever use <xsl:for-each> without providing a detailed justification in triplicate and signed in blood we will
	hunt you down and mock you. Do not learn your XSLT chops online.

	<xsl:for-each> is incredibly slow. We have cleaned up other transforms where removing xsl:for-each and replacing
	them with apply-templates or apply-imports has resulted in transform times being reduced from hundreds of seconds to
	tens of milliseconds with one extreme case (admittedly in IE6) being reduced from over 14 minutes to around 600
	milliseconds.
		YES: 14 MINUTES to 600 MILLISECONDS BY REMOVING xsl:for-each



	####################################################################################################################
	# Debug templates, variables and tests
	####################################################################################################################

	We have extra XSLT for handling extra information when in debug mode. This includes transforms for the WComponents
	debugInfo and a large amount of XSLT to handle our developer diagnostics layer. All of this is stripped from the
	compressed XSLT so long as any test (xsl:if or xsl:when) for debug mode tests the xsl:param $isDebug.

	The $isDebug param is also stripped from the compressed XSLT.


For XSLT code and comment conventions see the WComponents documentation project in the Maven site.