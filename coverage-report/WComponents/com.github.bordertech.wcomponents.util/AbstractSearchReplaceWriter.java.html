<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>AbstractSearchReplaceWriter.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents.util</a> &gt; <span class="el_source">AbstractSearchReplaceWriter.java</span></div><h1>AbstractSearchReplaceWriter.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents.util;

import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;

/**
 * &lt;p&gt;
 * AbstractSearchReplaceWriter is a writer extension that allows programmatic replacement of strings contained in
 * written stream. For efficiency, it uses a buffer that is twice the size of the longest search string.&lt;/p&gt;
 *
 * &lt;p&gt;
 * Data is only written to the underlying writer when the buffer is filled, or when the writer is closed; calling
 * {@link #flush()} only flushes the underlying writer. Calling {@link #close()} may not close the underlying writer,
 * depending on the return value of {@link #closeBackingOnClose()}&lt;/p&gt;
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
public abstract class AbstractSearchReplaceWriter extends Writer {

	/**
	 * The array of search Strings, sorted in ascending order.
	 */
	private final String[] search;

	/**
	 * The underlying writer to write the output to.
	 */
	private final Writer backing;

	/**
	 * The &quot;lookahead&quot; buffer. It buffers characters from the underlying stream to allow us to check for the &quot;match&quot;
	 * string before writing them to the underlying writer.
	 */
	private final char[] buffer;

	/**
	 * Our current position within the {@link #lookahead} buffer.
	 */
<span class="fc" id="L41">	private int bufferLen = 0;</span>

	/**
	 * Creates a SearchReplaceWriter.
	 *
	 * @param search the search strings.
	 * @param backing the backing writer, where output will be eventually sent to.
	 */
<span class="fc" id="L49">	public AbstractSearchReplaceWriter(final String[] search, final Writer backing) {</span>
<span class="fc" id="L50">		this.backing = backing;</span>

		// Create a copy of the search array, as we need it sorted
<span class="fc" id="L53">		this.search = new String[search.length];</span>
<span class="fc" id="L54">		System.arraycopy(search, 0, this.search, 0, search.length);</span>
<span class="fc" id="L55">		Arrays.sort(this.search);</span>

		// Find the longest search item
<span class="fc" id="L58">		int maxKeyLength = -1;</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">		for (int i = 0; i &lt; search.length; i++) {</span>
<span class="pc bpc" id="L61" title="2 of 4 branches missed.">			if (search[i] == null || search[i].length() == 0) {</span>
<span class="nc" id="L62">				throw new IllegalArgumentException(&quot;Search strings must not be empty, &quot; + i);</span>
			}

<span class="fc" id="L65">			maxKeyLength = Math.max(maxKeyLength, search[i].length());</span>
		}

<span class="pc bpc" id="L68" title="1 of 2 branches missed.">		if (maxKeyLength == -1) {</span>
			// Nothing to replace, so no need for a buffer
<span class="nc" id="L70">			buffer = null;</span>
		} else {
<span class="fc" id="L72">			buffer = new char[maxKeyLength * 2];</span>
		}
<span class="fc" id="L74">	}</span>

	/**
	 * Writes out remaining content and optionally closes the backing writer.
	 *
	 * @see #closeBackingOnClose()
	 * @throws IOException if there is an error closing the underlying buffer.
	 */
	@Override
	public void close() throws IOException {
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">		if (bufferLen != 0) {</span>
<span class="fc" id="L85">			writeBuf(bufferLen);</span>
		}

<span class="pc bpc" id="L88" title="1 of 2 branches missed.">		if (closeBackingOnClose()) {</span>
<span class="nc" id="L89">			backing.close();</span>
		}
<span class="fc" id="L91">	}</span>

	/**
	 * Flushes the underlying writer.
	 *
	 * @throws IOException if there is an error flushing the underlying buffer.
	 */
	@Override
	public void flush() throws IOException {
<span class="nc" id="L100">		backing.flush();</span>
<span class="nc" id="L101">	}</span>

	/**
	 * Implementation of Writer's write method.
	 *
	 * @param cbuf the character buffer to write.
	 * @param off the start position in the array to write from.
	 * @param len the amount of character data to write.
	 * @throws IOException if there is an error writing to the underlying buffer.
	 */
	@Override
	public void write(final char[] cbuf, final int off, final int len) throws IOException {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if (buffer == null) {</span>
			// Nothing to replace, just pass the data through
<span class="nc" id="L115">			backing.write(cbuf, off, len);</span>
		} else {
<span class="fc bfc" id="L117" title="All 2 branches covered.">			for (int i = off; i &lt; off + len; i++) {</span>
<span class="fc" id="L118">				buffer[bufferLen++] = cbuf[i];</span>

<span class="fc bfc" id="L120" title="All 2 branches covered.">				if (bufferLen == buffer.length) {</span>
<span class="fc" id="L121">					writeBuf(buffer.length / 2);</span>
				}
			}
		}
<span class="fc" id="L125">	}</span>

	/**
	 * Writes the current contents of the buffer, up to the given position. More data may be written from the buffer
	 * when there is a search string that crosses over endPos.
	 *
	 * @param endPos the end position to stop writing
	 * @throws IOException if there is an error writing to the underlying writer.
	 */
	private void writeBuf(final int endPos) throws IOException {
		// If the stream is not closed, we only process half the buffer at once.
		String searchTerm;
<span class="fc" id="L137">		int pos = 0;</span>
<span class="fc" id="L138">		int lastWritePos = 0;</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">		while (pos &lt; endPos) {</span>
<span class="fc" id="L141">			searchTerm = findSearchStrings(pos);</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">			if (searchTerm != null) {</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">				if (lastWritePos != pos) {</span>
<span class="fc" id="L145">					backing.write(buffer, lastWritePos, pos - lastWritePos);</span>
				}

<span class="fc" id="L148">				doReplace(searchTerm, backing);</span>
<span class="fc" id="L149">				pos += searchTerm.length();</span>
<span class="fc" id="L150">				lastWritePos = pos;</span>
			} else {
<span class="fc" id="L152">				pos++;</span>
			}
		}

		// Write the remaining characters that weren't matched
<span class="fc bfc" id="L157" title="All 2 branches covered.">		if (lastWritePos != pos) {</span>
<span class="fc" id="L158">			backing.write(buffer, lastWritePos, pos - lastWritePos);</span>
		}

		// Shuffle the buffer
<span class="fc" id="L162">		System.arraycopy(buffer, pos, buffer, 0, buffer.length - pos);</span>
<span class="fc" id="L163">		bufferLen -= pos;</span>
<span class="fc" id="L164">	}</span>

	/**
	 * Searches for any search strings in the buffer that start between the specified offsets.
	 *
	 * @param start the start search offset
	 *
	 * @return the first search String found, or null if none were found.
	 */
	private String findSearchStrings(final int start) {
<span class="fc" id="L174">		String longestMatch = null;</span>

		// Loop for each string
<span class="fc bfc" id="L177" title="All 2 branches covered.">		for (int i = 0; i &lt; search.length; i++) {</span>
			// No point checking a String that's too long
<span class="fc bfc" id="L179" title="All 2 branches covered.">			if (start + search[i].length() &gt; bufferLen) {</span>
<span class="fc" id="L180">				continue;</span>
			}

<span class="fc" id="L183">			boolean found = true;</span>

			// Loop for each character in range
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">			for (int j = 0; j &lt; search[i].length() &amp;&amp; (start + j &lt; bufferLen); j++) {</span>
<span class="fc" id="L187">				int diff = buffer[start + j] - search[i].charAt(j);</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">				if (diff &lt; 0) {</span>
					// Since the strings are all sorted, we can abort if
					// the character is less than the corresponding character in
					// the current search string.
<span class="fc" id="L193">					return longestMatch;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">				} else if (diff != 0) {</span>
<span class="fc" id="L195">					found = false;</span>
<span class="fc" id="L196">					break;</span>
				}
			}

<span class="pc bpc" id="L200" title="3 of 6 branches missed.">			if (found &amp;&amp; (longestMatch == null || longestMatch.length() &lt; search[i].length())) {</span>
<span class="fc" id="L201">				longestMatch = search[i];</span>
			}
		}

<span class="fc" id="L205">		return longestMatch;</span>
	}

	/**
	 * Indicates whether the backing writer should be closed on close of this writer. Subclasses can override this to
	 * keep the underlying writer open.
	 *
	 * @return true if the backing writer should be closed when {@link #close()} is called.
	 */
	protected boolean closeBackingOnClose() {
<span class="nc" id="L215">		return true;</span>
	}

	/**
	 * Subclasses must implement this method to perform the actual replacement.
	 *
	 * @param search the search string that was matched.
	 * @param backing the underlying writer to write the output to.
	 * @throws IOException if there is an error writing to the underlying writer.
	 */
	protected abstract void doReplace(String search, Writer backing) throws IOException;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>