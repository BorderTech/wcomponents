<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>Base64Util.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents.util</a> &gt; <span class="el_source">Base64Util.java</span></div><h1>Base64Util.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents.util;

import java.io.UnsupportedEncodingException;

/**
 * A Base64 Encoder/Decoder.
 * &lt;p&gt;
 * This class is used to encode and decode data in Base64 format as described in RFC 1521.
 * &lt;p&gt;
 * This is &quot;Open Source&quot; software and released under the
 * &lt;a href=&quot;http://www.gnu.org/licenses/lgpl.html&quot;&gt;GNU/LGPL &lt;/a&gt;
 * license. &lt;br&gt;
 * It is provided &quot;as is&quot; without warranty of any kind. &lt;br&gt;
 * Copyright 2003: Christian d'Heureuse, Inventec Informatik AG, Switzerland.
 * &lt;br&gt;
 * Home page: &lt;a href=&quot;http://www.source-code.biz&quot;&gt;www.source-code.biz &lt;/a&gt; &lt;br&gt;
 * &lt;p&gt;
 * Original name &lt;b&gt;Base64Coder.java &lt;/b&gt;
 * &lt;p&gt;
 * Version history: &lt;br&gt;
 * 2003-07-22 Christian d'Heureuse (chdh): Module created. &lt;br&gt;
 * 2005-08-11 chdh: Lincense changed from GPL to LGPL. &lt;br&gt;
 * 2006-11-21 chdh: &lt;br&gt;
 * &amp;nbsp; Method encode(String) renamed to encodeString(String). &lt;br&gt;
 * &amp;nbsp; Method decode(String) renamed to decodeString(String). &lt;br&gt;
 * &amp;nbsp; New method encode(byte[],int) added. &lt;br&gt;
 * &amp;nbsp; New method decode(String) added. &lt;br&gt;
 * 2007-04-30 francis.naoum: Added to sfp_lib. &lt;br&gt;
 * &amp;nbsp; byte[] encode(byte[]) changed to return a String. &lt;br&gt;
 *
 * @author Francis Naoum
 * @since 1.0.0
 */
public final class Base64Util {

	/**
	 * Mapping table from 6-bit nibbles to Base64 characters.
	 */
<span class="fc" id="L39">	private static final char[] MAP1 = new char[64];</span>

	static {
<span class="fc" id="L42">		int i = 0;</span>

<span class="fc bfc" id="L44" title="All 2 branches covered.">		for (char c = 'A'; c &lt;= 'Z'; c++) {</span>
<span class="fc" id="L45">			MAP1[i++] = c;</span>
		}

<span class="fc bfc" id="L48" title="All 2 branches covered.">		for (char c = 'a'; c &lt;= 'z'; c++) {</span>
<span class="fc" id="L49">			MAP1[i++] = c;</span>
		}

<span class="fc bfc" id="L52" title="All 2 branches covered.">		for (char c = '0'; c &lt;= '9'; c++) {</span>
<span class="fc" id="L53">			MAP1[i++] = c;</span>
		}

<span class="fc" id="L56">		MAP1[i++] = '+';</span>
<span class="fc" id="L57">		MAP1[i++] = '/';</span>
	}

	/**
	 * Mapping table from Base64 characters to 6-bit nibbles.
	 */
<span class="fc" id="L63">	private static final byte[] MAP2 = new byte[128];</span>

	static {
<span class="fc bfc" id="L66" title="All 2 branches covered.">		for (int i = 0; i &lt; MAP2.length; i++) {</span>
<span class="fc" id="L67">			MAP2[i] = -1;</span>
		}

<span class="fc bfc" id="L70" title="All 2 branches covered.">		for (int i = 0; i &lt; 64; i++) {</span>
<span class="fc" id="L71">			MAP2[MAP1[i]] = (byte) i;</span>
		}
<span class="fc" id="L73">	}</span>

	/**
	 * Encodes a string into Base64 format. No blanks or line breaks are inserted.
	 *
	 * @param string a String to be encoded.
	 * @return A String with the Base64 encoded data.
	 */
	public static String encodeString(final String string) {
<span class="fc" id="L82">		String encodedString = null;</span>

		try {
<span class="fc" id="L85">			encodedString = encodeString(string, &quot;UTF-8&quot;);</span>
<span class="nc" id="L86">		} catch (UnsupportedEncodingException uue) {</span>
			// Should never happen, java has to support &quot;UTF-8&quot;.
<span class="fc" id="L88">		}</span>

<span class="fc" id="L90">		return encodedString;</span>
	}

	/**
	 * Encodes a string into Base64 format. No blanks or line breaks are inserted.
	 *
	 * @param string a String to be encoded.
	 * @param encoding The character encoding of the string.
	 * @return A String with the Base64 encoded data.
	 *
	 * @throws UnsupportedEncodingException if the java runtime does not support &lt;code&gt;encoding&lt;/code&gt;.
	 */
	public static String encodeString(final String string, final String encoding) throws
			UnsupportedEncodingException {
<span class="fc" id="L104">		byte[] stringBytes = string.getBytes(encoding);</span>
<span class="fc" id="L105">		return encode(stringBytes);</span>
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are inserted.
	 * &lt;p&gt;
	 * This method has been modified to return a string not a char[].
	 *
	 * @param input an array containing the data bytes to be encoded.
	 * @return A character array with the Base64 encoded data.
	 */
	public static String encode(final byte[] input) {
<span class="fc" id="L117">		char[] chars = encode(input, input.length);</span>
<span class="fc" id="L118">		return new String(chars);</span>
	}

	/**
	 * Encodes a byte array into Base64 format. No blanks or line breaks are inserted.
	 *
	 * @param input an array containing the data bytes to be encoded.
	 * @param iLen number of bytes to process in &lt;code&gt;in&lt;/code&gt;.
	 * @return A character array with the Base64 encoded data.
	 */
	public static char[] encode(final byte[] input, final int iLen) {
<span class="fc" id="L129">		int oDataLen = (iLen * 4 + 2) / 3; // output length without padding</span>
<span class="fc" id="L130">		int oLen = ((iLen + 2) / 3) * 4; // output length including padding</span>
<span class="fc" id="L131">		char[] out = new char[oLen];</span>
<span class="fc" id="L132">		int ip = 0;</span>
<span class="fc" id="L133">		int op = 0;</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">		while (ip &lt; iLen) {</span>
<span class="fc" id="L136">			int i0 = input[ip++] &amp; 0xff;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">			int i1 = ip &lt; iLen ? input[ip++] &amp; 0xff : 0;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">			int i2 = ip &lt; iLen ? input[ip++] &amp; 0xff : 0;</span>
<span class="fc" id="L139">			int o0 = i0 &gt;&gt;&gt; 2;</span>
<span class="fc" id="L140">			int o1 = ((i0 &amp; 3) &lt;&lt; 4) | (i1 &gt;&gt;&gt; 4);</span>
<span class="fc" id="L141">			int o2 = ((i1 &amp; 0xf) &lt;&lt; 2) | (i2 &gt;&gt;&gt; 6);</span>
<span class="fc" id="L142">			int o3 = i2 &amp; 0x3F;</span>
<span class="fc" id="L143">			out[op++] = MAP1[o0];</span>
<span class="fc" id="L144">			out[op++] = MAP1[o1];</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">			out[op] = op &lt; oDataLen ? MAP1[o2] : '=';</span>
<span class="fc" id="L146">			op++;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">			out[op] = op &lt; oDataLen ? MAP1[o3] : '=';</span>
<span class="fc" id="L148">			op++;</span>
<span class="fc" id="L149">		}</span>

<span class="fc" id="L151">		return out;</span>
	}

	/**
	 * Decodes a string from Base64 format.
	 *
	 * @param string a Base64 String to be decoded.
	 * @return A String containing the decoded data.
	 * @throws IllegalArgumentException if the input is not valid Base64 encoded data.
	 */
	public static String decodeString(final String string) {
<span class="fc" id="L162">		String decodedString = null;</span>

		try {
<span class="fc" id="L165">			byte[] decodedBytes = decode(string);</span>
<span class="fc" id="L166">			decodedString = new String(decodedBytes, &quot;UTF-8&quot;);</span>
<span class="nc" id="L167">		} catch (UnsupportedEncodingException uue) {</span>
			// Should never happen, java has to support &quot;UTF-8&quot;.
<span class="fc" id="L169">		}</span>

<span class="fc" id="L171">		return decodedString;</span>
	}

	/**
	 * Decodes a byte array from Base64 format.
	 *
	 * @param string a Base64 String to be decoded.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException if the input is not valid Base64 encoded data.
	 */
	public static byte[] decode(final String string) {
<span class="fc" id="L182">		return decode(string.toCharArray());</span>
	}

	/**
	 * Decodes a byte array from Base64 format. No blanks or line breaks are allowed within the Base64 encoded data.
	 *
	 * @param input a character array containing the Base64 encoded data.
	 * @return An array containing the decoded data bytes.
	 * @throws IllegalArgumentException if the input is not valid Base64 encoded data.
	 */
	public static byte[] decode(final char[] input) {
<span class="fc" id="L193">		int iLen = input.length;</span>

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">		if (iLen % 4 != 0) {</span>
<span class="nc" id="L196">			throw new IllegalArgumentException(</span>
					&quot;Length of Base64 encoded input string is not a multiple of 4.&quot;);
		}

<span class="pc bpc" id="L200" title="1 of 4 branches missed.">		while (iLen &gt; 0 &amp;&amp; input[iLen - 1] == '=') {</span>
<span class="fc" id="L201">			iLen--;</span>
		}

<span class="fc" id="L204">		int oLen = (iLen * 3) / 4;</span>
<span class="fc" id="L205">		byte[] out = new byte[oLen];</span>
<span class="fc" id="L206">		int ip = 0;</span>
<span class="fc" id="L207">		int op = 0;</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">		while (ip &lt; iLen) {</span>
<span class="fc" id="L210">			int i0 = input[ip++];</span>
<span class="fc" id="L211">			int i1 = input[ip++];</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">			int i2 = ip &lt; iLen ? input[ip++] : 'A';</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">			int i3 = ip &lt; iLen ? input[ip++] : 'A';</span>

<span class="pc bpc" id="L215" title="4 of 8 branches missed.">			if (i0 &gt; 127 || i1 &gt; 127 || i2 &gt; 127 || i3 &gt; 127) {</span>
<span class="nc" id="L216">				throw new IllegalArgumentException(&quot;Illegal character in Base64 encoded data.&quot;);</span>
			}

<span class="fc" id="L219">			int b0 = MAP2[i0];</span>
<span class="fc" id="L220">			int b1 = MAP2[i1];</span>
<span class="fc" id="L221">			int b2 = MAP2[i2];</span>
<span class="fc" id="L222">			int b3 = MAP2[i3];</span>

<span class="pc bpc" id="L224" title="4 of 8 branches missed.">			if (b0 &lt; 0 || b1 &lt; 0 || b2 &lt; 0 || b3 &lt; 0) {</span>
<span class="nc" id="L225">				throw new IllegalArgumentException(&quot;Illegal character in Base64 encoded data.&quot;);</span>
			}

<span class="fc" id="L228">			int o0 = (b0 &lt;&lt; 2) | (b1 &gt;&gt;&gt; 4);</span>
<span class="fc" id="L229">			int o1 = ((b1 &amp; 0xf) &lt;&lt; 4) | (b2 &gt;&gt;&gt; 2);</span>
<span class="fc" id="L230">			int o2 = ((b2 &amp; 3) &lt;&lt; 6) | b3;</span>
<span class="fc" id="L231">			out[op++] = (byte) o0;</span>

<span class="fc bfc" id="L233" title="All 2 branches covered.">			if (op &lt; oLen) {</span>
<span class="fc" id="L234">				out[op++] = (byte) o1;</span>
			}

<span class="fc bfc" id="L237" title="All 2 branches covered.">			if (op &lt; oLen) {</span>
<span class="fc" id="L238">				out[op++] = (byte) o2;</span>
			}
<span class="fc" id="L240">		}</span>

<span class="fc" id="L242">		return out;</span>
	}

	/**
	 * Dummy constructor.
	 */
<span class="nc" id="L248">	private Base64Util() {</span>
<span class="nc" id="L249">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>