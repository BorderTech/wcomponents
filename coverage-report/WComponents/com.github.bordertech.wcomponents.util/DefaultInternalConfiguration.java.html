<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>DefaultInternalConfiguration.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents.util</a> &gt; <span class="el_source">DefaultInternalConfiguration.java</span></div><h1>DefaultInternalConfiguration.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents.util;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.configuration.ConversionException;
import org.apache.commons.configuration.MapConfiguration;

/**
 * &lt;p&gt;
 * Implementation of the {@link Configuration} interface.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note: We can't use the logging infrastructure in this class, because the logging infrastructure is probably not
 * initialised yet. Indeed, it will be via this mechanism that the logging configuration is loaded! Instead, we have a
 * primitive mechanism for recording significant events which can be accessed later for logging if need be.
 * &lt;/p&gt;
 *
 * @author Yiannis Paschalidis, based on ParamImpl
 * @since 1.0.0
 */
final class DefaultInternalConfiguration implements Configuration {

	/**
	 * This array defines the file names which we load the internal configuration from, as well as the order in which
	 * the files are loaded.
	 */
<span class="fc" id="L51">	private static final String[] PARAMETER_LOAD_ORDER</span>
			= {
				// The name of the first resource we look for is for internal properties
				&quot;wcomponents.properties&quot;,
				// The name of the next resource we look at is for application properties
				&quot;wcomponents-app.properties&quot;,
				// The last properties which are loaded are local/developer properties
				&quot;local_app.properties&quot;
			};

	/**
	 * If this parameter is defined, it is treated as a comma-separated list of additional resources to load. The
	 * include is processed immediately.
	 */
	private static final String INCLUDE = &quot;include&quot;;

	/**
	 * If this parameter is defined, it is taken as a (comma-separated) resource to load. The resource is loaded after
	 * the current (set of) resources is loaded.
	 */
	private static final String INCLUDE_AFTER = &quot;includeAfter&quot;;

	/**
	 * If this parameter is defined and resolves to true as a boolean, then the system properties will be merged at the
	 * end of the loading process.
	 */
	private static final String USE_SYSTEM_PROPERTIES = &quot;bordertech.wcomponents.parameters.useSystemProperties&quot;;

	/**
	 * If this parameter is set to true, then after loading the parameters, they will be dumped to the console.
	 */
	private static final String DUMP = &quot;bordertech.wcomponents.parameters.dump.console&quot;;

	/**
	 * Parameters with this prefix will be dumped into the System parameters. This feature is for handling recalcitrant
	 * 3rd party software only - not for general use!!!
	 */
	private static final String SYSTEM_PARAMETERS_PREFIX = &quot;bordertech.wcomponents.parameters.system.&quot;;

	// -----------------------------------------------------------------------------------------------------------------
	// State used during loading of parameters
	/**
	 * The messages logged during loading of the configuration. We can't depend on a logging framework to log errors, as
	 * this class is typically used to configure the logging.
	 */
<span class="fc" id="L96">	private final StringBuffer messages = new StringBuffer();</span>

	/**
	 * The resource being loaded. This is used for the relative form of resource loading.
	 */
<span class="fc" id="L101">	private final Stack&lt;String&gt; resources = new Stack&lt;&gt;();</span>

	/**
	 * A generic object that allows us to synchronized refreshes. Required so that gets and refreshes are threadsafe
	 */
<span class="fc" id="L106">	private final Object lockObject = new Object();</span>

	// -----------------------------------------------------------------------------------------------------------------
	// Implementation
	/**
	 * Our backing store is a Map object.
	 */
	private Map&lt;String, Object&gt; backing;

	/**
	 * Explicitly cache booleans for flag look-up speed.
	 */
	private Set&lt;String&gt; booleanBacking;

	/**
	 * Stores &quot;explanations&quot; of where each setting comes from. Each parameter will have a history, explaining all the
	 * locations where that parameter was defined, in reverse order (so the first entry is the defining entry).
	 */
	private Map&lt;String, String&gt; locations;

	/**
	 * Cache of subcontexts, by {true,false}-prefix.
	 */
	private Map&lt;String, Properties&gt; subcontextCache;

	private IncludeProperties runtimeProperties;

	/**
	 * Variables that we are in the process of substituting. This is used to detect recursive substitutions
	 */
<span class="fc" id="L136">	private final Set&lt;String&gt; substituting = new HashSet&lt;&gt;();</span>

	/**
	 * Creates a DefaultInternalConfiguration. The constructor is package protected as it is called from
	 * {@link Config#getInstance()};
	 */
<span class="fc" id="L142">	protected DefaultInternalConfiguration() {</span>
<span class="fc" id="L143">		initialiseInstanceVariables();</span>
<span class="fc" id="L144">		load();</span>
<span class="fc" id="L145">	}</span>

	/**
	 * Create an instance of DefaultInternalConfiguration, loading values from a resource named &quot;resourceName&quot;. This
	 * constructor is provided purely for testing purposes. Application code should always use the
	 * {@link Config#getInstance()} method.
	 *
	 * @param resourceName the name of the resource to load (from the classloader, working or home directory)
	 */
<span class="fc" id="L154">	protected DefaultInternalConfiguration(final String resourceName) {</span>
<span class="fc" id="L155">		initialiseInstanceVariables();</span>
<span class="fc" id="L156">		loadTop(resourceName);</span>

		// Now perform variable substitution.
		do {
<span class="fc bfc" id="L160" title="All 2 branches covered.">		} while (substitute());</span>
<span class="fc" id="L161">	}</span>

	/**
	 * {@inheritDoc}
	 */
	public String get(final String key, final String defolt) {
<span class="fc" id="L167">		String result = get(key);</span>

<span class="fc bfc" id="L169" title="All 2 branches covered.">		if (result == null) {</span>
<span class="fc" id="L170">			return defolt;</span>
		} else {
<span class="fc" id="L172">			return result;</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public String get(final String key) {
<span class="fc" id="L180">		return (String) backing.get(key);</span>
	}

	/**
	 * Splits the given comma-delimited string into an an array. Leading/trailing spaces in list items will be trimmed.
	 *
	 * @param list the String to split.
	 * @return the split version of the list.
	 */
	private String[] parseStringArray(final String list) {
<span class="fc" id="L190">		StringTokenizer tokenizer = new StringTokenizer(list, &quot;,&quot;, false);</span>
<span class="fc" id="L191">		int length = tokenizer.countTokens();</span>
<span class="fc" id="L192">		String[] arr = new String[length];</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (int i = 0; tokenizer.hasMoreElements(); i++) {</span>
<span class="fc" id="L195">			arr[i] = cleanSpaces(tokenizer.nextToken());</span>
		}

<span class="fc" id="L198">		return arr;</span>
	}

	/**
	 * Removes any leading/trailing spaces from the given string. This has the same effect as calling
	 * {@link String#trim}, but is null-safe.
	 *
	 * @param aStr the String to trim.
	 * @return the trimmed String, or null if the &lt;code&gt;aStr&lt;/code&gt; was null.
	 */
	private String cleanSpaces(final String aStr) {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">		if (aStr == null) {</span>
<span class="nc" id="L210">			return aStr;</span>
		}

<span class="fc" id="L213">		return aStr.trim();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	public Properties getProperties() {
		// Don't return the backing directly; make a copy so that the caller can't change us...
<span class="nc" id="L221">		Properties copy = new Properties();</span>
<span class="nc" id="L222">		copy.putAll(backing);</span>
<span class="nc" id="L223">		return copy;</span>
	}

	// -----------------------------------------------------------------------------------------------------------------
	/**
	 * This method initialises most of the instance variables.
	 */
	private void initialiseInstanceVariables() {
<span class="fc" id="L231">		backing = new HashMap&lt;&gt;();</span>
<span class="fc" id="L232">		booleanBacking = new HashSet&lt;&gt;();</span>
<span class="fc" id="L233">		locations = new HashMap&lt;&gt;();</span>

		// subContextCache is updated on the fly so ensure no concurrent modification.
<span class="fc" id="L236">		subcontextCache = Collections.synchronizedMap(new HashMap());</span>
<span class="fc" id="L237">		runtimeProperties = new IncludeProperties(&quot;Runtime: added at runtime&quot;);</span>
<span class="fc" id="L238">	}</span>

	/**
	 * Load the backing from the properties file visible to our classloader, plus the filesystem.
	 */
	@SuppressWarnings(&quot;checkstyle:emptyblock&quot;)
	private void load() {
<span class="fc" id="L245">		recordMessage(&quot;Loading parameters&quot;);</span>
<span class="fc" id="L246">		File cwd = new File(&quot;.&quot;);</span>
		String workingDir;

		try {
<span class="fc" id="L250">			workingDir = cwd.getCanonicalPath();</span>
<span class="nc" id="L251">		} catch (IOException ex) {</span>
<span class="nc" id="L252">			workingDir = &quot;UNKNOWN&quot;;</span>
<span class="fc" id="L253">		}</span>

<span class="fc" id="L255">		recordMessage(&quot;Working directory is &quot; + workingDir);</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">		for (String resourceName : PARAMETER_LOAD_ORDER) {</span>
<span class="fc" id="L258">			loadTop(resourceName);</span>
		}

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">		if (getBoolean(USE_SYSTEM_PROPERTIES)) {</span>
<span class="nc" id="L262">			recordMessage(&quot;Loading from system properties&quot;);</span>
<span class="nc" id="L263">			load(System.getProperties(), &quot;System Properties&quot;, true);</span>
		}

		// Now perform variable substitution.
		do {
			// Do nothing while loop
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">		} while (substitute());</span>

<span class="pc bpc" id="L271" title="1 of 2 branches missed.">		if (getBoolean(DUMP)) {</span>
			// Can't use logging infrastructure here, so dump to console
<span class="nc" id="L273">			log(getDebuggingInfo());</span>
<span class="nc" id="L274">			log(getMessages());</span>
		}

		// We don't want the StringBuffer hanging around after 'DUMP'.
<span class="fc" id="L278">		clearMessages();</span>

		// Now move any parameters with the system parameters prefix into the real system parameters.
<span class="fc" id="L281">		Properties systemProperties = getSubProperties(SYSTEM_PARAMETERS_PREFIX, true);</span>
<span class="fc" id="L282">		System.getProperties().putAll(systemProperties);</span>
<span class="fc" id="L283">	}</span>

	/**
	 * @return debugging information for logging on application start-up.
	 */
	protected String getDebuggingInfo() {
<span class="nc" id="L289">		final String paramsFile = &quot;log4j.appender.PARAMS.File&quot;;</span>

<span class="nc" id="L291">		File cwd = new File(&quot;.&quot;);</span>
		String workingDir;

		try {
<span class="nc" id="L295">			workingDir = cwd.getCanonicalPath();</span>
<span class="nc" id="L296">		} catch (IOException ex) {</span>
<span class="nc" id="L297">			workingDir = &quot;UNKNOWN&quot;;</span>
<span class="nc" id="L298">		}</span>

<span class="nc" id="L300">		String codesourceStr = &quot;&quot;;</span>

		// Try to be sneaky and print the codesource location (for orientation of user)
		try {
<span class="nc" id="L304">			ProtectionDomain domain = getClass().getProtectionDomain();</span>
<span class="nc" id="L305">			CodeSource codesource = null;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">			if (domain != null) {</span>
<span class="nc" id="L308">				codesource = domain.getCodeSource();</span>
			}

<span class="nc bnc" id="L311" title="All 2 branches missed.">			codesourceStr = (codesource != null ? &quot; code location of ParamImpl: &quot; + codesource.</span>
<span class="nc" id="L312">					getLocation() : &quot;&quot;);</span>
<span class="nc" id="L313">		} catch (Throwable failed) {</span>
			// Okay
<span class="nc" id="L315">		}</span>

<span class="nc" id="L317">		StringBuffer info = new StringBuffer();</span>

<span class="nc" id="L319">		info.append(&quot;----Parameters start----&quot;);</span>
<span class="nc" id="L320">		info.append(codesourceStr);</span>
<span class="nc" id="L321">		info.append(&quot;\nWorking directory is &quot;);</span>
<span class="nc" id="L322">		info.append(workingDir);</span>
<span class="nc" id="L323">		info.append(</span>
				&quot;\nParameters have loaded, there is a full parameter dump in log4j FILE appender at &quot;);
<span class="nc" id="L325">		info.append(get(paramsFile));</span>
<span class="nc" id="L326">		info.append(&quot;\nTo dump all params to stdout set &quot;);</span>
<span class="nc" id="L327">		info.append(DUMP);</span>
<span class="nc" id="L328">		info.append(&quot; to true; currently value is &quot;);</span>
<span class="nc" id="L329">		info.append(get(DUMP));</span>
<span class="nc" id="L330">		info.append(&quot;\n----Parameters end------&quot;);</span>

<span class="nc" id="L332">		return info.toString();</span>
	}

	/**
	 * Loading of &quot;top level&quot; resources is different to the general recursive case, since it is only at the top level
	 * that we check for the includeAfter parameter.
	 *
	 * @param resourceName the path of the resource to load from.
	 */
	@SuppressWarnings(&quot;checkstyle:emptyblock&quot;)
	private void loadTop(final String resourceName) {
		try {
<span class="fc" id="L344">			resources.push(resourceName);</span>

<span class="fc" id="L346">			load(resourceName);</span>

			// Now check for INCLUDE_AFTER resources
<span class="fc" id="L349">			String includes = get(INCLUDE_AFTER);</span>

<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (includes != null) {</span>
				// First, do substitution on the INCLUDE_AFTER
				do {
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">				} while (substitute(INCLUDE_AFTER));</span>

				// Now split and process
<span class="fc" id="L357">				String[] includeAfter = getString(INCLUDE_AFTER).split(&quot;,&quot;);</span>
<span class="fc" id="L358">				backing.remove(INCLUDE_AFTER);</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">				for (String after : includeAfter) {</span>
<span class="fc" id="L360">					loadTop(after);</span>
				}
			}
		} finally {
<span class="pc" id="L364">			resources.pop();</span>
<span class="fc" id="L365">		}</span>
<span class="fc" id="L366">	}</span>

	/**
	 * Try loading the given resource name. There may be several resources corresponding to that name...
	 *
	 * @param resourceName the path of the resource to load from.
	 */
	private void load(final String resourceName) {
<span class="fc" id="L374">		boolean found = false;</span>

		try {
<span class="fc" id="L377">			resources.push(resourceName);</span>

			// Try classloader - load the resources in reverse order of the enumeration.  Since later-loaded resources
			// override earlier-loaded ones, this better corresponds to the usual classpath behaviour.
<span class="fc" id="L381">			ClassLoader classloader = getParamsClassLoader();</span>
<span class="fc" id="L382">			List&lt;URL&gt; urls = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L384">			for (Enumeration&lt;URL&gt; res = classloader.getResources(resourceName); res.</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">					hasMoreElements();) {</span>
<span class="fc" id="L386">				urls.add(res.nextElement());</span>
			}

<span class="fc" id="L389">			recordMessage(&quot;Resource &quot; + resourceName + &quot; was found  &quot; + urls.size() + &quot; times&quot;);</span>

			// Sometimes the same URL will crop up several times (because of redundant entries in classpaths).  Also,
			// sometimes the same file appears under several URLS (because it's packaged into a jar and also a classes
			// directory, perhaps). In these circumstances we really only want to load the resource once - we load the
			// first one and then ignore later ones.
<span class="fc" id="L395">			Map&lt;String, String&gt; loadedFiles = new HashMap&lt;&gt;();</span>

			// Build up a list of the byte arrays from the files that we then process.
<span class="fc" id="L398">			List&lt;byte[]&gt; contentsList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L399">			List&lt;URL&gt; urlList = new ArrayList&lt;&gt;();</span>

			// This processes from the front-of-classpath to end-of-classpath since end-of-classpath ones appear last in
			// the enumeration
<span class="fc bfc" id="L403" title="All 2 branches covered.">			for (int i = 0; i &lt; urls.size(); i++) {</span>
<span class="fc" id="L404">				URL url = urls.get(i);</span>
<span class="fc" id="L405">				found = true;</span>

				// Load the contents of the resource, for comparison with existing resources.
<span class="fc" id="L408">				InputStream urlContentStream = url.openStream();</span>
<span class="fc" id="L409">				ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L410">				StreamUtil.copy(urlContentStream, baos);</span>
<span class="fc" id="L411">				urlContentStream.close();</span>
<span class="fc" id="L412">				byte[] urlContentBytes = baos.toByteArray();</span>
<span class="fc" id="L413">				String urlContent = new String(urlContentBytes, &quot;UTF-8&quot;);</span>

				// Check if we have already loaded this file.
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">				if (loadedFiles.keySet().contains(urlContent)) {</span>
<span class="nc" id="L417">					recordMessage(&quot;Skipped url &quot; + url + &quot; - duplicate of &quot; + loadedFiles.get(urlContent));</span>
<span class="nc" id="L418">					continue;</span>
				}

<span class="fc" id="L421">				loadedFiles.put(urlContent, url.toString());</span>
<span class="fc" id="L422">				contentsList.add(urlContentBytes);</span>
<span class="fc" id="L423">				urlList.add(url);</span>
			}

<span class="fc bfc" id="L426" title="All 2 branches covered.">			for (int i = contentsList.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L427">				byte[] buff = contentsList.get(i);</span>
<span class="fc" id="L428">				URL url = urlList.get(i);</span>
<span class="fc" id="L429">				recordMessage(&quot;Loading from url &quot; + url + &quot;...&quot;);</span>
<span class="fc" id="L430">				ByteArrayInputStream in = new ByteArrayInputStream(buff);</span>

				// Use the &quot;IncludeProperties&quot; to load properties into us one at a time....
<span class="fc" id="L433">				IncludeProperties properties = new IncludeProperties(url.toString());</span>
<span class="fc" id="L434">				properties.load(in);</span>
			}

<span class="fc" id="L437">			File file = new File(resourceName);</span>

			// Don't reload the file in the working directory if we are in the home directory.
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">			if (file.exists()) {</span>
<span class="nc" id="L441">				recordMessage(&quot;Loading from file &quot; + filename(file) + &quot;...&quot;);</span>
<span class="nc" id="L442">				found = true;</span>

				// Use the &quot;IncludeProperties&quot; to load properties into us, one at a time....
<span class="nc" id="L445">				IncludeProperties properties = new IncludeProperties(&quot;file:&quot; + filename(file));</span>
<span class="nc" id="L446">				properties.load(new BufferedInputStream(new FileInputStream(file)));</span>
			}

<span class="fc bfc" id="L449" title="All 2 branches covered.">			if (!found) {</span>
<span class="fc" id="L450">				recordMessage(&quot;Did not find resource &quot; + resourceName);</span>
			}
<span class="nc" id="L452">		} catch (IOException ex) {</span>
			// This is bad.
<span class="nc" id="L454">			recordException(ex);</span>
<span class="nc" id="L455">		} catch (IllegalArgumentException ex) {</span>
			// Most likely a &quot;Malformed uxxxx encoding.&quot; error, which is
			// usually caused by a developer forgetting to escape backslashes
<span class="nc" id="L458">			recordException(ex);</span>
		} finally {
<span class="pc" id="L460">			resources.pop();</span>
<span class="pc" id="L461">		}</span>
<span class="fc" id="L462">	}</span>

	/**
	 * Retrieves the canonical path for a given file.
	 *
	 * @param aFile the file to get the canonical path for.
	 * @return the canonical path to the given file, or &lt;code&gt;&quot;UNKNOWN FILE&quot;&lt;/code&gt; on error.
	 */
	private String filename(final File aFile) {
		try {
<span class="nc" id="L472">			return aFile.getCanonicalPath();</span>
<span class="nc" id="L473">		} catch (IOException ex) {</span>
<span class="nc" id="L474">			recordException(ex);</span>
<span class="nc" id="L475">			return &quot;UNKNOWN FILE&quot;;</span>
		}
	}

	/**
	 * @return the ClassLoader instance for this class.
	 */
	private ClassLoader getParamsClassLoader() {
		// Ideally we could just use the defining classloader for this class.  But unfortunately we have to deal with
		// &quot;legacy&quot; deployment styles where this class is visible to the container's system class loader (ie in the
		// system class path), instead of being deployed within the application.
		//
		// One idea is to use the context class loader; but iPlanet does not set this usefully, so we have to fool
		// about...

		// First, try the context class loader.
<span class="fc" id="L491">		ClassLoader loader = Thread.currentThread().getContextClassLoader();</span>

<span class="pc bpc" id="L493" title="1 of 2 branches missed.">		if (loader == null) {</span>
<span class="nc" id="L494">			recordMessage(&quot;No context classloader had been set&quot;);</span>
<span class="nc" id="L495">			loader = getClass().getClassLoader();</span>
<span class="nc" id="L496">			recordMessage(&quot;Using classloader &quot; + loader);</span>
<span class="nc" id="L497">			return loader;</span>
		}

		// Are we visible to this class loader?
		try {
<span class="fc" id="L502">			Class test = loader.loadClass(getClass().getName());</span>

<span class="pc bpc" id="L504" title="1 of 2 branches missed.">			if (test == getClass()) {</span>
<span class="fc" id="L505">				recordMessage(&quot;Visible to ContextClassLoader&quot;);</span>
<span class="fc" id="L506">				recordMessage(&quot;Using classloader &quot; + loader);</span>

				// Beauty - context class loader looks good
<span class="fc" id="L509">				return loader;</span>
			} else {
				// Rats - this should not happen with a sane application server
<span class="nc" id="L512">				recordMessage(</span>
						&quot;Whoa - is visible to context class loader, but it gives a different class&quot;);

				// If this happens we need to investigate further, but for the time being we'll use the context class
				// loader
<span class="nc" id="L517">				return loader;</span>
			}
<span class="nc" id="L519">		} catch (Exception ex) {</span>
<span class="nc" id="L520">			recordMessage(&quot;Not visible to context class loader (&quot; + loader + &quot;):&quot; + ex.getMessage());</span>
<span class="nc" id="L521">			loader = getClass().getClassLoader();</span>
<span class="nc" id="L522">			recordMessage(&quot;Using classloader &quot; + loader);</span>
<span class="nc" id="L523">			return loader;</span>
		}
	}

	/**
	 * Load the properties from the given Properties object, recording the origin on those properties as being from the
	 * given location.
	 *
	 * @param properties the properties to load from
	 * @param location the location where the parameter was defined.
	 * @param overwriteOnly if true, only properties that are already defined will be loaded
	 */
	private void load(final Properties properties, final String location,
			final boolean overwriteOnly) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">		for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) {</span>

<span class="nc" id="L539">			String key = (String) entry.getKey();</span>
<span class="nc" id="L540">			String already = get(key);</span>

<span class="nc bnc" id="L542" title="All 6 branches missed.">			if (overwriteOnly &amp;&amp; already == null &amp;&amp; !INCLUDE.equals(key)) {</span>
<span class="nc" id="L543">				continue;</span>
			}

<span class="nc" id="L546">			String value = (String) entry.getValue();</span>
<span class="nc" id="L547">			load(key, value, location);</span>
<span class="nc" id="L548">		}</span>
<span class="nc" id="L549">	}</span>

	/**
	 * Loads a single parameter into the configuration. This handles the special directives such as &quot;include&quot;.
	 *
	 * @param key the parameter key.
	 * @param value the parameter value.
	 * @param location the location where the parameter was defined.
	 */
	private void load(final String key, final String value, final String location) {
		// Recursive bit
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">		if (INCLUDE.equals(key)) {</span>
<span class="nc" id="L561">			load(parseStringArray(value));</span>
		} else {
<span class="fc" id="L563">			backing.put(key, value);</span>

<span class="pc bpc" id="L565" title="1 of 4 branches missed.">			if (&quot;yes&quot;.equals(value) || &quot;true&quot;.equals(value)) {</span>
<span class="fc" id="L566">				booleanBacking.add(key);</span>
			} else {
<span class="fc" id="L568">				booleanBacking.remove(key);</span>
			}

<span class="fc" id="L571">			String history = locations.get(key);</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">			if (history == null) {</span>
<span class="fc" id="L574">				history = location;</span>
			} else {
<span class="fc" id="L576">				history = location + &quot;; &quot; + history;</span>
			}

<span class="fc" id="L579">			locations.put(key, history);</span>
		}
<span class="fc" id="L581">	}</span>

	/**
	 * Loads the configuration from a set of files.
	 *
	 * @param subFiles the files to load from.
	 */
	private void load(final String[] subFiles) {
<span class="fc bfc" id="L589" title="All 2 branches covered.">		for (int i = 0; i &lt; subFiles.length; i++) {</span>
<span class="fc" id="L590">			load(subFiles[i]);</span>
		}
<span class="fc" id="L592">	}</span>

	/**
	 * Logs an exception.
	 *
	 * @param throwable the exception to log.
	 */
	private void recordException(final Throwable throwable) {
<span class="nc" id="L600">		throwable.printStackTrace();</span>
<span class="nc" id="L601">	}</span>

	/**
	 * Records a message in the internal log buffer.
	 *
	 * @param msg the message log.
	 */
	private void recordMessage(final String msg) {
<span class="fc" id="L609">		messages.append(msg).append('\n');</span>
<span class="fc" id="L610">	}</span>

	/**
	 * @return the set of logged messages.
	 */
	private String getMessages() {
<span class="nc" id="L616">		return messages.toString();</span>
	}

	/**
	 * Clears the logged message buffer.
	 */
	private void clearMessages() {
<span class="fc" id="L623">		messages.setLength(0);</span>
<span class="fc" id="L624">	}</span>

	/**
	 * Returns a sub-set of the parameters contained in this configuration.
	 *
	 * @param prefix the prefix of the parameter keys which should be included.
	 * @param truncate if true, the prefix is truncated in the returned properties.
	 * @return the properties sub-set, may be empty.
	 */
	public Properties getSubProperties(final String prefix, final boolean truncate) {
<span class="fc" id="L634">		String cacheKey = truncate + prefix;</span>
<span class="fc" id="L635">		Properties sub = subcontextCache.get(cacheKey);</span>

<span class="pc bpc" id="L637" title="1 of 2 branches missed.">		if (sub != null) {</span>
			// make a copy so users can't change.
<span class="nc" id="L639">			Properties copy = new Properties();</span>
<span class="nc" id="L640">			copy.putAll(sub);</span>
<span class="nc" id="L641">			return copy;</span>
		}

<span class="fc" id="L644">		sub = new Properties();</span>

<span class="fc" id="L646">		int length = prefix.length();</span>

<span class="fc bfc" id="L648" title="All 2 branches covered.">		for (Map.Entry&lt;String, Object&gt; entry : backing.entrySet()) {</span>

<span class="fc" id="L650">			String key = entry.getKey();</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">			if (key.startsWith(prefix)) {</span>
				// If we are truncating, remove the prefix
<span class="fc" id="L654">				String newKey = key;</span>

<span class="fc bfc" id="L656" title="All 2 branches covered.">				if (truncate) {</span>
<span class="fc" id="L657">					newKey = key.substring(length);</span>
				}

<span class="fc" id="L660">				sub.setProperty(newKey, (String) entry.getValue());</span>
			}
<span class="fc" id="L662">		}</span>

<span class="fc" id="L664">		subcontextCache.put(cacheKey, sub);</span>

		// Make a copy so users can't change.
<span class="fc" id="L667">		Properties copy = new Properties();</span>
<span class="fc" id="L668">		copy.putAll(sub);</span>

<span class="fc" id="L670">		return copy;</span>
	}

	/**
	 * Iterates through the values, looking for values containing ${...} strings. For those that do, we substitute if
	 * the stuff in the {...} is a defined key.
	 *
	 * @return true if any substitutions were made, false otherwise.
	 */
	private boolean substitute() {
<span class="fc" id="L680">		boolean madeChange = false;</span>

<span class="fc bfc" id="L682" title="All 2 branches covered.">		for (String key : backing.keySet()) {</span>
<span class="fc bfc" id="L683" title="All 4 branches covered.">			madeChange = madeChange || substitute(key);</span>
<span class="fc" id="L684">		}</span>

<span class="fc" id="L686">		return madeChange;</span>
	}

	/**
	 * Performs value substitution for the given key. For values containing ${...} strings, we substitute if the stuff
	 * in the {...} is a defined key.
	 *
	 * @param aKey the key to run the substitution for.
	 * @return true if a substitutions was made, false otherwise.
	 */
	private boolean substitute(final String aKey) {
<span class="fc" id="L697">		boolean madeChange = false;</span>

<span class="pc bpc" id="L699" title="1 of 2 branches missed.">		if (substituting.contains(aKey)) {</span>
<span class="nc" id="L700">			backing.put(aKey, &quot;&quot;);</span>
<span class="nc" id="L701">			booleanBacking.remove(aKey);</span>
<span class="nc" id="L702">			recordMessage(&quot;WARNING: Recursive substitution detected on parameter &quot; + aKey);</span>
<span class="nc" id="L703">			String history = locations.get(aKey);</span>
<span class="nc" id="L704">			locations.put(aKey, history + &quot;recursion detected, using null value; &quot; + history);</span>
<span class="nc" id="L705">			return true;</span>
		}

		try {
<span class="fc" id="L709">			substituting.add(aKey);</span>

<span class="fc" id="L711">			String value = (String) backing.get(aKey);</span>

<span class="fc" id="L713">			int start = findStartVariable(value);</span>

<span class="fc bfc" id="L715" title="All 2 branches covered.">			if (start == -1) {</span>
<span class="fc" id="L716">				return madeChange;</span>
			}

<span class="fc" id="L719">			int end = value.indexOf('}', start);</span>

<span class="pc bpc" id="L721" title="1 of 2 branches missed.">			if (end == -1) {</span>
<span class="nc" id="L722">				return madeChange;</span>
			}

<span class="fc" id="L725">			String variableName = value.substring(start + 2, end);</span>

<span class="pc bpc" id="L727" title="2 of 4 branches missed.">			madeChange = madeChange || substitute(variableName);</span>

<span class="fc" id="L729">			String variableValue = get(variableName);</span>

<span class="fc bfc" id="L731" title="All 2 branches covered.">			if (variableValue == null) {</span>
<span class="fc" id="L732">				return madeChange;</span>
			}

<span class="fc" id="L735">			String newValue = value.substring(0, start) + variableValue + value.substring(end + 1);</span>

<span class="fc" id="L737">			madeChange = true;</span>

<span class="fc" id="L739">			backing.put(aKey, newValue);</span>

<span class="pc bpc" id="L741" title="2 of 4 branches missed.">			if (&quot;yes&quot;.equals(newValue) || &quot;true&quot;.equals(newValue)) {</span>
<span class="nc" id="L742">				booleanBacking.add(aKey);</span>
			} else {
<span class="fc" id="L744">				booleanBacking.remove(aKey);</span>
			}

			// Record this substitution in the history
<span class="fc" id="L748">			String history = locations.get(aKey);</span>
<span class="fc" id="L749">			history = &quot;substitution of ${&quot; + variableName + &quot;}; &quot; + history;</span>
<span class="fc" id="L750">			locations.put(aKey, history);</span>

<span class="fc" id="L752">			return madeChange;</span>
		} finally {
<span class="pc" id="L754">			substituting.remove(aKey);</span>
		}
	}

	/**
	 * Finds the start of a variable name in the given string. Variables use the &quot;${&lt;i&gt;variableName&lt;/i&gt;}&quot; notation.
	 *
	 * @param aKey the key to search.
	 * @return the index of the start of a variable name in the given string, or -1 if not found.
	 */
	private int findStartVariable(final String aKey) {
<span class="fc bfc" id="L765" title="All 2 branches covered.">		if (aKey == null) {</span>
<span class="fc" id="L766">			return -1;</span>
		}

		// Look for the first occurence of ${ in the parameter.
<span class="fc" id="L770">		int index = aKey.indexOf('$');</span>

<span class="pc bfc" id="L772" title="All 2 branches covered.">		for (; index &gt;= 0; index = aKey.indexOf('$', index + 1)) {</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">			if (index == aKey.length() - 1) {</span>
<span class="nc" id="L774">				continue;</span>
			}

<span class="pc bpc" id="L777" title="1 of 2 branches missed.">			if (aKey.charAt(index + 1) != '{') {</span>
				continue;
			}

			// Ahh - got it
			break; // NOPMD
		}

<span class="fc" id="L785">		return index;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	public void refresh() {
<span class="nc" id="L792">		synchronized (lockObject) {</span>
			// Now reset this object back to its initial state.
<span class="nc" id="L794">			initialiseInstanceVariables();</span>

			// Load all the parameters from scratch.
<span class="nc" id="L797">			load();</span>

			// Finally, notify all the listeners that have registered with this object that a change in properties has
			// occurred.
<span class="nc" id="L801">			Config.notifyListeners();</span>
<span class="nc" id="L802">		}</span>
<span class="nc" id="L803">	}</span>

	/**
	 * {@inheritDoc}
	 */
	public void addOrModifyProperty(final String name, final String value) {
<span class="fc bfc" id="L809" title="All 2 branches covered.">		if (name == null) {</span>
<span class="fc" id="L810">			throw new SystemException(&quot;name parameter can not be null.&quot;);</span>
		}

<span class="fc bfc" id="L813" title="All 2 branches covered.">		if (name.length() &lt; 1) {</span>
<span class="fc" id="L814">			throw new SystemException(&quot;name parameter can not be the empty String.&quot;);</span>
		}

<span class="fc bfc" id="L817" title="All 2 branches covered.">		if (value == null) {</span>
<span class="fc" id="L818">			throw new SystemException(&quot;value parameter can not be null.&quot;);</span>
		}

<span class="fc" id="L821">		recordMessage(</span>
				&quot;modifyProperties() - Adding property '&quot; + name + &quot;' with the value '&quot; + value + &quot;'.&quot;);

<span class="fc" id="L824">		runtimeProperties.setProperty(name, value);</span>

		// clear the subContext cache, it's now invalid
<span class="fc" id="L827">		subcontextCache.clear();</span>
<span class="fc" id="L828">	}</span>

	// -----------------------------------------------------------------------------------------------------------------
	// Helper classes
	// -----------------------------------------------------------------------------------------------------------------
	/**
	 * A helper class for properties which are being loaded.
	 */
	class IncludeProperties extends Properties {

		/**
		 * The properties file location (if applicable).
		 */
		private final String location;

		/**
		 * Creates an IncludeProperties, which has not being sourced externally.
		 */
		IncludeProperties() {
<span class="nc" id="L847">			this(&quot;Modified at Runtime&quot;);</span>
<span class="nc" id="L848">		}</span>

		/**
		 * Creates an IncludeProperties, which will be sourced from the given location.
		 *
		 * @param aLocation the location of the external properties.
		 */
<span class="fc" id="L855">		IncludeProperties(final String aLocation) {</span>
<span class="fc" id="L856">			location = aLocation;</span>
<span class="fc" id="L857">		}</span>

		/**
		 * Adds a value to the properties set. This has been overridden to support the Configuration extensions (e.g.
		 * the &quot;include&quot; directive).
		 *
		 * @param aKey the key to add
		 * @param aValue the value to add
		 * @return the old value for the key, or null if there was no previously associated value.
		 */
		@Override
		public Object put(final Object aKey, final Object aValue) {
<span class="fc" id="L869">			String key = (String) aKey;</span>
<span class="fc" id="L870">			String value = (String) aValue;</span>

			// Act on &quot;include&quot; directives immediately
<span class="fc bfc" id="L873" title="All 2 branches covered.">			if (INCLUDE.equals(key)) {</span>
<span class="fc" id="L874">				DefaultInternalConfiguration.this.load(parseStringArray(value));</span>
<span class="fc" id="L875">				return value;</span>
			} else {
				// Check for a trailing &quot;+&quot; sign on the key (or a leading &quot;+= on the value&quot;)
<span class="fc" id="L878">				boolean append = false;</span>

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">				if (key.endsWith(&quot;+&quot;)) {</span>
<span class="nc" id="L881">					key = key.substring(0, key.length() - 1);</span>
<span class="nc" id="L882">					append = true;</span>
<span class="pc bpc" id="L883" title="2 of 4 branches missed.">				} else if (value != null &amp;&amp; value.startsWith(&quot;+=&quot;)) {</span>
					// If the line contained &quot;key += value&quot; then the Properties will have parsed this as 'key'
					// and '+= value'
<span class="nc" id="L886">					value = value.substring(2).trim();</span>
<span class="nc" id="L887">					append = true;</span>
				}

<span class="pc bpc" id="L890" title="1 of 2 branches missed.">				if (append) {</span>
<span class="nc" id="L891">					String already = DefaultInternalConfiguration.this.get(key);</span>

					// If there is no value already, strip off the leading comma, otherwise append.
<span class="nc bnc" id="L894" title="All 2 branches missed.">					value = (already != null ? already + &quot;,&quot; + value : value);</span>
				}

<span class="fc" id="L897">				DefaultInternalConfiguration.this.load(key, value, location);</span>

<span class="fc" id="L899">				return super.put(key, value);</span>
			}
		}
	}

	/**
	 * The parameters implementation can not depend on a logging framework to log errors, as it is typically used to
	 * configure logging.
	 *
	 * @param message the message to log.
	 */
	private static void log(final String message) {
<span class="nc" id="L911">		System.out.println(message);</span>
<span class="nc" id="L912">	}</span>

	// -----------------------------------------------------------------------------------------------------------------
	// The rest of this class is the implementation of Configuration interface
	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getInt(final String key, final int defolt) {
		try {
<span class="fc" id="L922">			String value = get(key);</span>

<span class="fc bfc" id="L924" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L925">				return defolt;</span>
			}

<span class="fc" id="L928">			return Integer.parseInt(value);</span>
<span class="fc" id="L929">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L930">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getInt(final String key) {
<span class="fc" id="L939">		return getInt(key, 0);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public short getShort(final String key) {
<span class="fc" id="L947">		return getShort(key, (short) 0);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public short getShort(final String key, final short defaultValue) {
		try {
<span class="fc" id="L956">			String value = get(key);</span>

<span class="fc bfc" id="L958" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L959">				return defaultValue;</span>
			}

<span class="fc" id="L962">			return Short.parseShort(value);</span>
<span class="fc" id="L963">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L964">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Short getShort(final String key, final Short defaultValue) {
		try {
<span class="fc" id="L974">			String value = get(key);</span>

<span class="pc bpc" id="L976" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L977">				return defaultValue;</span>
			}

<span class="nc" id="L980">			return Short.valueOf(value);</span>
<span class="nc" id="L981">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L982">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void addProperty(final String key, final Object value) {
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">		if (containsKey(key)) {</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">			String newValue = get(key) + ',' + (value == null ? &quot;&quot; : value);</span>
<span class="fc" id="L993">			addOrModifyProperty(key, newValue);</span>
<span class="fc" id="L994">		} else {</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">			addOrModifyProperty(key, value == null ? null : value.toString());</span>
		}
<span class="fc" id="L997">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void clear() {
<span class="nc" id="L1004">		backing.clear();</span>
<span class="nc" id="L1005">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void clearProperty(final String key) {
<span class="fc" id="L1012">		backing.remove(key);</span>
<span class="fc" id="L1013">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean containsKey(final String key) {
<span class="fc" id="L1020">		return backing.containsKey(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public BigDecimal getBigDecimal(final String key) {
<span class="fc" id="L1028">		return getBigDecimal(key, new BigDecimal(&quot;0.0&quot;));</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public BigDecimal getBigDecimal(final String key, final BigDecimal defaultValue) {
		try {
<span class="fc" id="L1037">			String value = get(key);</span>

<span class="fc bfc" id="L1039" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1040">				return defaultValue;</span>
			}

<span class="fc" id="L1043">			return new BigDecimal(value);</span>
<span class="fc" id="L1044">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1045">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public BigInteger getBigInteger(final String key) {
<span class="fc" id="L1054">		return getBigInteger(key, BigInteger.ZERO);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public BigInteger getBigInteger(final String key, final BigInteger defaultValue) {
		try {
<span class="fc" id="L1063">			String value = get(key);</span>

<span class="fc bfc" id="L1065" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1066">				return defaultValue;</span>
			}

<span class="fc" id="L1069">			return new BigInteger(value);</span>
<span class="fc" id="L1070">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1071">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean getBoolean(final String key) {
<span class="fc" id="L1080">		return booleanBacking.contains(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean getBoolean(final String key, final boolean defaultValue) {
<span class="fc bfc" id="L1088" title="All 2 branches covered.">		return containsKey(key) ? getBoolean(key) : defaultValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Boolean getBoolean(final String key, final Boolean defaultValue) {
<span class="pc bpc" id="L1096" title="1 of 2 branches missed.">		return containsKey(key) ? Boolean.valueOf(getBoolean(key)) : defaultValue;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public byte getByte(final String key) {
<span class="fc" id="L1104">		return getByte(key, (byte) 0);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public byte getByte(final String key, final byte defaultValue) {
		try {
<span class="fc" id="L1113">			String value = get(key);</span>

<span class="fc bfc" id="L1115" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1116">				return defaultValue;</span>
			}

<span class="fc" id="L1119">			return Byte.parseByte(value);</span>
<span class="fc" id="L1120">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1121">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Byte getByte(final String key, final Byte defaultValue) {
		try {
<span class="fc" id="L1131">			String value = get(key);</span>

<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L1134">				return defaultValue;</span>
			}

<span class="nc" id="L1137">			return Byte.valueOf(value);</span>
<span class="nc" id="L1138">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L1139">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public double getDouble(final String key) {
<span class="fc" id="L1148">		return getDouble(key, 0.0);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public double getDouble(final String key, final double defaultValue) {
		try {
<span class="fc" id="L1157">			String value = get(key);</span>

<span class="fc bfc" id="L1159" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1160">				return defaultValue;</span>
			}

<span class="fc" id="L1163">			return Double.parseDouble(value);</span>
<span class="fc" id="L1164">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1165">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Double getDouble(final String key, final Double defaultValue) {
		try {
<span class="fc" id="L1175">			String value = get(key);</span>

<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L1178">				return defaultValue;</span>
			}

<span class="nc" id="L1181">			return Double.valueOf(value);</span>
<span class="nc" id="L1182">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L1183">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public float getFloat(final String key) {
<span class="fc" id="L1192">		return getFloat(key, 0.0f);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public float getFloat(final String key, final float defaultValue) {
		try {
<span class="fc" id="L1201">			String value = get(key);</span>

<span class="fc bfc" id="L1203" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1204">				return defaultValue;</span>
			}

<span class="fc" id="L1207">			return Float.parseFloat(value);</span>
<span class="fc" id="L1208">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1209">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Float getFloat(final String key, final Float defaultValue) {
		try {
<span class="fc" id="L1219">			String value = get(key);</span>

<span class="pc bpc" id="L1221" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L1222">				return defaultValue;</span>
			}

<span class="nc" id="L1225">			return Float.valueOf(value);</span>
<span class="nc" id="L1226">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L1227">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Integer getInteger(final String key, final Integer defaultValue) {
		try {
<span class="fc" id="L1237">			String value = get(key);</span>

<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L1240">				return defaultValue;</span>
			}

<span class="nc" id="L1243">			return Integer.valueOf(value);</span>
<span class="nc" id="L1244">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L1245">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Iterator&lt;String&gt; getKeys() {
<span class="fc" id="L1254">		return backing.keySet().iterator();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Iterator&lt;String&gt; getKeys(final String prefix) {
<span class="nc" id="L1262">		Set&lt;String&gt; keys = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L1264" title="All 2 branches missed.">		for (String key : backing.keySet()) {</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">			if (key.startsWith(prefix)) {</span>
<span class="nc" id="L1266">				keys.add(key);</span>
			}
<span class="nc" id="L1268">		}</span>

<span class="nc" id="L1270">		return keys.iterator();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List getList(final String key) {
<span class="fc" id="L1278">		return getList(key, new ArrayList(1));</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List getList(final String key, final List defaultValue) {
<span class="fc bfc" id="L1286" title="All 2 branches covered.">		if (containsKey(key)) {</span>
<span class="fc" id="L1287">			return Arrays.asList(getStringArray(key));</span>
		} else {
<span class="fc" id="L1289">			return defaultValue;</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getLong(final String key) {
<span class="fc" id="L1298">		return getLong(key, 0L);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public long getLong(final String key, final long defaultValue) {
		try {
<span class="fc" id="L1307">			String value = get(key);</span>

<span class="fc bfc" id="L1309" title="All 2 branches covered.">			if (value == null) {</span>
<span class="fc" id="L1310">				return defaultValue;</span>
			}

<span class="fc" id="L1313">			return Long.parseLong(value);</span>
<span class="fc" id="L1314">		} catch (NumberFormatException ex) {</span>
<span class="fc" id="L1315">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Long getLong(final String key, final Long defaultValue) {
		try {
<span class="fc" id="L1325">			String value = get(key);</span>

<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">			if (value == null) {</span>
<span class="fc" id="L1328">				return defaultValue;</span>
			}

<span class="nc" id="L1331">			return Long.valueOf(value);</span>
<span class="nc" id="L1332">		} catch (NumberFormatException ex) {</span>
<span class="nc" id="L1333">			throw new ConversionException(ex);</span>
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Properties getProperties(final String key) {
<span class="fc" id="L1342">		String[] keyValuePairs = getStringArray(key);</span>

<span class="fc" id="L1344">		Properties props = new Properties();</span>

<span class="fc bfc" id="L1346" title="All 2 branches covered.">		for (String pair : keyValuePairs) {</span>
<span class="fc" id="L1347">			int index = pair.indexOf('=');</span>

<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">			if (index &lt; 1) {</span>
<span class="nc" id="L1350">				throw new IllegalArgumentException(&quot;Malformed property: &quot; + pair);</span>
			}

<span class="fc" id="L1353">			props.put(pair.substring(0, index), pair.substring(index + 1, pair.length()));</span>
		}

<span class="fc" id="L1356">		return props;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Object getProperty(final String key) {
<span class="fc" id="L1364">		return get(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getString(final String key) {
<span class="fc" id="L1372">		return get(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getString(final String key, final String defaultValue) {
<span class="fc" id="L1380">		return get(key, defaultValue);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String[] getStringArray(final String key) {
<span class="fc" id="L1388">		String list = get(key);</span>

<span class="fc bfc" id="L1390" title="All 2 branches covered.">		if (list == null) {</span>
<span class="fc" id="L1391">			return new String[0];</span>
		}

<span class="fc" id="L1394">		return parseStringArray(list);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isEmpty() {
<span class="nc" id="L1402">		return backing.isEmpty();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setProperty(final String key, final Object value) {
<span class="fc bfc" id="L1410" title="All 2 branches covered.">		addOrModifyProperty(key, value == null ? null : value.toString());</span>
<span class="fc" id="L1411">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Configuration subset(final String prefix) {
<span class="nc" id="L1418">		return new MapConfiguration(getSubProperties(prefix, false));</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>