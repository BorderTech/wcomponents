<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>WVideo.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">WVideo.java</span></div><h1>WVideo.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.util.Util;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * WVideo is used to display video content on the client.
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
public class WVideo extends AbstractWComponent implements Targetable, AjaxTarget, Disableable {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L21">	private static final Log LOG = LogFactory.getLog(WVideo.class);</span>

	/**
	 * This request parameter is used to determine which video clip to serve up.
	 */
	private static final String VIDEO_INDEX_REQUEST_PARAM_KEY = &quot;WVideo.videoIndex&quot;;

	/**
	 * This request parameter is used to determine which track to serve up.
	 */
	private static final String TRACK_INDEX_REQUEST_PARAM_KEY = &quot;WVideo.trackIndex&quot;;

	/**
	 * This request parameter is used to request the poster image.
	 */
	private static final String POSTER_REQUEST_PARAM_KEY = &quot;WVideo.poster&quot;;

	/**
	 * This is used to indicate whether pre-loading of content should occur before the clip is played.
	 */
<span class="pc" id="L41">	public enum Preload {</span>
		/**
		 * Do not pre-load any data.
		 */
<span class="fc" id="L45">		NONE,</span>
		/**
		 * Preload meta-data only.
		 */
<span class="fc" id="L49">		META_DATA,</span>
		/**
		 * Let the client determine what to load.
		 */
<span class="fc" id="L53">		AUTO</span>
	}

	/**
	 * This is used to indicate which playback controls to display for the video.
	 *
	 * &lt;p&gt;
	 * &lt;strong&gt;Note:&lt;/strong&gt;
	 * Advancements in video support in clients since this API was first implemented means that most of this is now
	 * redundant. Under most circumstances the UI will display their native video controls. Where a particular WVideo
	 * does not have any source which is able to be played by the client then links to all sources will be provided.
	 * This enum is not worthless as the values NONE and PLAY_PAUSE are used to turn off native video controls in the
	 * client. The value NONE however causes major problems and is incompatible with autoplay for a11y reasons so it
	 * basically makes the media worthless. This enum may be replaced in the future with a simple boolean to trigger
	 * native controls or play/pause only (see https://github.com/BorderTech/wcomponents/issues/503).
	 * &lt;/p&gt;
	 */
<span class="pc" id="L70">	public enum Controls {</span>
		/**
		 * Do not display any controls: not recommended. May be incompatible with any of {@link #isAutoplay()} == true,
		 * {@link #isMuted()} == true or {@link #isLoop()} == true. If this value is set then the WVideo control
		 * &lt;strong&gt;MAY NOT WORK AT ALL&lt;/strong&gt;.
		 * @deprecated since 1.1.1 as this is incompatible with WCAG requirements.
		 */
<span class="fc" id="L77">		NONE,</span>
		/**
		 * Display all controls.
		 * @deprecated since 1.1.1 as themes use native video controls.
		 */
<span class="fc" id="L82">		ALL,</span>
		/**
		 * A combined play/pause button.
		 */
<span class="fc" id="L86">		PLAY_PAUSE,</span>
		/**
		 * Displays the &quot;default&quot; set of controls for the theme.
		 * @deprecated since 1.1.1 as themes use native video controls.
		 */
<span class="fc" id="L91">		DEFAULT,</span>
		/**
		 * Displays the client's native set of controls.
		 */
<span class="fc" id="L95">		NATIVE</span>
	}

	/**
	 * Creates a WVideo with no video clips. Video clips must be added later by calling one of the setVideo(...)
	 * methods.
	 */
<span class="fc" id="L102">	public WVideo() {</span>
<span class="fc" id="L103">	}</span>

	/**
	 * Creates a WVideo with the given video clip.
	 *
	 * @param video the video clip.
	 */
	public WVideo(final Video video) {
<span class="fc" id="L111">		this(new Video[]{video});</span>
<span class="fc" id="L112">	}</span>

	/**
	 * &lt;p&gt;
	 * Creates a WVideo with the given static content. This is provided as a convenience method for when the video file
	 * is included as static content in the class path rather than in the web application's resources.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The mime type for the video clip is looked up from the &quot;mimeType.*&quot; mapping configuration parameters using the
	 * resource's file extension.
	 * &lt;/p&gt;
	 *
	 * @param resource the resource path to the video file.
	 */
	public WVideo(final String resource) {
<span class="nc" id="L127">		this(new VideoResource(resource));</span>
<span class="nc" id="L128">	}</span>

	/**
	 * Creates a WVideo with the given video clip in multiple formats. The client will try to load the first video clip,
	 * and if it fails or isn't supported, it will move on to the next video clip. Only the first clip which can be
	 * played on the client will be used.
	 *
	 * @param video multiple formats for the same the video clip.
	 */
<span class="fc" id="L137">	public WVideo(final Video[] video) {</span>
<span class="fc" id="L138">		setVideo(video);</span>
<span class="fc" id="L139">	}</span>

	/**
	 * Sets the video clip.
	 *
	 * @param video the video clip.
	 */
	public void setVideo(final Video video) {
<span class="fc" id="L147">		setVideo(new Video[]{video});</span>
<span class="fc" id="L148">	}</span>

	/**
	 * Sets the video clip in multiple formats. The client will try to load the first video clip, and if it fails or
	 * isn't supported, it will move on to the next video clip. Only the first clip which can be played on the client
	 * will be used.
	 *
	 * @param video multiple formats for the same the video clip.
	 */
	public void setVideo(final Video[] video) {
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">		List&lt;Video&gt; list = video == null ? null : Arrays.asList(video);</span>
<span class="fc" id="L159">		getOrCreateComponentModel().video = list;</span>
<span class="fc" id="L160">	}</span>

	/**
	 * Retrieves the video clips associated with this WVideo.
	 *
	 * @return the video clips, may be null.
	 */
	public Video[] getVideo() {
<span class="fc" id="L168">		List&lt;Video&gt; list = getComponentModel().video;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">		return list == null ? null : list.toArray(new Video[]{});</span>
	}

	/**
	 * Indicates whether the video component is disabled.
	 *
	 * @return true if the component is disabled, otherwise false.
	 */
	@Override
	public boolean isDisabled() {
<span class="fc" id="L179">		return isFlagSet(ComponentModel.DISABLED_FLAG);</span>
	}

	/**
	 * Sets whether the video component is disabled.
	 *
	 * @param disabled if true, the component is disabled. If false, it is enabled.
	 */
	@Override
	public void setDisabled(final boolean disabled) {
<span class="fc" id="L189">		setFlag(ComponentModel.DISABLED_FLAG, disabled);</span>
<span class="fc" id="L190">	}</span>

	/**
	 * @return true if the clip should start playing automatically, false for a manual start.
	 */
	public boolean isAutoplay() {
<span class="fc" id="L196">		return getComponentModel().autoplay;</span>
	}

	/**
	 * Sets whether the clip should play automatically.
	 *
	 * @param autoplay true to start playing automatically, false for a manual start.
	 */
	public void setAutoplay(final boolean autoplay) {
<span class="fc" id="L205">		getOrCreateComponentModel().autoplay = autoplay;</span>
<span class="fc" id="L206">	}</span>

	/**
	 * @return the media group name.
	 */
	public String getMediaGroup() {
<span class="fc" id="L212">		return getComponentModel().mediaGroup;</span>
	}

	/**
	 * Sets the media group.
	 *
	 * @param mediaGroup The media group name.
	 */
	public void setMediaGroup(final String mediaGroup) {
<span class="fc" id="L221">		getOrCreateComponentModel().mediaGroup = mediaGroup;</span>
<span class="fc" id="L222">	}</span>

	/**
	 * Indicates whether the video clip playback should loop.
	 *
	 * @return true to loop, false to stop at the end.
	 */
	public boolean isLoop() {
<span class="fc" id="L230">		return getComponentModel().loop;</span>
	}

	/**
	 * Sets whether the video clip playback should loop or stop at the end.
	 *
	 * @param loop true to loop, false to stop at the end.
	 */
	public void setLoop(final boolean loop) {
<span class="fc" id="L239">		getOrCreateComponentModel().loop = loop;</span>
<span class="fc" id="L240">	}</span>

	/**
	 * Indicates whether the video's audio should initially be muted.
	 *
	 * @return true if muted, false otherwise.
	 */
	public boolean isMuted() {
<span class="fc" id="L248">		return getComponentModel().muted;</span>
	}

	/**
	 * Sets whether the video's audio should initially be muted.
	 *
	 * @param muted true to mute the audio, false to play normally.
	 */
	public void setMuted(final boolean muted) {
<span class="fc" id="L257">		getOrCreateComponentModel().muted = muted;</span>
<span class="fc" id="L258">	}</span>

	/**
	 * Indicates which playback controls (e.g. stop/start/pause) to display on the video component.
	 *
	 * @return the playback controls to display.
	 */
	public Controls getControls() {
<span class="fc" id="L266">		return getComponentModel().controls;</span>
	}

	/**
	 * Sets which playback controls (e.g. stop/start/pause) to display on the video component. The values of
	 * {@link Controls#NONE} and {@link Controls#ALL} take precedence over all other values. Passing a null or empty set
	 * of controls will cause the client's default set of controls to be used.
	 *
	 * @param controls the playback controls to display.
	 */
	public void setControls(final Controls controls) {
<span class="fc" id="L277">		getOrCreateComponentModel().controls = controls;</span>
<span class="fc" id="L278">	}</span>

	/**
	 * Indicates how pre-loading of content should occur before the clip is played.
	 *
	 * @return the pre-loading mode.
	 */
	public Preload getPreload() {
<span class="fc" id="L286">		return getComponentModel().preload;</span>
	}

	/**
	 * Sets how pre-loading of content should occur before the clip is played.
	 *
	 * @param preload the pre-loading mode.
	 */
	public void setPreload(final Preload preload) {
<span class="fc" id="L295">		getOrCreateComponentModel().preload = preload;</span>
<span class="fc" id="L296">	}</span>

	/**
	 * @return alternative text to display when the video clip can not be played.
	 */
	public String getAltText() {
<span class="fc" id="L302">		return getComponentModel().altText;</span>
	}

	/**
	 * Sets the alternative text to display when the video clip can not be played.
	 *
	 * @param altText the text to set.
	 */
	public void setAltText(final String altText) {
<span class="fc" id="L311">		getOrCreateComponentModel().altText = altText;</span>
<span class="fc" id="L312">	}</span>

	/**
	 * @return the width of the video playback region on the client, in pixels.
	 */
	public int getWidth() {
<span class="fc" id="L318">		return getComponentModel().width;</span>
	}

	/**
	 * Sets the width of the video playback region on the client.
	 *
	 * @param width the width of the video playback region, in pixels.
	 */
	public void setWidth(final int width) {
<span class="fc" id="L327">		getOrCreateComponentModel().width = width;</span>
<span class="fc" id="L328">	}</span>

	/**
	 * @return the height of the video playback region on the client, in pixels.
	 */
	public int getHeight() {
<span class="fc" id="L334">		return getComponentModel().height;</span>
	}

	/**
	 * Sets the height of the video playback region on the client.
	 *
	 * @param height the height of the video playback region, in pixels.
	 */
	public void setHeight(final int height) {
<span class="fc" id="L343">		getOrCreateComponentModel().height = height;</span>
<span class="fc" id="L344">	}</span>

	/**
	 * Retrieves the default poster image. The poster image is displayed by the client when the video is not playing.
	 *
	 * @return the default poster image.
	 */
	public Image getPoster() {
<span class="nc" id="L352">		return getComponentModel().poster;</span>
	}

	/**
	 * Sets the default poster image. The poster image is displayed by the client when the video is not playing.
	 *
	 * @param poster the default poster image.
	 */
	public void setPoster(final Image poster) {
<span class="fc" id="L361">		getOrCreateComponentModel().poster = poster;</span>
<span class="fc" id="L362">	}</span>

	/**
	 * Sets the tracks for the video. The tracks are used to provide additional information relating to the video, for
	 * example subtitles.
	 *
	 * @param tracks additional tracks relating to the video.
	 */
	public void setTracks(final Track[] tracks) {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">		List&lt;Track&gt; list = tracks == null ? null : Arrays.asList(tracks);</span>
<span class="fc" id="L372">		getOrCreateComponentModel().tracks = list;</span>
<span class="fc" id="L373">	}</span>

	/**
	 * Retrieves additional tracks associated with the video. The tracks provide additional information relating to the
	 * video, for example subtitles.
	 *
	 * @return the video clips, may be null.
	 */
	public Track[] getTracks() {
<span class="fc" id="L382">		List&lt;Track&gt; list = getComponentModel().tracks;</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">		return list == null ? null : list.toArray(new Track[]{});</span>
	}

	/**
	 * Creates dynamic URLs that the video clips can be loaded from. In fact the URL points to the main application
	 * servlet, but includes a non-null for the parameter associated with this WComponent (ie, its label). The
	 * handleRequest method below detects this when the browser requests a file.
	 *
	 * @return the urls to load the video files from, or null if there are no clips defined.
	 */
	public String[] getVideoUrls() {
<span class="fc" id="L394">		Video[] video = getVideo();</span>

<span class="pc bpc" id="L396" title="2 of 4 branches missed.">		if (video == null || video.length == 0) {</span>
<span class="nc" id="L397">			return null;</span>
		}

<span class="fc" id="L400">		String[] urls = new String[video.length];</span>

		// this variable needs to be set in the portlet environment.
<span class="fc" id="L403">		String url = getEnvironment().getWServletPath();</span>
<span class="fc" id="L404">		Map&lt;String, String&gt; parameters = getBaseParameterMap();</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">		for (int i = 0; i &lt; urls.length; i++) {</span>
<span class="fc" id="L407">			parameters.put(VIDEO_INDEX_REQUEST_PARAM_KEY, String.valueOf(i));</span>
<span class="fc" id="L408">			urls[i] = WebUtilities.getPath(url, parameters, true);</span>
		}

<span class="fc" id="L411">		return urls;</span>
	}

	/**
	 * Creates dynamic URLs that the video clips can be loaded from. In fact the URL points to the main application
	 * servlet, but includes a non-null for the parameter associated with this WComponent (ie, its label). The
	 * handleRequest method below detects this when the browser requests a file.
	 *
	 * @return the urls to load the video files from, or null if there are no clips defined.
	 */
	public String[] getTrackUrls() {
<span class="fc" id="L422">		Track[] tracks = getTracks();</span>

<span class="pc bpc" id="L424" title="2 of 4 branches missed.">		if (tracks == null || tracks.length == 0) {</span>
<span class="nc" id="L425">			return null;</span>
		}

<span class="fc" id="L428">		String[] urls = new String[tracks.length];</span>

		// this variable needs to be set in the portlet environment.
<span class="fc" id="L431">		String url = getEnvironment().getWServletPath();</span>
<span class="fc" id="L432">		Map&lt;String, String&gt; parameters = getBaseParameterMap();</span>

<span class="fc bfc" id="L434" title="All 2 branches covered.">		for (int i = 0; i &lt; urls.length; i++) {</span>
<span class="fc" id="L435">			parameters.put(TRACK_INDEX_REQUEST_PARAM_KEY, String.valueOf(i));</span>
<span class="fc" id="L436">			urls[i] = WebUtilities.getPath(url, parameters, true);</span>
		}

<span class="fc" id="L439">		return urls;</span>
	}

	/**
	 * Creates a dynamic URL that the poster can be loaded from. In fact the URL points to the main application servlet,
	 * but includes a non-null for the parameter associated with this WComponent (ie, its label). The handleRequest
	 * method below detects this when the browser requests a file.
	 *
	 * @return the url to load the poster from, or null if there is no poster defined.
	 */
	public String getPosterUrl() {
<span class="fc" id="L450">		Image poster = getComponentModel().poster;</span>

<span class="fc bfc" id="L452" title="All 2 branches covered.">		if (poster == null) {</span>
<span class="fc" id="L453">			return null;</span>
		}

		// this variable needs to be set in the portlet environment.
<span class="fc" id="L457">		String url = getEnvironment().getWServletPath();</span>
<span class="fc" id="L458">		Map&lt;String, String&gt; parameters = getBaseParameterMap();</span>
<span class="fc" id="L459">		parameters.put(POSTER_REQUEST_PARAM_KEY, &quot;x&quot;);</span>
<span class="fc" id="L460">		return WebUtilities.getPath(url, parameters, true);</span>
	}

	/**
	 * Retrieves the base parameter map for serving content (videos + tracks).
	 *
	 * @return the base map for serving content.
	 */
	private Map&lt;String, String&gt; getBaseParameterMap() {
<span class="fc" id="L469">		Environment env = getEnvironment();</span>
<span class="fc" id="L470">		Map&lt;String, String&gt; parameters = env.getHiddenParameters();</span>
<span class="fc" id="L471">		parameters.put(Environment.TARGET_ID, getTargetId());</span>

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">		if (Util.empty(getCacheKey())) {</span>
			// Add some randomness to the URL to prevent caching
<span class="nc" id="L475">			String random = WebUtilities.generateRandom();</span>
<span class="nc" id="L476">			parameters.put(Environment.UNIQUE_RANDOM_PARAM, random);</span>
<span class="nc" id="L477">		} else {</span>
			// Remove step counter as not required for cached content
<span class="fc" id="L479">			parameters.remove(Environment.STEP_VARIABLE);</span>
<span class="fc" id="L480">			parameters.remove(Environment.SESSION_TOKEN_VARIABLE);</span>
			// Add the cache key
<span class="fc" id="L482">			parameters.put(Environment.CONTENT_CACHE_KEY, getCacheKey());</span>
		}

<span class="fc" id="L485">		return parameters;</span>
	}

	/**
	 * Override isVisible to also return false if there are no video clips to play.
	 *
	 * @return true if this component is visible in the given context, otherwise false.
	 */
	@Override
	public boolean isVisible() {
<span class="pc bpc" id="L495" title="1 of 2 branches missed.">		if (!super.isVisible()) {</span>
<span class="nc" id="L496">			return false;</span>
		}

<span class="fc" id="L499">		Video[] video = getVideo();</span>
<span class="pc bpc" id="L500" title="1 of 4 branches missed.">		return video != null &amp;&amp; video.length &gt; 0;</span>
	}

	/**
	 * When an video element is rendered to the client, the browser will make a second request to get the video content.
	 * The handleRequest method has been overridden to detect whether the request is the &quot;content fetch&quot; request by
	 * looking for the parameter that we encode in the content url.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	public void handleRequest(final Request request) {
<span class="fc" id="L512">		super.handleRequest(request);</span>


<span class="fc" id="L515">		String targ = request.getParameter(Environment.TARGET_ID);</span>
<span class="pc bpc" id="L516" title="1 of 4 branches missed.">		boolean contentReqested = (targ != null &amp;&amp; targ.equals(getTargetId()));</span>

<span class="fc bfc" id="L518" title="All 4 branches covered.">		if (contentReqested &amp;&amp; request.getParameter(POSTER_REQUEST_PARAM_KEY) != null) {</span>
<span class="nc" id="L519">			handlePosterRequest();</span>
		}

<span class="pc bpc" id="L522" title="1 of 2 branches missed.">		if (isDisabled()) {</span>
<span class="nc" id="L523">			return;</span>
		}

<span class="fc bfc" id="L526" title="All 2 branches covered.">		if (contentReqested) {</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">			if (request.getParameter(VIDEO_INDEX_REQUEST_PARAM_KEY) != null) {</span>
<span class="nc" id="L528">				handleVideoRequest(request);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">			} else if (request.getParameter(TRACK_INDEX_REQUEST_PARAM_KEY) != null) {</span>
<span class="nc" id="L530">				handleTrackRequest(request);</span>
			}
		}
<span class="fc" id="L533">	}</span>

	/**
	 * Handles a request for the poster.
	 */
	private void handlePosterRequest() {
<span class="fc" id="L539">		Image poster = getComponentModel().poster;</span>

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">		if (poster != null) {</span>
<span class="fc" id="L542">			ContentEscape escape = new ContentEscape(poster);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			escape.setCacheable(!Util.empty(getCacheKey()));</span>
<span class="fc" id="L544">			throw escape;</span>
		} else {
<span class="nc" id="L546">			LOG.warn(&quot;Client requested non-existant poster&quot;);</span>
		}
<span class="nc" id="L548">	}</span>

	/**
	 * Handles a request for a video.
	 *
	 * @param request the request being responded to.
	 */
	private void handleVideoRequest(final Request request) {
<span class="fc" id="L556">		String videoRequested = request.getParameter(VIDEO_INDEX_REQUEST_PARAM_KEY);</span>
<span class="fc" id="L557">		int videoFileIndex = 0;</span>

		try {
<span class="fc" id="L560">			videoFileIndex = Integer.parseInt(videoRequested);</span>
<span class="nc" id="L561">		} catch (NumberFormatException e) {</span>
<span class="nc" id="L562">			LOG.error(&quot;Failed to parse video index: &quot; + videoFileIndex);</span>
<span class="fc" id="L563">		}</span>

<span class="fc" id="L565">		Video[] video = getVideo();</span>

<span class="pc bpc" id="L567" title="3 of 6 branches missed.">		if (video != null &amp;&amp; videoFileIndex &gt;= 0 &amp;&amp; videoFileIndex &lt; video.length) {</span>
<span class="fc" id="L568">			ContentEscape escape = new ContentEscape(video[videoFileIndex]);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">			escape.setCacheable(!Util.empty(getCacheKey()));</span>
<span class="fc" id="L570">			throw escape;</span>
		} else {
<span class="nc" id="L572">			LOG.warn(&quot;Client requested invalid video clip: &quot; + videoFileIndex);</span>
		}
<span class="nc" id="L574">	}</span>

	/**
	 * Handles a request for an auxillary track.
	 *
	 * @param request the request being responded to.
	 */
	private void handleTrackRequest(final Request request) {
<span class="fc" id="L582">		String trackRequested = request.getParameter(TRACK_INDEX_REQUEST_PARAM_KEY);</span>
<span class="fc" id="L583">		int trackIndex = 0;</span>

		try {
<span class="fc" id="L586">			trackIndex = Integer.parseInt(trackRequested);</span>
<span class="nc" id="L587">		} catch (NumberFormatException e) {</span>
<span class="nc" id="L588">			LOG.error(&quot;Failed to parse track index: &quot; + trackIndex);</span>
<span class="fc" id="L589">		}</span>

<span class="fc" id="L591">		Track[] tracks = getTracks();</span>

<span class="pc bpc" id="L593" title="3 of 6 branches missed.">		if (tracks != null &amp;&amp; trackIndex &gt;= 0 &amp;&amp; trackIndex &lt; tracks.length) {</span>
<span class="fc" id="L594">			ContentEscape escape = new ContentEscape(tracks[trackIndex]);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">			escape.setCacheable(!Util.empty(getCacheKey()));</span>
<span class="fc" id="L596">			throw escape;</span>
		} else {
<span class="nc" id="L598">			LOG.warn(&quot;Client requested invalid track: &quot; + trackIndex);</span>
		}
<span class="nc" id="L600">	}</span>

	/**
	 * @return the cacheKey
	 */
	public String getCacheKey() {
<span class="fc" id="L606">		return getComponentModel().cacheKey;</span>
	}

	/**
	 * @param cacheKey the cacheKey to set.
	 */
	public void setCacheKey(final String cacheKey) {
<span class="fc" id="L613">		getOrCreateComponentModel().cacheKey = cacheKey;</span>
<span class="fc" id="L614">	}</span>

	/**
	 * Returns the id to use to target this component.
	 *
	 * @return this component's target id.
	 */
	@Override
	public String getTargetId() {
<span class="fc" id="L623">		return getId();</span>
	}

	/**
	 * @return a String representation of this component, for debugging purposes.
	 */
	@Override
	public String toString() {
<span class="nc" id="L631">		String text = getAltText();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">		return toString(text == null ? null : ('&quot;' + text + '&quot;'));</span>
	}

	// --------------------------------
	// Extrinsic state management
	/**
	 * Creates a new component model appropriate for this component.
	 *
	 * @return a new VideoModel.
	 */
	@Override
	protected VideoModel newComponentModel() {
<span class="fc" id="L644">		return new VideoModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// For type safety only
	protected VideoModel getComponentModel() {
<span class="fc" id="L653">		return (VideoModel) super.getComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// For type safety only
	protected VideoModel getOrCreateComponentModel() {
<span class="fc" id="L662">		return (VideoModel) super.getOrCreateComponentModel();</span>
	}

	/**
	 * Holds the extrinsic state information of a WVideo.
	 */
<span class="fc" id="L668">	public static class VideoModel extends ComponentModel {</span>

		/**
		 * The various video clips.
		 */
		private List&lt;Video&gt; video;

		/**
		 * Additional tracks relating to the video, e.g. subtitles.
		 */
		private List&lt;Track&gt; tracks;

		/**
		 * The cache key used to control client-side caching.
		 */
		private String cacheKey;

		/**
		 * Indicates whether the video should play immediately after page load.
		 */
		private boolean autoplay;

		/**
		 * Indicates whether playback of the video clip should be looped.
		 */
		private boolean loop;

		/**
		 * Indicates whether audio should initially be muted.
		 */
		private boolean muted;

		/**
		 * Indicates which playback controls to display.
		 */
		private Controls controls;

		/**
		 * Indicates whether pre-loading of content should occur before the clip is played.
		 */
<span class="fc" id="L708">		private Preload preload = Preload.NONE;</span>

		/**
		 * Alternate text to display if the video clip can not be played.
		 */
		private String altText;

		/**
		 * The width of the video playback region on the client, in pixels.
		 */
		private int width;

		/**
		 * The height of the video playback region on the client, in pixels.
		 */
		private int height;

		/**
		 * The poster image is displayed in place of the video, until it is loaded.
		 */
		private Image poster;

		/**
		 * This is used to group related media together, for example to synchronize tracks.
		 */
		private String mediaGroup;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>