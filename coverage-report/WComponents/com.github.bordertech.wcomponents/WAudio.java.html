<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>WAudio.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">WAudio.java</span></div><h1>WAudio.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.util.Util;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * WAudio provides a means to play audio content. For most uses this means a HTML audio element. If the client does not
 * implement the audio element or cannot play any of the supplied sources then an alternate means to access the sources
 * is provided.
 *&lt;/p&gt;
 * &lt;p&gt;
 * Each WAudio component must have at least one {@link Audio} resource. Each such resource should be appropriate for
 * delivery over the web and in a format suitable for the application's target browsers. If the application has a
 * mixed browser matrix then it may be appropriate to attach multiple sources to each WAudio. It is &lt;strong&gt;strongly
 * recommended&lt;/strong&gt; that AVI files are &lt;strong&gt;never&lt;/strong&gt; used as an Audio resource.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Every use of WAudio &lt;strong&gt;must&lt;/strong&gt; comply with the requirements outlined in
 * &lt;a href=&quot;https://www.w3.org/TR/media-accessibility-reqs/&quot;&gt;Media Accessibility User Requirements&lt;/a&gt;, and meet
 * guidelines
 * &lt;a href=&quot;https://www.w3.org/WAI/WCAG20/quickref/#media-equiv&quot;&gt;1.2&lt;/a&gt;,
 * &lt;a href=&quot;https://www.w3.org/WAI/WCAG20/quickref/#visual-audio-contrast-dis-audio&quot;&gt;1.4.2&lt;/a&gt; and
 * &lt;a href=&quot;https://www.w3.org/WAI/WCAG20/quickref/#visual-audio-contrast-noaudio&quot;&gt;1.4.7&lt;/a&gt;.
 * &lt;/p&gt;
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
public class WAudio extends AbstractWComponent implements Targetable, AjaxTarget, Disableable {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L39">	private static final Log LOG = LogFactory.getLog(WAudio.class);</span>

	/**
	 * This request parameter is used to determine which audio clip to serve up.
	 */
	private static final String AUDIO_INDEX_REQUEST_PARAM_KEY = &quot;WAudio.index&quot;;

	/**
	 * This is used to indicate whether pre-loading of content should occur before the clip is played. If the audio
	 * clip is a static, cacheable resource then Preload.AUTO is highly recommended. If the clip is not cacheable and
	 * is streamed from the application's resources the default value of Preload.NONE should usually be used.
	 */
<span class="pc" id="L51">	public enum Preload {</span>
		/**
		 * Do not pre-load any data. This is best for clips streamed from the application's resources or live feeds.
		 */
<span class="fc" id="L55">		NONE,</span>
		/**
		 * Preload meta-data only.
		 */
<span class="fc" id="L59">		META_DATA,</span>
		/**
		 * Let the client determine what to load. This is usually best for pre-recorded audio presented as cacheable
		 * static resources.
		 */
<span class="fc" id="L64">		AUTO</span>
	}

	/**
	 * This is used to indicate which playback controls to display for the audio.
	 *
	 * &lt;p&gt;
	 * &lt;strong&gt;Note:&lt;/strong&gt;
	 * Advancements in audio support in clients since this API was first implemented means that most of this is now
	 * redundant. Under most circumstances the UI will display their native audio controls. Where a particular WAudio
	 * does not have any source which is able to be played by the client then links to all sources will be provided.
	 * This enum is not worthless as the values NONE and PLAY_PAUSE are used to turn off native audio controls in the
	 * client. The value NONE however causes major problems and is incompatible with autoplay for a11y reasons so it
	 * basically makes the media worthless. This enum may be replaced in the future with a simple boolean to trigger
	 * native controls or play/pause only (see https://github.com/BorderTech/wcomponents/issues/503).
	 * &lt;/p&gt;
	 */
<span class="pc" id="L81">	public enum Controls {</span>
		/**
		 * Do not display any controls. May be incompatible with either {@link #isAutoplay()} == true or
		 * {@link #isLoop()} == true. If this is set then the WAudio control &lt;strong&gt;MAY NOT WORK&lt;/strong&gt;.
		 * @deprecated since 1.1.1 as this is incompatible with WCAG requirements.
		 */
<span class="fc" id="L87">		NONE,</span>
		/**
		 * Display all controls. What this actually means depends upon the theme.
		 * @deprecated since 1.1.1 as themes use native controls.
		 */
<span class="fc" id="L92">		ALL,</span>
		/**
		 * A combined play/pause button.
		 */
<span class="fc" id="L96">		PLAY_PAUSE,</span>
		/**
		 * Displays the &quot;default&quot; set of controls for the theme.
		 * @deprecated since 1.1.1 as themes use native audio controls.
		 */
<span class="fc" id="L101">		DEFAULT,</span>
		/**
		 * Displays the client's native set of controls.
		 */
<span class="fc" id="L105">		NATIVE</span>
	}

	/**
	 * Creates a WAudio with no audio clips. Audio clips must be added later by calling one of the setAudio(...)
	 * methods.
	 */
<span class="fc" id="L112">	public WAudio() {</span>
<span class="fc" id="L113">	}</span>

	/**
	 * Creates a WAudio with a given audio clip.
	 *
	 * @param audio the audio clip
	 */
	public WAudio(final Audio audio) {
<span class="fc" id="L121">		this(new Audio[]{audio});</span>
<span class="fc" id="L122">	}</span>

	/**
	 * &lt;p&gt;
	 * Creates a WAudio with the given static content. This is provided as a convenience method for when the audio file
	 * is included as static content in the class path rather than in the web application's resources.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The mime type for the audio clip is looked up from the &quot;mimeType.*&quot; mapping configuration parameters using the
	 * resource's file extension.
	 * &lt;/p&gt;
	 *
	 * @param resource the resource path to the audio file
	 */
	public WAudio(final String resource) {
<span class="nc" id="L137">		this(new AudioResource(resource));</span>
<span class="nc" id="L138">	}</span>

	/**
	 * Creates a WAudio with the given audio clip in multiple formats. The client will try to load the first audio clip,
	 * and if it fails or isn't supported, it will move on to the next audio clip. Only the first clip which can be
	 * played on the client will be used.
	 *
	 * @param audio multiple formats for the same the audio clip
	 */
<span class="fc" id="L147">	public WAudio(final Audio[] audio) {</span>
<span class="fc" id="L148">		setAudio(audio);</span>
<span class="fc" id="L149">	}</span>

	/**
	 * Sets the audio clip for all users.
	 *
	 * @param audio the audio clip
	 */
	public void setAudio(final Audio audio) {
<span class="fc" id="L157">		setAudio(new Audio[]{audio});</span>
<span class="fc" id="L158">	}</span>

	/**
	 * Sets the audio clip in multiple formats for all users. The client will try to load the first audio clip, and if
	 * it fails or isn't supported, it will move on to the next audio clip. Only the first clip which can be played on
	 * the client will be used.
	 *
	 * @param audio multiple formats for the same the audio clip
	 */
	public void setAudio(final Audio[] audio) {
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		List&lt;Audio&gt; list = audio == null ? null : Arrays.asList(audio);</span>
<span class="fc" id="L169">		getOrCreateComponentModel().audio = list;</span>
<span class="fc" id="L170">	}</span>

	/**
	 * Retrieves the audio clips associated with this WAudio.
	 *
	 * @return the audio clips, may be null
	 */
	public Audio[] getAudio() {
<span class="fc" id="L178">		List&lt;Audio&gt; list = getComponentModel().audio;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		return list == null ? null : list.toArray(new Audio[]{});</span>
	}

	/**
	 * Indicates whether the audio component is disabled.
	 *
	 * @return true if the component is disabled, otherwise false
	 */
	@Override
	public boolean isDisabled() {
<span class="fc" id="L189">		return isFlagSet(ComponentModel.DISABLED_FLAG);</span>
	}

	/**
	 * Sets whether the audio component is disabled.
	 *
	 * @param disabled if true, the component is disabled. If false, it is enabled
	 */
	@Override
	public void setDisabled(final boolean disabled) {
<span class="fc" id="L199">		setFlag(ComponentModel.DISABLED_FLAG, disabled);</span>
<span class="fc" id="L200">	}</span>

	/**
	 * @return true if the clip should start playing automatically, false for a manual start
	 */
	public boolean isAutoplay() {
<span class="fc" id="L206">		return getComponentModel().autoplay;</span>
	}

	/**
	 * &lt;p&gt;
	 * Sets whether the clip should play automatically. It is &lt;strong&gt;recommended&lt;/strong&gt; that this should not be set
	 * true.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Each instance of WAudio which is set to auto-play must comply with
	 * &lt;a href=&quot;https://www.w3.org/WAI/WCAG20/quickref/#visual-audio-contrast-dis-audio&quot;&gt;guideline 1.4.2&lt;/a&gt;; therefore
	 * this setting is ignored if the WAudio component uses {@link Controls#NONE}.
	 *&lt;/p&gt;
	 *
	 * @param autoplay true to start playing automatically, false for a manual start
	 */
	public void setAutoplay(final boolean autoplay) {
<span class="fc" id="L223">		getOrCreateComponentModel().autoplay = autoplay;</span>
<span class="fc" id="L224">	}</span>

	/**
	 * @return the media group name.
	 */
	public String getMediaGroup() {
<span class="fc" id="L230">		return getComponentModel().mediaGroup;</span>
	}

	/**
	 * Sets the media group. Not currently implemented in the client due to lack of browser support.
	 *
	 * @param mediaGroup The media group name
	 */
	public void setMediaGroup(final String mediaGroup) {
<span class="fc" id="L239">		getOrCreateComponentModel().mediaGroup = mediaGroup;</span>
<span class="fc" id="L240">	}</span>

	/**
	 * Indicates whether the audio clip playback should loop.
	 *
	 * @return true to loop, false to stop at the end
	 */
	public boolean isLoop() {
<span class="fc" id="L248">		return getComponentModel().loop;</span>
	}

	/**
	 * Sets whether the audio clip playback should loop or stop at the end. It is &lt;strong&gt;recommended&lt;/strong&gt;
	 * that this not be set &lt;code&gt;true&lt;/code&gt; as this could cause significant usability issues for some users.
	 *
	 * @param loop true to loop, false to stop at the end
	 */
	public void setLoop(final boolean loop) {
<span class="fc" id="L258">		getOrCreateComponentModel().loop = loop;</span>
<span class="fc" id="L259">	}</span>

	/**
	 * Indicates how pre-loading of content should occur before the clip is played.
	 *
	 * @return the pre-loading mode
	 */
	public Preload getPreload() {
<span class="fc" id="L267">		return getComponentModel().preload;</span>
	}

	/**
	 * Sets how pre-loading of content should occur before the clip is played.
	 *
	 * @param preload the pre-loading mode
	 */
	public void setPreload(final Preload preload) {
<span class="fc" id="L276">		getOrCreateComponentModel().preload = preload;</span>
<span class="fc" id="L277">	}</span>

	/**
	 * @return alternative text to display when the audio clip can not be played.
	 */
	public String getAltText() {
<span class="fc" id="L283">		return getComponentModel().altText;</span>
	}

	/**
	 * Sets the alternative text to display when the audio clip can not be played.
	 *
	 * @param altText the text to set
	 */
	public void setAltText(final String altText) {
<span class="fc" id="L292">		getOrCreateComponentModel().altText = altText;</span>
<span class="fc" id="L293">	}</span>

	/**
	 * Creates dynamic URLs that the audio clips can be loaded from. In fact the URL points to the main application
	 * servlet, but includes a non-null for the parameter associated with this WComponent (ie, its label). The
	 * handleRequest method below detects this when the browser requests a file.
	 *
	 * @return the urls to load the audio files from, or null if there are no clips defined
	 */
	public String[] getAudioUrls() {
<span class="fc" id="L303">		Audio[] audio = getAudio();</span>

<span class="pc bpc" id="L305" title="2 of 4 branches missed.">		if (audio == null || audio.length == 0) {</span>
<span class="nc" id="L306">			return null;</span>
		}

<span class="fc" id="L309">		String[] urls = new String[audio.length];</span>

<span class="fc" id="L311">		Environment env = getEnvironment();</span>
<span class="fc" id="L312">		Map&lt;String, String&gt; parameters = env.getHiddenParameters();</span>
<span class="fc" id="L313">		parameters.put(Environment.TARGET_ID, getTargetId());</span>

<span class="pc bpc" id="L315" title="1 of 2 branches missed.">		if (Util.empty(getCacheKey())) {</span>
			// Add some randomness to the URL to prevent caching
<span class="nc" id="L317">			String random = WebUtilities.generateRandom();</span>
<span class="nc" id="L318">			parameters.put(Environment.UNIQUE_RANDOM_PARAM, random);</span>
<span class="nc" id="L319">		} else {</span>
			// Remove step counter as not required for cached content
<span class="fc" id="L321">			parameters.remove(Environment.STEP_VARIABLE);</span>
<span class="fc" id="L322">			parameters.remove(Environment.SESSION_TOKEN_VARIABLE);</span>
			// Add the cache key
<span class="fc" id="L324">			parameters.put(Environment.CONTENT_CACHE_KEY, getCacheKey());</span>
		}

		// this variable needs to be set in the portlet environment.
<span class="fc" id="L328">		String url = env.getWServletPath();</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">		for (int i = 0; i &lt; urls.length; i++) {</span>
<span class="fc" id="L331">			parameters.put(AUDIO_INDEX_REQUEST_PARAM_KEY, String.valueOf(i));</span>
<span class="fc" id="L332">			urls[i] = WebUtilities.getPath(url, parameters, true);</span>
		}

<span class="fc" id="L335">		return urls;</span>
	}

	/**
	 * Override isVisible to also return false if there are no audio clips to play.
	 *
	 * @return true if this component is visible in the given context, otherwise false
	 */
	@Override
	public boolean isVisible() {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">		if (!super.isVisible()) {</span>
<span class="nc" id="L346">			return false;</span>
		}

<span class="fc" id="L349">		Audio[] audio = getAudio();</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">		return audio != null &amp;&amp; audio.length &gt; 0;</span>
	}

	/**
	 * When an audio element is rendered to the client, the browser will make a second request to get the audio content.
	 * The handleRequest method has been overridden to detect whether the request is the &quot;content fetch&quot; request by
	 * looking for the parameter that we encode in the content url.
	 *
	 * @param request the request being responded to
	 */
	@Override
	public void handleRequest(final Request request) {
<span class="fc" id="L362">		super.handleRequest(request);</span>

<span class="pc bpc" id="L364" title="1 of 2 branches missed.">		if (isDisabled()) {</span>
<span class="nc" id="L365">			return;</span>
		}

<span class="fc" id="L368">		String targ = request.getParameter(Environment.TARGET_ID);</span>
<span class="fc" id="L369">		String audioFileRequested = request.getParameter(AUDIO_INDEX_REQUEST_PARAM_KEY);</span>
<span class="pc bpc" id="L370" title="1 of 4 branches missed.">		boolean contentReqested = targ != null &amp;&amp; targ.equals(getTargetId());</span>

<span class="fc bfc" id="L372" title="All 2 branches covered.">		if (contentReqested) {</span>
<span class="fc" id="L373">			int audioFileIndex = 0;</span>

			try {
<span class="fc" id="L376">				audioFileIndex = Integer.parseInt(audioFileRequested);</span>
<span class="nc" id="L377">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L378">				LOG.error(&quot;Failed to parse audio index: &quot; + audioFileIndex);</span>
<span class="fc" id="L379">			}</span>

<span class="fc" id="L381">			Audio[] audio = getAudio();</span>

<span class="pc bpc" id="L383" title="3 of 6 branches missed.">			if (audio != null &amp;&amp; audioFileIndex &gt;= 0 &amp;&amp; audioFileIndex &lt; audio.length) {</span>
<span class="fc" id="L384">				ContentEscape escape = new ContentEscape(audio[audioFileIndex]);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">				escape.setCacheable(!Util.empty(getCacheKey()));</span>
<span class="fc" id="L386">				throw escape;</span>
			} else {
<span class="nc" id="L388">				LOG.error(&quot;Requested invalid audio clip: &quot; + audioFileIndex);</span>
			}
		}
<span class="fc" id="L391">	}</span>

	/**
	 * @return the cacheKey
	 */
	public String getCacheKey() {
<span class="fc" id="L397">		return getComponentModel().cacheKey;</span>
	}

	/**
	 * Set a cache key to make the audio cacheable on the client. All audio which it is permissible to cache should have
	 * a cache key set. Audio* which is never to be reproduced (such as an audio CAPTCHA) should not have a cache key
	 * set.
	 *
	 * @param cacheKey the cacheKey to set
	 */
	public void setCacheKey(final String cacheKey) {
<span class="fc" id="L408">		getOrCreateComponentModel().cacheKey = cacheKey;</span>
<span class="fc" id="L409">	}</span>

	/**
	 * Indicates which playback controls to display on the audio component.
	 *
	 * @return the playback controls to display
	 */
	public Controls getControls() {
<span class="fc" id="L417">		return getComponentModel().controls;</span>
	}

	/**
	 * Sets which playback controls to display on the audio component. Passing a null or empty set of controls will
	 * cause the client's default set of controls to be used.
	 *
	 * @param controls the playback controls to display
	 */
	public void setControls(final Controls controls) {
<span class="fc" id="L427">		getOrCreateComponentModel().controls = controls;</span>
<span class="fc" id="L428">	}</span>

	/**
	 * Returns the id to use to target this component.
	 *
	 * @return this component's target id
	 */
	@Override
	public String getTargetId() {
<span class="fc" id="L437">		return getId();</span>
	}

	/**
	 * @return a String representation of this component usually for debugging purposes
	 */
	@Override
	public String toString() {
<span class="nc" id="L445">		String text = getAltText();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">		return toString(text == null ? null : '&quot;' + text + '&quot;');</span>
	}

	// --------------------------------
	// Extrinsic state management
	/**
	 * Creates a new component model appropriate for this component.
	 *
	 * @return a new AudioModel
	 */
	@Override
	protected AudioModel newComponentModel() {
<span class="fc" id="L458">		return new AudioModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override // For type safety only
	protected AudioModel getComponentModel() {
<span class="fc" id="L466">		return (AudioModel) super.getComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override // For type safety only
	protected AudioModel getOrCreateComponentModel() {
<span class="fc" id="L474">		return (AudioModel) super.getOrCreateComponentModel();</span>
	}

	/**
	 * Holds the extrinsic state information of a WAudio.
	 */
<span class="fc" id="L480">	public static class AudioModel extends ComponentModel {</span>

		/**
		 * The various audio clips.
		 */
		private List&lt;Audio&gt; audio;

		/**
		 * The cache key used to control client-side caching.
		 */
		private String cacheKey;

		/**
		 * Indicates whether the audio should play immediately after page load.
		 */
		private boolean autoplay;

		/**
		 * Indicates whether playback of the audio clip should be looped.
		 */
		private boolean loop;

		/**
		 * Indicates which playback controls to display.
		 */
		private Controls controls;

		/**
		 * Indicates whether pre-loading of content should occur before the clip is played.
		 */
<span class="fc" id="L510">		private Preload preload = Preload.NONE;</span>

		/**
		 * Alternate text to display if the audio clip can not be played.
		 */
		private String altText;

		/**
		 * This is used to group related media together, for example to synchronize tracks.
		 */
		private String mediaGroup;
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>