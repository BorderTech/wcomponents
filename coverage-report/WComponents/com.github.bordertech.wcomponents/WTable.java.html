<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>WTable.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">WTable.java</span></div><h1>WTable.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.AdapterBasicTableModel.BasicTableModel;
import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.InternalMessages;
import com.github.bordertech.wcomponents.util.TableUtil;
import com.github.bordertech.wcomponents.util.Util;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * The WTable component is used to display tabular data. It supports common functions such as sorting and pagination of
 * data.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The WTable component is only concerned with how the UI functions, not the data behind the table. In a MVC sense, the
 * WTable is the Controller, the view is comprised of the WTable layout and column renderers, and the {@link TableModel}
 * is the model.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Columns may only be added statically to the table, but individual columns can be shown/hidden per user by toggling
 * their visibility. See {@link #getColumn(int)} and {@link WComponent#setVisible(boolean)}. Making columns not visible
 * can be problematic with sorting.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Another way to make columns not visible is by using {@link #setColumnOrder(int[])}. This can be used to change the
 * column order but also hide columns by not including their index in the array.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For data that is not in a tree like structure (ie not expandable), the {@link BasicTableModel} interface can be used
 * via the {@link AdapterBasicTableModel}.
 * &lt;/p&gt;
 *
 * @author Jonathan Austin
 * @since 1.0.0
 */
public class WTable extends WBeanComponent implements Container, AjaxTarget, SubordinateTarget,
		Marginable, NamingContextable {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L53">	private static final Log LOG = LogFactory.getLog(WTable.class);</span>

	/**
	 * Default rows per page.
	 */
	private static final int DEFAULT_ROWS = 10;

	/**
	 * For easy access to the columns, including the ability to hide them all at once.
	 */
<span class="fc" id="L63">	private final WContainer columns = new WContainer();</span>

	/**
	 * The repeater that is used to handle the repeated (row) content.
	 */
<span class="fc" id="L68">	private final TableRepeater repeater = new TableRepeater(this);</span>

	/**
	 * Table actions, which are normally visible at the bottom of the table.
	 */
<span class="fc" id="L73">	private final WContainer actions = new WContainer();</span>

	/**
	 * This is used to control how row selection should work.
	 */
<span class="pc" id="L78">	public enum SelectMode {</span>
		/**
		 * Indicates that row selection is not available.
		 */
<span class="fc" id="L82">		NONE,</span>
		/**
		 * Indicates that only a single row may be selected.
		 */
<span class="fc" id="L86">		SINGLE,</span>
		/**
		 * Indicates that multiple rows may be selected.
		 */
<span class="fc" id="L90">		MULTIPLE</span>
	};

	/**
	 * This is used to control how the &quot;select all&quot; function should work.
	 */
<span class="pc" id="L96">	public enum SelectAllType {</span>
		/**
		 * Indicates that the select all/none function should not be available.
		 */
<span class="fc" id="L100">		NONE,</span>
		/**
		 * Indicates that the select all/none function should is displayed as text.
		 */
<span class="fc" id="L104">		TEXT,</span>
		/**
		 * Indicates that the select all/none function should is displayed as a control (checkbox).
		 */
<span class="fc" id="L108">		CONTROL</span>
	};

	/**
	 * This is used to control how row expansion should work.
	 */
<span class="pc" id="L114">	public enum ExpandMode {</span>
		/**
		 * Indicates that row expansion is not supported.
		 */
<span class="fc" id="L118">		NONE,</span>
		/**
		 * Indicates that row expansion occurs on the client.
		 */
<span class="fc" id="L122">		CLIENT,</span>
		/**
		 * Indicates that row expansion occurs once, via AJAX.
		 */
<span class="fc" id="L126">		LAZY,</span>
		/**
		 * Indicates that row expansion should make an AJAX call every time.
		 */
<span class="fc" id="L130">		DYNAMIC</span>
	};

	/**
	 * This is used to control how pagination should work.
	 */
<span class="pc" id="L136">	public enum PaginationMode {</span>
		/**
		 * Indicates that pagination is not supported, all data will be displayed in the one page.
		 */
<span class="fc" id="L140">		NONE,</span>
		/**
		 * Indicates that pagination occurs on the client. All data will be sent at once.
		 */
<span class="fc" id="L144">		CLIENT,</span>
		/**
		 * Indicates that pagination occurs via AJAX calls to the server.
		 */
<span class="fc" id="L148">		DYNAMIC</span>
	};

	/**
	 * This is used to control where in the table the pagination controls appear.
	 */
<span class="pc" id="L154">	public enum PaginationLocation {</span>
		/**
		 * Indicates that pagination controls appear in a location determined solely by the theme.
		 */
<span class="fc" id="L158">		AUTO,</span>
		/**
		 * Indicates the pagination controls appear at the top of the table.
		 */
<span class="fc" id="L162">		TOP,</span>
		/**
		 * Indicates the pagination controls appear at the bottom of the table.
		 */
<span class="fc" id="L166">		BOTTOM,</span>
		/**
		 * Indicates that the pagination controls should be placed both at the top and at the bottom of the table.
		 */
<span class="fc" id="L170">		BOTH</span>
	};

	/**
	 * This is used to control the type of striping used, if any.
	 */
<span class="pc" id="L176">	public enum StripingType {</span>
		/**
		 * Indicates that no zebra striping should be used.
		 */
<span class="fc" id="L180">		NONE,</span>
		/**
		 * Indicates that zebra striping should be used to highlight rows.
		 */
<span class="fc" id="L184">		ROWS,</span>
		/**
		 * Indicates that zebra striping should be used to highlight columns.
		 */
<span class="fc" id="L188">		COLUMNS</span>
	};

	/**
	 * This is used to control the type of striping used, if any.
	 */
<span class="pc" id="L194">	public enum SeparatorType {</span>
		/**
		 * Indicates that no separators should be displayed.
		 */
<span class="fc" id="L198">		NONE,</span>
		/**
		 * Indicates that horizontal separators should be displayed.
		 */
<span class="fc" id="L202">		HORIZONTAL,</span>
		/**
		 * Indicates that vertical separators should be displayed.
		 */
<span class="fc" id="L206">		VERTICAL,</span>
		/**
		 * Indicates that both horizontal and vertical separators should be displayed.
		 */
<span class="fc" id="L210">		BOTH</span>
	};

	/**
	 * This is used to control how sorting should work.
	 */
<span class="pc" id="L216">	public enum SortMode {</span>
		/**
		 * Indicates that sorting should be disabled.
		 */
<span class="fc" id="L220">		NONE,</span>
		/**
		 * Indicates that sorting is via AJAX calls.
		 */
<span class="fc" id="L224">		DYNAMIC</span>
	};

	/**
	 * This is used to control how table data should be displayed.
	 */
<span class="pc" id="L230">	public enum Type {</span>
		/**
		 * Indicates that the table should be displayed as a normal table.
		 */
<span class="fc" id="L234">		TABLE,</span>
		/**
		 * Indicates that the table should be displayed as a hierarchical list.
		 */
<span class="fc" id="L238">		HIERARCHIC</span>
	};

	/**
	 * Prefix used in row ids.
	 */
	public static final String ROW_ID_CONTEXT_PREFIX = &quot;row&quot;;

	/**
	 * Selection action command.
	 */
	public static final String SELECTION_ACTION_COMMAND = &quot;selection&quot;;

	/**
	 * Creates a WTable.
	 */
<span class="fc" id="L254">	public WTable() {</span>
<span class="fc" id="L255">		add(columns);</span>
<span class="fc" id="L256">		add(repeater);</span>
<span class="fc" id="L257">		add(actions);</span>

<span class="fc" id="L259">		repeater.setRepeatedComponent(new WTableRowRenderer(this));</span>
<span class="fc" id="L260">		repeater.setBeanProvider(new RepeaterRowIdBeanProvider(this));</span>
<span class="fc" id="L261">	}</span>

	/**
	 * Adds a column to the table.
	 *
	 * @param column the column to add.
	 */
	public void addColumn(final WTableColumn column) {
<span class="fc" id="L269">		columns.add(column);</span>
<span class="fc" id="L270">		WTableRowRenderer renderer = (WTableRowRenderer) repeater.getRepeatedComponent();</span>
<span class="fc" id="L271">		renderer.addColumn(column, columns.getChildCount() - 1);</span>
<span class="fc" id="L272">	}</span>

	/**
	 * Retrieves the column at the specified index. Bounds checking is not performed, see {@link #getColumnCount()}.
	 *
	 * @param index the column index. Zero based.
	 * @return the column at the specified index.
	 */
	public WTableColumn getColumn(final int index) {
<span class="fc" id="L281">		return (WTableColumn) columns.getChildAt(index);</span>
	}

	/**
	 * Returns the number of columns contained in this table. Invisible columns still count towards the total.
	 *
	 * @return the number of columns contained in this table.
	 */
	public int getColumnCount() {
<span class="fc" id="L290">		return columns.getChildCount();</span>
	}

	/**
	 * @return the repeater used to render table rows.
	 */
	public TableRepeater getRepeater() {
<span class="fc" id="L297">		return repeater;</span>
	}

	/**
	 * @return the table model
	 */
	public TableModel getTableModel() {
<span class="fc" id="L304">		return getComponentModel().tableModel;</span>
	}

	/**
	 * Sets the table model which provides the row/column data.
	 *
	 * @param tableModel the table model.
	 */
	public void setTableModel(final TableModel tableModel) {
<span class="fc" id="L313">		getOrCreateComponentModel().tableModel = tableModel;</span>
<span class="fc" id="L314">		getOrCreateComponentModel().rowIndexMapping = null;</span>
<span class="fc" id="L315">		setSelectedRows(null);</span>
<span class="fc" id="L316">		setExpandedRows(null);</span>
<span class="fc" id="L317">		clearPrevExpandedRows();</span>
<span class="fc" id="L318">		clearPrevRenderedRows();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (tableModel instanceof BeanBoundTableModel) {</span>
<span class="fc" id="L321">			((BeanBoundTableModel) tableModel).</span>
<span class="fc" id="L322">					setBeanProvider(new BeanBoundTableModelBeanProvider(this));</span>
<span class="fc" id="L323">			((BeanBoundTableModel) tableModel).setBeanProperty(&quot;.&quot;);</span>
		}

<span class="pc bpc" id="L326" title="1 of 2 branches missed.">		if (tableModel instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L328">				throw new IllegalStateException(</span>
						&quot;Set a ScrollableTableModel on a table that is not paginated.&quot;);
			}

<span class="nc" id="L332">			int startIndex = getCurrentPage() * getRowsPerPage();</span>
<span class="nc" id="L333">			int endIndex = startIndex + getRowsPerPage() - 1;</span>
<span class="nc" id="L334">			((ScrollableTableModel) tableModel).setCurrentRows(startIndex, endIndex);</span>
		}

		// Flush the repeater's row contexts and scratch maps
<span class="fc" id="L338">		repeater.reset();</span>
<span class="fc" id="L339">	}</span>

	/**
	 * Updates the bean using the table data model's {@link TableModel#setValueAt(Object, List, int)} method.
	 * &lt;p&gt;
	 * The update is only applied if the table has been set as editable via {@link #setEditable(boolean)}. Only rows
	 * that have been rendered are updated.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * For {@link ScrollableTableModel}, only the rows on the current page are updated.
	 * &lt;/p&gt;
	 */
	@Override
	public void updateBeanValue() {
<span class="nc" id="L353">		TableModel model = getTableModel();</span>

		// Only apply updates if table was editable
<span class="nc bnc" id="L356" title="All 2 branches missed.">		if (!isEditable()) {</span>
<span class="nc" id="L357">			LOG.warn(&quot;UpdateBeanValue called for table that is not editable&quot;);</span>
<span class="nc" id="L358">			return;</span>
		}

<span class="nc" id="L361">		int rows = model.getRowCount();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">		if (rows == 0) {</span>
<span class="nc" id="L363">			return;</span>
		}

<span class="nc" id="L366">		int startIndex = 0;</span>
<span class="nc" id="L367">		int endIndex = rows - 1;</span>

		// For scrollable table model, only update the rows on the current page
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (model instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L372">				throw new IllegalStateException(</span>
						&quot;UpdateBeanValue tried to update a ScrollableTableModel with no pagination.&quot;);
			}

<span class="nc" id="L376">			int rowsPerPage = getRowsPerPage();</span>
<span class="nc" id="L377">			int currentPage = getCurrentPage();</span>
			// Only update the rows on the current page
<span class="nc" id="L379">			startIndex = currentPage * rowsPerPage;</span>
<span class="nc" id="L380">			endIndex = Math.min(startIndex + rowsPerPage, rows) - 1;</span>
<span class="nc" id="L381">			LOG.warn(&quot;UpdateBeanValue only updating the current page for ScrollableTableModel&quot;);</span>
		}

<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (endIndex &lt; startIndex) {</span>
<span class="nc" id="L385">			return;</span>
		}

		// Temporarily widen the pagination on the repeater to hold all rows
		// Calling setBean with a non-null value overrides the DataTableBeanProvider
<span class="nc" id="L390">		repeater.setBean(getRowIds(startIndex, endIndex, true));</span>
<span class="nc" id="L391">		updateBeanValueForRenderedRows();</span>
<span class="nc" id="L392">		repeater.setBean(null);</span>
<span class="nc" id="L393">	}</span>

	/**
	 * Updates the bean using the table data model's {@link TableModel#setValueAt(Object, List, int)} method. This
	 * method only updates the data for the currently set row ids.
	 */
	private void updateBeanValueForRenderedRows() {
<span class="nc" id="L400">		WTableRowRenderer rowRenderer = (WTableRowRenderer) repeater.getRepeatedComponent();</span>
<span class="nc" id="L401">		TableModel model = getTableModel();</span>

<span class="nc" id="L403">		int index = 0;</span>

<span class="nc" id="L405">		List&lt;RowIdWrapper&gt; wrappers = repeater.getBeanList();</span>

<span class="nc" id="L407">		int columnCount = getColumnCount();</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">		for (RowIdWrapper wrapper : wrappers) {</span>
<span class="nc" id="L410">			UIContext rowContext = repeater.getRowContext(wrapper, index++);</span>
<span class="nc" id="L411">			List&lt;Integer&gt; rowIndex = wrapper.getRowIndex();</span>

<span class="nc" id="L413">			Class&lt;? extends WComponent&gt; expandRenderer = model.getRendererClass(rowIndex);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">			if (expandRenderer == null) {</span>
				// Process Columns
<span class="nc bnc" id="L416" title="All 2 branches missed.">				for (int col = 0; col &lt; columnCount; col++) {</span>
					// Check if this cell is editable
<span class="nc bnc" id="L418" title="All 2 branches missed.">					if (model.isCellEditable(rowIndex, col)) {</span>
<span class="nc" id="L419">						updateBeanValueForColumnInRow(rowRenderer, rowContext, rowIndex, col, model);</span>
					}
				}
<span class="nc bnc" id="L422" title="All 2 branches missed.">			} else if (model.isCellEditable(rowIndex, -1)) {</span>
				// Check if this expanded row is editable
<span class="nc" id="L424">				updateBeanValueForRowRenderer(rowRenderer, rowContext, expandRenderer);</span>
			}

<span class="nc" id="L427">		}</span>
<span class="nc" id="L428">	}</span>

	/**
	 * Update the column in the row.
	 *
	 * @param rowRenderer the table row renderer
	 * @param rowContext the row context
	 * @param rowIndex the row id to update
	 * @param col the column to update
	 * @param model the table model
	 */
	private void updateBeanValueForColumnInRow(final WTableRowRenderer rowRenderer,
			final UIContext rowContext,
			final List&lt;Integer&gt; rowIndex, final int col, final TableModel model) {
		// The actual component is wrapped in a renderer wrapper, so we have to fetch it from that
<span class="nc" id="L443">		WComponent renderer = ((Container) rowRenderer.getRenderer(col)).getChildAt(0);</span>

<span class="nc" id="L445">		UIContextHolder.pushContext(rowContext);</span>

		try {
			// If the column is a Container then call updateBeanValue to let the column renderer and its children update
			// the &quot;bean&quot; returned by getValueAt(row, col)
<span class="nc bnc" id="L450" title="All 2 branches missed.">			if (renderer instanceof Container) {</span>
<span class="nc" id="L451">				WebUtilities.updateBeanValue(renderer);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">			} else if (renderer instanceof DataBound) { // Update Databound renderer</span>
<span class="nc" id="L453">				Object oldValue = model.getValueAt(rowIndex, col);</span>
<span class="nc" id="L454">				Object newValue = ((DataBound) renderer).getData();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">				if (!Util.equals(oldValue, newValue)) {</span>
<span class="nc" id="L456">					model.setValueAt(newValue, rowIndex, col);</span>
				}
			}

		} finally {
<span class="nc" id="L461">			UIContextHolder.popContext();</span>
<span class="nc" id="L462">		}</span>

<span class="nc" id="L464">	}</span>

	/**
	 * Update the expandable row renderer.
	 *
	 * @param rowRenderer the table row renderer
	 * @param rowContext the row context
	 * @param expandRenderer the renderer for the expandable row.
	 */
	private void updateBeanValueForRowRenderer(final WTableRowRenderer rowRenderer,
			final UIContext rowContext,
			final Class&lt;? extends WComponent&gt; expandRenderer) {

<span class="nc" id="L477">		Container expandWrapper = (Container) rowRenderer.</span>
<span class="nc" id="L478">				getExpandedTreeNodeRenderer(expandRenderer);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		if (expandWrapper == null) {</span>
<span class="nc" id="L480">			return;</span>
		}

		// The actual component is wrapped in a renderer wrapper, so we have to fetch it from that
<span class="nc" id="L484">		WComponent expandInstance = expandWrapper.getChildAt(0);</span>

<span class="nc" id="L486">		UIContextHolder.pushContext(rowContext);</span>
		try {
			// Will apply updates to the &quot;bean&quot; returned by the model for this expanded renderer (ie
			// getValueAt(rowIndex, -1))
<span class="nc" id="L490">			WebUtilities.updateBeanValue(expandInstance);</span>
		} finally {
<span class="nc" id="L492">			UIContextHolder.popContext();</span>
<span class="nc" id="L493">		}</span>

<span class="nc" id="L495">	}</span>

	/**
	 * @return the separator type used to visually separate rows or columns.
	 */
	public SeparatorType getSeparatorType() {
<span class="fc" id="L501">		return getComponentModel().separatorType;</span>
	}

	/**
	 * Sets the separator used to visually separate rows or columns.
	 *
	 * @param separatorType the separator type to set.
	 */
	public void setSeparatorType(final SeparatorType separatorType) {
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">		getOrCreateComponentModel().separatorType = separatorType == null ? SeparatorType.NONE : separatorType;</span>
<span class="fc" id="L511">	}</span>

	/**
	 * Sets whether the de/selection of a row with sub rows should de/select the sub rows. This is a client-side only
	 * feature.
	 *
	 * @param toggleSubRowSelection true to turn on this feature.
	 */
	public void setToggleSubRowSelection(final boolean toggleSubRowSelection) {
<span class="fc" id="L520">		getOrCreateComponentModel().toggleSubRowSelection = toggleSubRowSelection;</span>
<span class="fc" id="L521">	}</span>

	/**
	 * Indicates whether de/selecting a row with sub row(s) will de/select the sub row(s).
	 *
	 * @return true if this feature is enabled.
	 */
	public boolean isToggleSubRowSelection() {
<span class="fc" id="L529">		return getComponentModel().toggleSubRowSelection;</span>
	}

	/**
	 * @return the striping type used to highlight alternate rows or columns
	 */
	public StripingType getStripingType() {
<span class="fc" id="L536">		return getComponentModel().stripingType;</span>
	}

	/**
	 * Sets the striping type used to highlight alternate rows or columns.
	 *
	 * @param stripingType the striping type to set.
	 */
	public void setStripingType(final StripingType stripingType) {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">		getOrCreateComponentModel().stripingType = stripingType == null ? StripingType.NONE : stripingType;</span>
<span class="fc" id="L546">	}</span>

	/**
	 * Indicates whether table column headers should be displayed.
	 *
	 * @return true if column headers should be displayed, false otherwise.
	 */
	public boolean isShowColumnHeaders() {
<span class="fc" id="L554">		return getComponentModel().showColumnHeaders;</span>
	}

	/**
	 * Sets whether table column headers should be displayed.
	 *
	 * @param showColumnHeaders true to display table column headers, false otherwise.
	 */
	public void setShowColumnHeaders(final boolean showColumnHeaders) {
<span class="fc" id="L563">		getOrCreateComponentModel().showColumnHeaders = showColumnHeaders;</span>
<span class="fc" id="L564">	}</span>

	/**
	 * @return the action to execute when row selection changes.
	 */
	public Action getSelectionChangeAction() {
<span class="fc" id="L570">		return getComponentModel().selectionChangeAction;</span>
	}

	/**
	 * Sets the action to execute when row selection changes.
	 *
	 * @param selectionChangeAction the action to execute on row selection change.
	 */
	public void setSelectionChangeAction(final Action selectionChangeAction) {
<span class="fc" id="L579">		getOrCreateComponentModel().selectionChangeAction = selectionChangeAction;</span>
<span class="fc" id="L580">	}</span>

	/**
	 * @return the message to display when the table contains no rows.
	 */
	public String getNoDataMessage() {
<span class="fc" id="L586">		return I18nUtilities.format(null, getComponentModel().noDataMessage);</span>
	}

	/**
	 * Sets the message to display when the table contains no rows.
	 *
	 * @param noDataMessage the no data message.
	 */
	public void setNoDataMessage(final String noDataMessage) {
<span class="fc" id="L595">		getOrCreateComponentModel().noDataMessage = noDataMessage;</span>
<span class="fc" id="L596">	}</span>

	/**
	 * @return the table summary text.
	 */
	public String getSummary() {
<span class="fc" id="L602">		return I18nUtilities.format(null, getComponentModel().summary);</span>
	}

	/**
	 * Sets the table summary text.
	 *
	 * @param summary the table summary text to set.
	 */
	public void setSummary(final String summary) {
<span class="fc" id="L611">		getOrCreateComponentModel().summary = summary;</span>
<span class="fc" id="L612">	}</span>

	/**
	 * @return the table caption text.
	 */
	public String getCaption() {
<span class="fc" id="L618">		return I18nUtilities.format(null, getComponentModel().caption);</span>
	}

	/**
	 * Sets the table caption text.
	 *
	 * @param caption the table caption text to set.
	 */
	public void setCaption(final String caption) {
<span class="fc" id="L627">		getOrCreateComponentModel().caption = caption;</span>
<span class="fc" id="L628">	}</span>

	/**
	 * @return the column order, or null if the default ordering is to be used.
	 */
	public int[] getColumnOrder() {
<span class="fc" id="L634">		return getComponentModel().columnOrder;</span>
	}

	/**
	 * Provide an array of column indexes in the order they should be rendered. At least one column must be specifed.
	 * &lt;p&gt;
	 * This can also be used to &quot;hide&quot; columns by not including them in the array.
	 * &lt;/p&gt;
	 *
	 * @param columnOrder the column order to set, or null to use default ordering.
	 */
	public void setColumnOrder(final int[] columnOrder) {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">		if (columnOrder == null) {</span>
<span class="nc" id="L647">			getOrCreateComponentModel().columnOrder = null;</span>
		} else {
<span class="fc" id="L649">			int count = getColumnCount();</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">			if (columnOrder.length == 0) {</span>
<span class="fc" id="L651">				throw new IllegalArgumentException(&quot;Cannot have an empty column order indices.&quot;);</span>
			}
<span class="fc bfc" id="L653" title="All 2 branches covered.">			if (columnOrder.length &gt; count) {</span>
<span class="fc" id="L654">				throw new IllegalArgumentException(</span>
						&quot;Number of column order indices cannot be greater than the number of table columns&quot;);
			}
<span class="fc bfc" id="L657" title="All 2 branches covered.">			for (int idx : columnOrder) {</span>
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">				if (idx &lt; 0 || idx &gt; count - 1) {</span>
<span class="fc" id="L659">					throw new IllegalArgumentException(</span>
							&quot;Illegal index in column order indices [&quot; + idx + &quot;]&quot;);
				}
			}
<span class="fc" id="L663">			getOrCreateComponentModel().columnOrder = Arrays.copyOf(columnOrder, columnOrder.length);</span>
		}
<span class="fc" id="L665">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setMargin(final Margin margin) {
<span class="fc" id="L672">		getOrCreateComponentModel().margin = margin;</span>
<span class="fc" id="L673">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Margin getMargin() {
<span class="fc" id="L680">		return getComponentModel().margin;</span>
	}

	/**
	 * @return the pagination mode.
	 */
	public PaginationMode getPaginationMode() {
<span class="fc" id="L687">		return getComponentModel().paginationMode;</span>
	}

	/**
	 * Sets the pagination mode.
	 *
	 * @param paginationMode the paginationMode to set.
	 */
	public void setPaginationMode(final PaginationMode paginationMode) {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">		getOrCreateComponentModel().paginationMode = paginationMode == null ? PaginationMode.NONE : paginationMode;</span>
<span class="fc" id="L697">	}</span>

	/**
	 * The number of rows to display per page. A value of zero, which is only valid when used with
	 * {@link #setRowsPerPageOptions(java.util.List)}, indicates display all rows.
	 *
	 * @return the number of rows to display per page.
	 */
	public int getRowsPerPage() {
<span class="fc" id="L706">		return getComponentModel().rowsPerPage;</span>
	}

	/**
	 * Sets the number of rows to display per page when pagination is enabled.
	 * &lt;p&gt;
	 * If rows per page options have been set, then the value must be a valid option, which can include zero to indicate
	 * show all rows, otherwise the value must be greater than zero.
	 * &lt;/p&gt;
	 *
	 * @param rowsPerPage the rowsPerPage to set
	 */
	public void setRowsPerPage(final int rowsPerPage) {
<span class="fc" id="L719">		List&lt;Integer&gt; rowsOptions = getRowsPerPageOptions();</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">		if (rowsOptions == null) {</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">			if (rowsPerPage &lt; 1) {</span>
<span class="fc" id="L722">				throw new IllegalArgumentException(</span>
						&quot;Rows per page must be greater than 0, but got: &quot; + rowsPerPage);
			}
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">		} else if (!rowsOptions.contains(rowsPerPage)) {</span>
<span class="nc" id="L726">			throw new IllegalArgumentException(</span>
					&quot;Rows per page is not a valid rows per page option, got: &quot; + rowsPerPage);
		}
<span class="fc" id="L729">		getOrCreateComponentModel().rowsPerPage = rowsPerPage;</span>
<span class="fc" id="L730">	}</span>

	/**
	 * @return the rows per page options, otherwise null
	 */
	public List&lt;Integer&gt; getRowsPerPageOptions() {
<span class="fc" id="L736">		return getComponentModel().rowsPerPageOptions;</span>
	}

	/**
	 * Set the rows per page options.
	 * &lt;p&gt;
	 * If the current value of {@link #getRowsPerPage()} is not a valid option, it will be set to the first option.
	 * &lt;/p&gt;
	 *
	 * @param rowsPerPageOptions the rows per page options
	 */
	public void setRowsPerPageOptions(final List&lt;Integer&gt; rowsPerPageOptions) {
<span class="fc" id="L748">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc bfc" id="L749" title="All 4 branches covered.">		if (rowsPerPageOptions == null || rowsPerPageOptions.isEmpty()) {</span>
<span class="fc" id="L750">			model.rowsPerPageOptions = null;</span>
			// If the rows per page is currently 0, reset it to the default value
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">			if (model.rowsPerPage == 0) {</span>
<span class="fc" id="L753">				model.rowsPerPage = DEFAULT_ROWS;</span>
			}
		} else {
			// Validate options
<span class="fc bfc" id="L757" title="All 2 branches covered.">			for (Integer rows : rowsPerPageOptions) {</span>
<span class="fc bfc" id="L758" title="All 4 branches covered.">				if (rows == null || rows &lt; 0) {</span>
<span class="fc" id="L759">					throw new IllegalArgumentException(</span>
							&quot;Rows per page option cannot be less than 0 or null, got: &quot; + rows);
				}
<span class="fc" id="L762">			}</span>
<span class="fc" id="L763">			model.rowsPerPageOptions = new ArrayList&lt;&gt;(rowsPerPageOptions);</span>
			// If the current rows per page is not a valid option, default to the first option
<span class="fc bfc" id="L765" title="All 2 branches covered.">			if (!rowsPerPageOptions.contains(model.rowsPerPage)) {</span>
<span class="fc" id="L766">				model.rowsPerPage = rowsPerPageOptions.get(0);</span>
			}
		}
<span class="fc" id="L769">	}</span>

	/**
	 * @return true if table is currently displaying paginated rows
	 */
	public boolean isPaginated() {
<span class="pc bpc" id="L775" title="2 of 4 branches missed.">		return getPaginationMode() != PaginationMode.NONE &amp;&amp; getRowsPerPage() &gt; 0;</span>
	}

	/**
	 * @return the location for the pagination controls
	 */
	public PaginationLocation getPaginationLocation() {
<span class="fc" id="L782">		return getComponentModel().paginationLocation;</span>
	}

	/**
	 * Sets the location in the table to show the pagination controls.
	 *
	 * @param location the PaginationLocation to set.
	 */
	public void setPaginationLocation(final PaginationLocation location) {
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">		getOrCreateComponentModel().paginationLocation = location == null ? PaginationLocation.AUTO : location;</span>
<span class="fc" id="L792">	}</span>

	/**
	 * @return the row selection mode.
	 */
	public SelectMode getSelectMode() {
<span class="fc" id="L798">		return getComponentModel().selectMode;</span>
	}

	/**
	 * Sets the row selection mode.
	 *
	 * @param selectMode the row selection mode to set.
	 */
	public void setSelectMode(final SelectMode selectMode) {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">		getOrCreateComponentModel().selectMode = selectMode == null ? SelectMode.NONE : selectMode;</span>
<span class="fc" id="L808">	}</span>

	/**
	 * @return the sort mode.
	 */
	public SortMode getSortMode() {
<span class="fc" id="L814">		return getComponentModel().sortMode;</span>
	}

	/**
	 * Sets the table sort mode. The data model controls which columns are sortable.
	 *
	 * @param sortMode The sort mode to set.
	 */
	public void setSortMode(final SortMode sortMode) {
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">		getOrCreateComponentModel().sortMode = sortMode == null ? SortMode.NONE : sortMode;</span>
<span class="fc" id="L824">	}</span>

	/**
	 * &lt;p&gt;
	 * For tables that are editable, extra details about each row must be stored to allow them to be updated. Therefore,
	 * if the table is not editable, the table is able to have improved performance.
	 * &lt;/p&gt;
	 *
	 * @return true if table is editable
	 */
	public boolean isEditable() {
<span class="fc" id="L835">		return getComponentModel().editable;</span>
	}

	/**
	 * Sets the table to be editable.
	 * &lt;p&gt;
	 * For tables that are editable, extra details about each row must be stored to allow them to be updated. Therefore,
	 * if the table is not editable, the table is able to have improved performance.
	 * &lt;/p&gt;
	 *
	 * @param editable true if editable
	 */
	public void setEditable(final boolean editable) {
<span class="nc" id="L848">		getOrCreateComponentModel().editable = editable;</span>
<span class="nc" id="L849">	}</span>

	/**
	 * @return the table type that controls how the table is displayed.
	 */
	public Type getType() {
<span class="fc" id="L855">		return getComponentModel().type;</span>
	}

	/**
	 * Sets the table type that controls how the table is displayed.
	 *
	 * @param type the table type to set.
	 */
	public void setType(final Type type) {
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">		getOrCreateComponentModel().type = type == null ? Type.TABLE : type;</span>
<span class="fc" id="L865">	}</span>

	/**
	 * Indicates how the table row &quot;select all&quot; function should be displayed.
	 *
	 * @return the select all mode.
	 */
	public SelectAllType getSelectAllMode() {
<span class="fc" id="L873">		return getComponentModel().selectAllMode;</span>
	}

	/**
	 * Sets how the table row &quot;select all&quot; function should be displayed.
	 *
	 * @param selectAllMode the select all mode to set.
	 */
	public void setSelectAllMode(final SelectAllType selectAllMode) {
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">		getOrCreateComponentModel().selectAllMode = selectAllMode == null ? SelectAllType.TEXT : selectAllMode;</span>
<span class="fc" id="L883">	}</span>

	/**
	 * @return the row expansion mode.
	 */
	public ExpandMode getExpandMode() {
<span class="fc" id="L889">		return getComponentModel().expandMode;</span>
	}

	/**
	 * Sets the row expansion mode.
	 *
	 * @param expandMode the expand mode to set.
	 */
	public void setExpandMode(final ExpandMode expandMode) {
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">		getOrCreateComponentModel().expandMode = expandMode == null ? ExpandMode.NONE : expandMode;</span>
<span class="fc" id="L899">	}</span>

	/**
	 * Indicates whether the &quot;expand all&quot; control should be available.
	 *
	 * @return true if the expand all control should be available, false if not.
	 */
	public boolean isExpandAll() {
<span class="fc" id="L907">		return getComponentModel().expandAll;</span>
	}

	/**
	 * Sets whether the &quot;expand all&quot; control should be available.
	 *
	 * @param expandAll true if the expand-all control should be available, false if not.
	 */
	public void setExpandAll(final boolean expandAll) {
<span class="fc" id="L916">		getOrCreateComponentModel().expandAll = expandAll;</span>
<span class="fc" id="L917">	}</span>

	/**
	 * @return the current page. Zero based.
	 */
	public int getCurrentPage() {
		// Table data may have changed.
<span class="fc" id="L924">		int currentPage = getComponentModel().currentPage;</span>
<span class="fc" id="L925">		int maxPage = getComponentModel().getMaxPage();</span>

<span class="pc bpc" id="L927" title="1 of 2 branches missed.">		if (currentPage &gt; maxPage) {</span>
<span class="nc" id="L928">			currentPage = maxPage;</span>
<span class="nc" id="L929">			setCurrentPage(maxPage);</span>
		}

<span class="fc" id="L932">		return currentPage;</span>
	}

	/**
	 * @param currentPage the currentPage to set. Zero based.
	 */
	public void setCurrentPage(final int currentPage) {
<span class="fc bfc" id="L939" title="All 2 branches covered.">		if (currentPage &lt; 0) {</span>
<span class="fc" id="L940">			throw new IllegalArgumentException(&quot;Page number must be greater than or equal to zero.&quot;);</span>
		}

<span class="fc" id="L943">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L944">		model.currentPage = Math.min(model.getMaxPage(), currentPage);</span>

		// Notify the table model that the page has changed
<span class="fc" id="L947">		TableModel dataModel = getTableModel();</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">		if (dataModel instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L950">				throw new IllegalStateException(</span>
						&quot;Table with no pagination tried to set the current page on a ScrollableTableModel.&quot;);
			}
<span class="nc" id="L953">			int startIndex = getCurrentPage() * getRowsPerPage();</span>
<span class="nc" id="L954">			int endIndex = Math.min(startIndex + getRowsPerPage(), dataModel.getRowCount()) - 1;</span>
<span class="nc" id="L955">			((ScrollableTableModel) dataModel).setCurrentRows(startIndex, endIndex);</span>
		}
<span class="fc" id="L957">	}</span>

	/**
	 * Set the row keys that are expanded.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @param rowKeys the keys of expanded rows.
	 */
	public void setExpandedRows(final Set&lt;?&gt; rowKeys) {
<span class="fc" id="L969">		getOrCreateComponentModel().expandedRows = rowKeys;</span>
<span class="fc" id="L970">	}</span>

	/**
	 * Retrieve the row keys that are expanded.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @return the expanded row keys.
	 */
	public Set&lt;?&gt; getExpandedRows() {
<span class="fc" id="L982">		Set&lt;?&gt; keys = getComponentModel().expandedRows;</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">		if (keys == null) {</span>
<span class="fc" id="L984">			return Collections.emptySet();</span>
		} else {
<span class="fc" id="L986">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Set the row keys that are selected.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @param rowKeys the keys of selected rows.
	 */
	public void setSelectedRows(final Set&lt;?&gt; rowKeys) {
<span class="fc" id="L1000">		getOrCreateComponentModel().selectedRows = rowKeys;</span>
<span class="fc" id="L1001">	}</span>

	/**
	 * Retrieve the row keys that are selected.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @return the selected row keys.
	 */
	public Set&lt;?&gt; getSelectedRows() {
<span class="fc" id="L1013">		Set&lt;?&gt; keys = getComponentModel().selectedRows;</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">		if (keys == null) {</span>
<span class="fc" id="L1015">			return Collections.emptySet();</span>
		} else {
<span class="fc" id="L1017">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Return the row keys that have been expanded.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @return the previously expanded row keys.
	 */
	protected Set&lt;?&gt; getPrevExpandedRows() {
<span class="nc" id="L1030">		Set&lt;?&gt; keys = getComponentModel().prevExpandedRows;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">		if (keys == null) {</span>
<span class="nc" id="L1032">			return Collections.emptySet();</span>
		} else {
<span class="nc" id="L1034">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Track the row keys that have been expanded.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @param rowKey the row key that has been expanded.
	 */
	protected void addPrevExpandedRow(final Object rowKey) {
<span class="nc" id="L1047">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">		if (model.prevExpandedRows == null) {</span>
<span class="nc" id="L1049">			model.prevExpandedRows = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L1051">		model.prevExpandedRows.add(rowKey);</span>
<span class="nc" id="L1052">	}</span>

	/**
	 * Clear the previously expanded row keys.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 */
	protected void clearPrevExpandedRows() {
<span class="fc" id="L1061">		getOrCreateComponentModel().prevExpandedRows = null;</span>
<span class="fc" id="L1062">	}</span>

	/**
	 * Return the row keys that have been rendered.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @return the previously rendered row keys.
	 */
	protected Set&lt;?&gt; getPrevRenderedRows() {
<span class="nc" id="L1073">		Set&lt;?&gt; keys = getComponentModel().prevRenderedRows;</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">		if (keys == null) {</span>
<span class="nc" id="L1075">			return Collections.emptySet();</span>
		} else {
<span class="nc" id="L1077">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Track the row keys that have been rendered.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @param rowKey the row key that has been rendered.
	 */
	protected void addPrevRenderedRow(final Object rowKey) {
<span class="nc" id="L1090">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">		if (model.prevRenderedRows == null) {</span>
<span class="nc" id="L1092">			model.prevRenderedRows = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L1094">		model.prevRenderedRows.add(rowKey);</span>
<span class="nc" id="L1095">	}</span>

	/**
	 * Clear the previously rendered row keys.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 */
	protected void clearPrevRenderedRows() {
<span class="fc" id="L1104">		getOrCreateComponentModel().prevRenderedRows = null;</span>
<span class="fc" id="L1105">	}</span>

	/**
	 * For rendering purposes only - has no effect on model.
	 *
	 * @param index the sort column index, or -1 for no sort.
	 * @param ascending true for ascending order, false for descending
	 */
	protected void setSort(final int index, final boolean ascending) {
<span class="fc" id="L1114">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1115">		model.sortColIndex = index;</span>
<span class="fc" id="L1116">		model.sortAscending = ascending;</span>
<span class="fc" id="L1117">	}</span>

	/**
	 * @return true if the table is currently sorted
	 */
	public boolean isSorted() {
<span class="fc bfc" id="L1123" title="All 2 branches covered.">		return getComponentModel().sortColIndex &gt;= 0;</span>
	}

	/**
	 * @return the index of the column the table is sorted by.
	 */
	public int getSortColumnIndex() {
<span class="fc" id="L1130">		return getComponentModel().sortColIndex;</span>
	}

	/**
	 * Indicates whether the sort on this table is ascending. Note that a return value of false does not necessarily
	 * indicate a descending sort - see {@link #isSorted()}.
	 *
	 * @return true if the sort order is ascending, false for descending.
	 */
	public boolean isSortAscending() {
<span class="fc" id="L1140">		return getComponentModel().sortAscending;</span>
	}

	/**
	 * Indicates whether the table supports sorting.
	 *
	 * @return true if the table and model both support sorting, false otherwise.
	 */
	public boolean isSortable() {
		// First check global override which turns sorting off
<span class="fc bfc" id="L1150" title="All 2 branches covered.">		if (getSortMode() == SortMode.NONE) {</span>
<span class="fc" id="L1151">			return false;</span>
		}

		// Otherwise, the table is sortable if at least one column is sortable.
<span class="fc" id="L1155">		TableModel dataModel = getTableModel();</span>
<span class="fc" id="L1156">		final int columnCount = getColumnCount();</span>

<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">		for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">			if (dataModel.isSortable(i)) {</span>
<span class="fc" id="L1160">				return true;</span>
			}
		}

<span class="nc" id="L1164">		return false;</span>
	}

	/**
	 * Retrieves the actions for the table.
	 *
	 * @return the list of table actions
	 */
	public List&lt;WButton&gt; getActions() {
<span class="fc" id="L1173">		final int numActions = actions.getChildCount();</span>
<span class="fc" id="L1174">		List&lt;WButton&gt; buttons = new ArrayList&lt;&gt;(numActions);</span>

<span class="fc bfc" id="L1176" title="All 2 branches covered.">		for (int i = 0; i &lt; numActions; i++) {</span>
<span class="fc" id="L1177">			WButton button = (WButton) actions.getChildAt(i);</span>
<span class="fc" id="L1178">			buttons.add(button);</span>
		}

<span class="fc" id="L1181">		return Collections.unmodifiableList(buttons);</span>
	}

	/**
	 * Adds a component to the set of table actions.
	 *
	 * @param button the button to add.
	 */
	public void addAction(final WButton button) {
<span class="fc" id="L1190">		actions.add(button);</span>
<span class="fc" id="L1191">	}</span>

	/**
	 * Adds a constraint to when the given action can be used.
	 *
	 * @param button the button which the constraint applies to.
	 * @param constraint the constraint to add.
	 */
	public void addActionConstraint(final WButton button, final ActionConstraint constraint) {
<span class="fc bfc" id="L1200" title="All 2 branches covered.">		if (button.getParent() != actions) {</span>
<span class="fc" id="L1201">			throw new IllegalArgumentException(</span>
					&quot;Can only add a constraint to a button which is in this table's actions&quot;);
		}

<span class="fc" id="L1205">		getOrCreateComponentModel().addActionConstraint(button, constraint);</span>
<span class="fc" id="L1206">	}</span>

	/**
	 * Retrieves the constraints for the given action.
	 *
	 * @param button the button to retrieve the constraints for.
	 * @return the constraints for the given action, or null if there are no constraints.
	 */
	public List&lt;ActionConstraint&gt; getActionConstraints(final WButton button) {
<span class="fc" id="L1215">		List&lt;ActionConstraint&gt; constraints = getComponentModel().actionConstraints.get(button);</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">		return constraints == null ? null : Collections.unmodifiableList(constraints);</span>
	}

	/**
	 * Override handleRequest to add table-specific functionality such as pagination and row selection.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	public void handleRequest(final Request request) {
<span class="fc" id="L1226">		super.handleRequest(request);</span>

<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">		if (isPresent(request)) {</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">			if (getExpandMode() != ExpandMode.NONE) {</span>
<span class="fc" id="L1230">				handleExpansionRequest(request);</span>
			}

<span class="fc bfc" id="L1233" title="All 2 branches covered.">			if (getSelectMode() != SelectMode.NONE) {</span>
<span class="fc" id="L1234">				handleSelectionRequest(request);</span>
			}

<span class="fc bfc" id="L1237" title="All 2 branches covered.">			if (getPaginationMode() != PaginationMode.NONE) {</span>
<span class="fc" id="L1238">				handlePaginationRequest(request);</span>
			}

<span class="fc bfc" id="L1241" title="All 2 branches covered.">			if (isSortable()) {</span>
<span class="fc" id="L1242">				handleSortRequest(request);</span>
			}
		}
<span class="fc" id="L1245">	}</span>

	/**
	 * Indicates whether this table was present in the request.
	 *
	 * @param request the request being responded to.
	 * @return true if this table was present in the request, false if not.
	 */
	protected boolean isPresent(final Request request) {
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">		return request.getParameter(getId() + &quot;-h&quot;) != null;</span>
	}

	/**
	 * Handles a request containing sort instruction data.
	 *
	 * @param request the request containing sort instruction data.
	 */
	private void handleSortRequest(final Request request) {
<span class="fc" id="L1263">		String sortColStr = request.getParameter(getId() + &quot;.sort&quot;);</span>
<span class="fc" id="L1264">		String sortDescStr = request.getParameter(getId() + &quot;.sortDesc&quot;);</span>

<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">		if (sortColStr != null) {</span>
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">			if (&quot;&quot;.equals(sortColStr)) {</span>
				// Reset sort
<span class="nc" id="L1269">				setSort(-1, false);</span>
<span class="nc" id="L1270">				getOrCreateComponentModel().rowIndexMapping = null;</span>
			} else {
				try {
<span class="fc" id="L1273">					int sortCol = Integer.parseInt(sortColStr);</span>
					// Allow for column order
<span class="fc" id="L1275">					int[] cols = getColumnOrder();</span>
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">					if (cols != null) {</span>
<span class="nc" id="L1277">						sortCol = cols[sortCol];</span>
					}
<span class="fc bfc" id="L1279" title="All 2 branches covered.">					boolean sortAsc = !&quot;true&quot;.equalsIgnoreCase(sortDescStr);</span>

					// Only process the sort request if it differs from the current sort order
<span class="pc bpc" id="L1282" title="3 of 4 branches missed.">					if (sortCol != getSortColumnIndex() || sortAsc != isSortAscending()) {</span>
<span class="fc" id="L1283">						sort(sortCol, sortAsc);</span>
<span class="fc" id="L1284">						setFocussed();</span>
					}
<span class="nc" id="L1286">				} catch (NumberFormatException e) {</span>
<span class="nc" id="L1287">					LOG.warn(&quot;Invalid sort column: &quot; + sortColStr);</span>
<span class="fc" id="L1288">				}</span>
			}
		}
<span class="fc" id="L1291">	}</span>

	/**
	 * Sort the table data by the specified column.
	 *
	 * @param sortCol the column to sort
	 * @param sortAsc true if sort ascending, otherwise sort descending
	 */
	public void sort(final int sortCol, final boolean sortAsc) {
<span class="fc" id="L1300">		int[] rowIndexMappings = getTableModel().sort(sortCol, sortAsc);</span>
<span class="fc" id="L1301">		getOrCreateComponentModel().rowIndexMapping = rowIndexMappings;</span>

<span class="fc" id="L1303">		setSort(sortCol, sortAsc);</span>

<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">		if (rowIndexMappings == null) {</span>
			// There's no way to correlate the previously selected row indices
			// with the new order of rows, so we need to clear out the selection.
<span class="nc" id="L1308">			setSelectedRows(null);</span>
<span class="nc" id="L1309">			setExpandedRows(null);</span>
		}
<span class="fc" id="L1311">	}</span>

	/**
	 * Handles a request containing row selection data.
	 *
	 * @param request the request containing row selection data.
	 */
	private void handleSelectionRequest(final Request request) {
<span class="fc" id="L1319">		String[] paramValue = request.getParameterValues(getId() + &quot;.selected&quot;);</span>

<span class="fc bfc" id="L1321" title="All 2 branches covered.">		if (paramValue == null) {</span>
<span class="fc" id="L1322">			paramValue = new String[0];</span>
		}

<span class="fc" id="L1325">		Map&lt;List&lt;Integer&gt;, Object&gt; pageRowKeys = getCurrentRowIndexAndKeys();</span>

<span class="fc" id="L1327">		String[] selectedRows = removeEmptyStrings(paramValue);</span>
<span class="fc" id="L1328">		Set&lt;?&gt; oldSelections = getSelectedRows();</span>
		Set&lt;Object&gt; newSelections;

<span class="fc bfc" id="L1331" title="All 2 branches covered.">		boolean singleSelect = getSelectMode() == SelectMode.SINGLE;</span>

<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">		if (getTableModel().getRowCount() == 0) {</span>
<span class="nc" id="L1334">			newSelections = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1335">			selectedRows = new String[0];</span>
<span class="pc bpc" id="L1336" title="5 of 6 branches missed.">		} else if (getPaginationMode() == PaginationMode.NONE || getPaginationMode() == PaginationMode.CLIENT</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">				|| oldSelections == null || !isPaginated()) {</span>
<span class="fc" id="L1338">			newSelections = new HashSet&lt;&gt;(selectedRows.length);</span>
<span class="nc bnc" id="L1339" title="All 4 branches missed.">		} else if (singleSelect &amp;&amp; selectedRows.length &gt; 0) {</span>
			// For single-select, we need to remove the old entries
<span class="nc" id="L1341">			newSelections = new HashSet&lt;&gt;(1);</span>
		} else {
			// For multi-select, we need the entries for the current page only
<span class="nc" id="L1344">			newSelections = new HashSet&lt;&gt;(oldSelections);</span>
<span class="nc" id="L1345">			newSelections.removeAll(pageRowKeys.values());</span>
		}

<span class="fc bfc" id="L1348" title="All 2 branches covered.">		for (String selectedRow : selectedRows) {</span>
<span class="fc" id="L1349">			List&lt;Integer&gt; rowIndex = TableUtil.rowIndexStringToList(selectedRow);</span>
<span class="fc" id="L1350">			Object key = pageRowKeys.get(rowIndex);</span>
<span class="pc bpc" id="L1351" title="1 of 2 branches missed.">			if (key == null) {</span>
<span class="nc" id="L1352">				continue;</span>
			}
<span class="fc" id="L1354">			newSelections.add(key);</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">			if (singleSelect) {</span>
<span class="fc" id="L1356">				break;</span>
			}
		}

<span class="fc" id="L1360">		setSelectedRows(newSelections);</span>

		// If there is a selection change action specified, it may need to be fired
<span class="fc" id="L1363">		Action selectionChangeAction = getSelectionChangeAction();</span>

<span class="pc bpc" id="L1365" title="3 of 4 branches missed.">		if (selectionChangeAction != null &amp;&amp; !newSelections.equals(oldSelections)) {</span>
<span class="nc" id="L1366">			selectionChangeAction.execute(new ActionEvent(this, SELECTION_ACTION_COMMAND));</span>
		}
<span class="fc" id="L1368">	}</span>

	/**
	 * Handles a request containing row expansion data.
	 *
	 * @param request the request containing row expansion data.
	 */
	private void handleExpansionRequest(final Request request) {
<span class="fc" id="L1376">		String[] paramValue = request.getParameterValues(getId() + &quot;.expanded&quot;);</span>

<span class="fc bfc" id="L1378" title="All 2 branches covered.">		if (paramValue == null) {</span>
<span class="fc" id="L1379">			paramValue = new String[0];</span>
		}

<span class="fc" id="L1382">		Map&lt;List&lt;Integer&gt;, Object&gt; pageRowKeys = getCurrentRowIndexAndKeys();</span>

<span class="fc" id="L1384">		String[] expandedRows = removeEmptyStrings(paramValue);</span>
<span class="fc" id="L1385">		Set&lt;?&gt; oldExpansions = getExpandedRows();</span>
		Set&lt;Object&gt; newExpansions;

<span class="fc" id="L1388">		TableModel model = getTableModel();</span>

<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">		if (model.getRowCount() == 0) {</span>
<span class="nc" id="L1391">			newExpansions = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1392">			expandedRows = new String[0];</span>
<span class="pc bpc" id="L1393" title="5 of 6 branches missed.">		} else if (getPaginationMode() == PaginationMode.NONE || getPaginationMode() == PaginationMode.CLIENT</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">				|| oldExpansions == null || !isPaginated()) {</span>
<span class="fc" id="L1395">			newExpansions = new HashSet&lt;&gt;(expandedRows.length);</span>
		} else {
			// row expansions only apply to the current page
<span class="nc" id="L1398">			newExpansions = new HashSet&lt;&gt;(oldExpansions);</span>
<span class="nc" id="L1399">			newExpansions.removeAll(pageRowKeys.values());</span>
		}

<span class="fc bfc" id="L1402" title="All 2 branches covered.">		for (String expandedRow : expandedRows) {</span>
<span class="fc" id="L1403">			List&lt;Integer&gt; rowIndex = TableUtil.rowIndexStringToList(expandedRow);</span>
<span class="fc" id="L1404">			Object key = pageRowKeys.get(rowIndex);</span>
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">			if (key != null) {</span>
<span class="fc" id="L1406">				newExpansions.add(key);</span>
			}
		}

<span class="fc" id="L1410">		setExpandedRows(newExpansions);</span>
<span class="fc" id="L1411">	}</span>

	/**
	 * Handles a request containing pagination data.
	 *
	 * @param request the request containing a pagination data.
	 */
	private void handlePaginationRequest(final Request request) {
<span class="fc" id="L1419">		String rowsStr = request.getParameter(getId() + &quot;.rows&quot;);</span>

<span class="fc" id="L1421">		int prevPage = getCurrentPage();</span>
<span class="fc" id="L1422">		int prevRows = getRowsPerPage();</span>

<span class="fc" id="L1424">		boolean rowsChanged = false;</span>

		// Check for rows per page option and is valid
<span class="pc bpc" id="L1427" title="1 of 4 branches missed.">		if (rowsStr != null &amp;&amp; getRowsPerPageOptions() != null) {</span>
			try {
<span class="fc" id="L1429">				int newRows = Integer.parseInt(rowsStr);</span>
				// If rows option changed
<span class="fc bfc" id="L1431" title="All 2 branches covered.">				if (prevRows != newRows) {</span>
					// Set rows
<span class="fc" id="L1433">					setRowsPerPage(newRows);</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">					if (newRows == 0) {</span>
<span class="fc" id="L1435">						setCurrentPage(0);</span>
					} else {
						// Try to calc the page the previous top row was on
<span class="fc" id="L1438">						int startIdx = prevPage * prevRows;</span>
<span class="fc" id="L1439">						int page = startIdx / newRows;</span>
<span class="fc" id="L1440">						setCurrentPage(page);</span>
					}
<span class="fc" id="L1442">					rowsChanged = true;</span>
				}
<span class="nc" id="L1444">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L1445">				LOG.warn(&quot;Invalid rows option: &quot; + rowsStr);</span>
<span class="fc" id="L1446">			}</span>
		}

		// Check for the current page
<span class="pc bpc" id="L1450" title="1 of 4 branches missed.">		if (!rowsChanged &amp;&amp; isPaginated()) {</span>
<span class="fc" id="L1451">			String pageStr = request.getParameter(getId() + &quot;.page&quot;);</span>
<span class="pc bpc" id="L1452" title="1 of 2 branches missed.">			if (pageStr == null) {</span>
<span class="nc" id="L1453">				setCurrentPage(0);</span>
			} else {
				try {
<span class="fc" id="L1456">					int pageNum = Integer.parseInt(pageStr);</span>
<span class="fc" id="L1457">					setCurrentPage(pageNum);</span>
<span class="nc" id="L1458">				} catch (NumberFormatException e) {</span>
<span class="nc" id="L1459">					LOG.warn(&quot;Invalid page number: &quot; + pageStr);</span>
<span class="fc" id="L1460">				}</span>
			}
		}

<span class="fc" id="L1464">	}</span>

	/**
	 * Helper that removes empty/null string from the &lt;code&gt;original&lt;/code&gt; string array.
	 *
	 * @param originals The string array from which the null/empty strings should be removed from.
	 * @return Array of non empty strings from the &lt;code&gt;original&lt;/code&gt; string array.
	 */
	private String[] removeEmptyStrings(final String[] originals) {
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">		if (originals == null) {</span>
<span class="nc" id="L1474">			return null;</span>
		} else {
<span class="fc" id="L1476">			List&lt;String&gt; parsed = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1478" title="All 2 branches covered.">			for (String original : originals) {</span>
<span class="pc bpc" id="L1479" title="2 of 4 branches missed.">				if (original != null &amp;&amp; original.length() &gt; 0) {</span>
<span class="fc" id="L1480">					parsed.add(original);</span>
				}
			}

<span class="fc" id="L1484">			return parsed.toArray(new String[parsed.size()]);</span>
		}
	}

	/**
	 * Override preparePaint to register an AJAX operation if necessary.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	protected void preparePaintComponent(final Request request) {
<span class="fc" id="L1495">		super.preparePaintComponent(request);</span>

<span class="fc bfc" id="L1497" title="All 4 branches covered.">		if (getRowsPerPageOptions() != null || PaginationMode.DYNAMIC.equals(getPaginationMode()) || SortMode.DYNAMIC.</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">				equals(getSortMode())</span>
<span class="fc bfc" id="L1499" title="All 4 branches covered.">				|| ExpandMode.DYNAMIC.equals(getExpandMode()) || ExpandMode.LAZY.equals(</span>
<span class="fc" id="L1500">				getExpandMode())) {</span>
<span class="fc" id="L1501">			AjaxHelper.registerComponentTargetItself(getId(), request);</span>
		}
<span class="fc" id="L1503">	}</span>

	/**
	 * Method to call when the model data has changed. For example, when a row has been added or removed.
	 * &lt;p&gt;
	 * Handles resorting the data (if table sorted) and making sure the table pagination is still correct.
	 * &lt;/p&gt;
	 */
	public void handleDataChanged() {
		// Apply sort (if required)
<span class="nc bnc" id="L1513" title="All 2 branches missed.">		if (isSorted()) {</span>
<span class="nc" id="L1514">			sort(getSortColumnIndex(), isSortAscending());</span>
		}
<span class="nc" id="L1516">		setCurrentPage(getCurrentPage());</span>
<span class="nc" id="L1517">	}</span>

	/**
	 * Allows a subclass to provide the ID used in the row naming context. It is important this ID is unique for each
	 * row.
	 * &lt;p&gt;
	 * The returned ID must only contain letters, digits or underscores.
	 * &lt;/p&gt;
	 *
	 * @param rowIndex the current row index
	 * @param rowKey the current row key.
	 * @return the unique row id or null to use the default context id
	 */
	protected String getRowIdName(final List&lt;Integer&gt; rowIndex, final Object rowKey) {
<span class="fc" id="L1531">		return null;</span>
	}

	/**
	 * Describes a constraint on a table action.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public static final class ActionConstraint implements Serializable {

		/**
		 * The minimum number of rows which must be selected to fulfil the constraint.
		 */
		private int minSelectedRowCount;

		/**
		 * The maximum number of rows which must be selected to fulfil the constraint.
		 */
		private int maxSelectedRowCount;

		/**
		 * True if the constraint is an error, false for a warning.
		 */
		private boolean error;

		/**
		 * The message to display when the constraint is not met.
		 */
		private String message;

		/**
		 * Creates an action constraint.
		 *
		 * @param minSelectedRowCount the minimum number of rows which must be selected to fulfil the constraint, or
		 * zero for any number of rows.
		 * @param maxSelectedRowCount the maximum number of rows which can be selected to fulfil the constraint, or zero
		 * for any number of rows.
		 * @param error true if the constraint is an error, false for a warning.
		 * @param message the message to display when the constraint is not met.
		 */
		public ActionConstraint(final int minSelectedRowCount, final int maxSelectedRowCount,
				final boolean error,
<span class="fc" id="L1574">				final String message) {</span>
<span class="fc" id="L1575">			this.minSelectedRowCount = minSelectedRowCount;</span>
<span class="fc" id="L1576">			this.maxSelectedRowCount = maxSelectedRowCount;</span>
<span class="fc" id="L1577">			this.error = error;</span>
<span class="fc" id="L1578">			this.message = message;</span>
<span class="fc" id="L1579">		}</span>

		/**
		 * Indicates the minimum number of rows which must be selected for the error/warning not to occur.
		 *
		 * @return the minimum selected row count.
		 */
		public int getMinSelectedRowCount() {
<span class="fc" id="L1587">			return minSelectedRowCount;</span>
		}

		/**
		 * @param minSelectedRowCount the minimum selected row count to set.
		 */
		public void setMinSelectedRowCount(final int minSelectedRowCount) {
<span class="fc" id="L1594">			this.minSelectedRowCount = minSelectedRowCount;</span>
<span class="fc" id="L1595">		}</span>

		/**
		 * Indicates the maximum number of rows which can be selected for the error/warning not to occur.
		 *
		 * @return the maximum selected row count.
		 */
		public int getMaxSelectedRowCount() {
<span class="fc" id="L1603">			return maxSelectedRowCount;</span>
		}

		/**
		 * @param maxSelectedRowCount the maximum selected row count to set.
		 */
		public void setMaxSelectedRowCount(final int maxSelectedRowCount) {
<span class="fc" id="L1610">			this.maxSelectedRowCount = maxSelectedRowCount;</span>
<span class="fc" id="L1611">		}</span>

		/**
		 * Indicates whether the constraint is an error or warning.
		 *
		 * @return true if the constraint is an error, false for a warning.
		 */
		public boolean isError() {
<span class="fc" id="L1619">			return error;</span>
		}

		/**
		 * Sets whether the constraint is an error or warning.
		 *
		 * @param error true if the constraint is an error, false for a warning.
		 */
		public void setError(final boolean error) {
<span class="fc" id="L1628">			this.error = error;</span>
<span class="fc" id="L1629">		}</span>

		/**
		 * @return the message.
		 */
		public String getMessage() {
<span class="fc" id="L1635">			return message;</span>
		}

		/**
		 * @param message the message to set.
		 */
		public void setMessage(final String message) {
<span class="fc" id="L1642">			this.message = message;</span>
<span class="fc" id="L1643">		}</span>
	}

	/**
	 * A bean provider implementation which uses the bean bound to the table.
	 */
	private static final class BeanBoundTableModelBeanProvider implements BeanProvider, Serializable {

		private final WTable table;

		/**
		 * @param table the parent table
		 */
<span class="fc" id="L1656">		private BeanBoundTableModelBeanProvider(final WTable table) {</span>
<span class="fc" id="L1657">			this.table = table;</span>
<span class="fc" id="L1658">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Object getBean(final BeanProviderBound beanProviderBound) {
<span class="fc" id="L1665">			return table.getBeanValue();</span>
		}
	}

	/**
	 * A bean provider implementation which provides beans to the table repeater. This provider takes the table's
	 * pagination state into account, so that only visible rows are rendered.
	 */
	private static final class RepeaterRowIdBeanProvider implements BeanProvider, Serializable {

		private final WTable table;

		/**
		 * @param table the parent table
		 */
<span class="fc" id="L1680">		private RepeaterRowIdBeanProvider(final WTable table) {</span>
<span class="fc" id="L1681">			this.table = table;</span>
<span class="fc" id="L1682">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Object getBean(final BeanProviderBound beanProviderBound) {
<span class="fc" id="L1689">			TableModel dataModel = table.getTableModel();</span>
<span class="fc" id="L1690">			int rowCount = dataModel.getRowCount();</span>

<span class="fc bfc" id="L1692" title="All 2 branches covered.">			if (rowCount == 0) {</span>
<span class="fc" id="L1693">				return Collections.emptyList();</span>
			}

<span class="fc" id="L1696">			int startIndex = 0;</span>
<span class="fc" id="L1697">			int endIndex = rowCount - 1;</span>

<span class="pc bpc" id="L1699" title="1 of 4 branches missed.">			if (PaginationMode.DYNAMIC == table.getPaginationMode() &amp;&amp; table.isPaginated()) {</span>
<span class="fc" id="L1700">				int rowsPerPage = table.getRowsPerPage();</span>
<span class="fc" id="L1701">				int currentPage = table.getCurrentPage();</span>
				// Only render the rows on the current page
				// If total row count has changed, calc the new last page
<span class="fc" id="L1704">				startIndex = Math.</span>
<span class="fc" id="L1705">						min(currentPage * rowsPerPage, rowCount - (rowCount % rowsPerPage));</span>
<span class="fc" id="L1706">				endIndex = Math.min(startIndex + rowsPerPage, rowCount) - 1;</span>
			}

<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">			if (endIndex &lt; startIndex) {</span>
				// No data
<span class="nc" id="L1711">				return Collections.EMPTY_LIST;</span>
			}

<span class="fc" id="L1714">			return table.getRowIds(startIndex, endIndex, false);</span>
		}
	}

	/**
	 * Determine the row ids for the provided index range.
	 *
	 * @param startIndex the startIndex
	 * @param endIndex the endIndex
	 * @param forUpdate true if building list of rowids for rows that need updating
	 * @return the list of rowIds for the provided index range
	 */
	private List&lt;RowIdWrapper&gt; getRowIds(final int startIndex, final int endIndex,
			final boolean forUpdate) {
<span class="fc" id="L1728">		TableModel model = getTableModel();</span>

		// If the table is sorted, we may require a mapping for table row index &lt;--&gt; data model index.
<span class="fc" id="L1731">		int[] rowIndexMapping = getComponentModel().rowIndexMapping;</span>

		// Check if sort mapping needs updating
<span class="pc bpc" id="L1734" title="2 of 6 branches missed.">		if (isSorted() &amp;&amp; rowIndexMapping != null &amp;&amp; rowIndexMapping.length != model.getRowCount()) {</span>
<span class="nc" id="L1735">			rowIndexMapping = model.sort(getSortColumnIndex(), isSortAscending());</span>
<span class="nc" id="L1736">			getOrCreateComponentModel().rowIndexMapping = rowIndexMapping;</span>
		}

<span class="fc" id="L1739">		List&lt;RowIdWrapper&gt; rowIds = new ArrayList&lt;&gt;(endIndex - startIndex + 1);</span>

<span class="fc" id="L1741">		ExpandMode mode = getExpandMode();</span>
<span class="fc bfc" id="L1742" title="All 2 branches covered.">		boolean expandable = mode != ExpandMode.NONE;</span>

		// Expanded rows - for update, include rows that have been previously expanded
<span class="fc" id="L1745">		Set&lt;?&gt; expanded = null;</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">		if (expandable) {</span>
<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">			expanded = forUpdate ? getPrevExpandedRows() : getExpandedRows();</span>
		}

		// Rendered rows - for update, only process rows that have been rendered
<span class="fc" id="L1751">		Set&lt;?&gt; rendered = null;</span>
<span class="fc" id="L1752">		int renderedCount = 0;</span>
<span class="pc bpc" id="L1753" title="1 of 2 branches missed.">		if (forUpdate) {</span>
<span class="nc" id="L1754">			rendered = getPrevRenderedRows();</span>
			// Check if no rows previously rendered
<span class="nc bnc" id="L1756" title="All 2 branches missed.">			if (rendered.isEmpty()) {</span>
<span class="nc" id="L1757">				return Collections.EMPTY_LIST;</span>
			}
		}

<span class="fc" id="L1761">		boolean editable = isEditable();</span>

<span class="fc bfc" id="L1763" title="All 2 branches covered.">		for (int i = startIndex; i &lt;= endIndex; i++) {</span>
			// Create top level
<span class="fc" id="L1765">			List&lt;Integer&gt; rowIndex = new ArrayList&lt;&gt;(1);</span>

			// Map ids (if sorted)
<span class="fc bfc" id="L1768" title="All 2 branches covered.">			if (rowIndexMapping == null) {</span>
<span class="fc" id="L1769">				rowIndex.add(i);</span>
			} else {
<span class="fc" id="L1771">				rowIndex.add(rowIndexMapping[i]);</span>
			}

			// Row key
<span class="fc" id="L1775">			Object key = model.getRowKey(rowIndex);</span>

			// For update, only process rows that have been rendered
<span class="pc bpc" id="L1778" title="3 of 4 branches missed.">			if (forUpdate &amp;&amp; !rendered.contains(key)) {</span>
<span class="nc" id="L1779">				continue;</span>
			}

			// Create wrapper
<span class="fc" id="L1783">			RowIdWrapper wrapper = new RowIdWrapper(rowIndex, key, null);</span>

<span class="fc bfc" id="L1785" title="All 2 branches covered.">			if (expandable) {</span>
<span class="fc" id="L1786">				calcChildrenRowIds(rowIds, wrapper, model, null, expanded, mode, forUpdate, editable);</span>
			} else {
<span class="fc" id="L1788">				rowIds.add(wrapper);</span>
			}

			// For update, check if all rendered rows have been processed
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">			if (forUpdate) {</span>
<span class="nc" id="L1793">				renderedCount++;</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">				if (renderedCount == rendered.size()) {</span>
					// No need to keep processing
<span class="nc" id="L1796">					break;</span>
				}
			}

			// For render, keep rows that have been rendered for update logic (only if table editable)
<span class="pc bpc" id="L1801" title="3 of 4 branches missed.">			if (editable &amp;&amp; !forUpdate) {</span>
<span class="nc" id="L1802">				addPrevRenderedRow(key);</span>
			}
		}

		// Set the position of each row in the list of row ids.
<span class="fc" id="L1807">		int i = 0;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">		for (RowIdWrapper row : rowIds) {</span>
<span class="fc" id="L1809">			row.setPosition(i++);</span>
<span class="fc" id="L1810">		}</span>

<span class="fc" id="L1812">		return rowIds;</span>
	}

	/**
	 * Calculate the row ids of a row's children.
	 *
	 * @param rows the list of row ids
	 * @param row the current row
	 * @param model the table model
	 * @param parent the row's parent
	 * @param expanded the set of expanded rows
	 * @param mode the table expand mode
	 * @param forUpdate true if building list of row ids to update
	 * @param editable true if the table is editable
	 */
	@SuppressWarnings(&quot;checkstyle:parameternumber&quot;)
	private void calcChildrenRowIds(final List&lt;RowIdWrapper&gt; rows, final RowIdWrapper row,
			final TableModel model,
			final RowIdWrapper parent, final Set&lt;?&gt; expanded, final ExpandMode mode,
			final boolean forUpdate, final boolean editable) {
		// Add row
<span class="fc" id="L1833">		rows.add(row);</span>

		// Add to parent
<span class="fc bfc" id="L1836" title="All 2 branches covered.">		if (parent != null) {</span>
<span class="fc" id="L1837">			parent.addChild(row);</span>
		}

<span class="fc" id="L1840">		List&lt;Integer&gt; rowIndex = row.getRowIndex();</span>

		// If row has a renderer, then dont need to process its children (should not have any anyway as it is a &quot;leaf&quot;)
<span class="fc bfc" id="L1843" title="All 2 branches covered.">		if (model.getRendererClass(rowIndex) != null) {</span>
<span class="fc" id="L1844">			return;</span>
		}

		// Check row is expandable
<span class="fc bfc" id="L1848" title="All 2 branches covered.">		if (!model.isExpandable(rowIndex)) {</span>
<span class="fc" id="L1849">			return;</span>
		}

		// Check has children
<span class="fc bfc" id="L1853" title="All 2 branches covered.">		if (!model.hasChildren(rowIndex)) {</span>
<span class="fc" id="L1854">			return;</span>
		}
<span class="fc" id="L1856">		row.setHasChildren(true);</span>

		// Always add children if CLIENT mode or row is expanded
<span class="pc bpc" id="L1859" title="5 of 6 branches missed.">		boolean addChildren = (mode == ExpandMode.CLIENT) || (expanded != null &amp;&amp; expanded.contains(</span>
<span class="nc" id="L1860">				row.getRowKey()));</span>
<span class="pc bpc" id="L1861" title="1 of 2 branches missed.">		if (!addChildren) {</span>
<span class="nc" id="L1862">			return;</span>
		}

		// Get actual child count
<span class="fc" id="L1866">		int children = model.getChildCount(rowIndex);</span>
<span class="pc bpc" id="L1867" title="1 of 2 branches missed.">		if (children == 0) {</span>
			// Could be there are no children even though hasChildren returned true
<span class="nc" id="L1869">			row.setHasChildren(false);</span>
<span class="nc" id="L1870">			return;</span>
		}

		// Render mode, Keep rows that have been expanded (only if table editable)
<span class="pc bpc" id="L1874" title="2 of 4 branches missed.">		if (!forUpdate &amp;&amp; editable) {</span>
<span class="nc" id="L1875">			addPrevExpandedRow(row.getRowKey());</span>
		}

		// Add children by processing each child row
<span class="fc bfc" id="L1879" title="All 2 branches covered.">		for (int i = 0; i &lt; children; i++) {</span>
			// Add next level
<span class="fc" id="L1881">			List&lt;Integer&gt; nextRow = new ArrayList&lt;&gt;(row.getRowIndex());</span>
<span class="fc" id="L1882">			nextRow.add(i);</span>
			// Create Wrapper
<span class="fc" id="L1884">			Object key = model.getRowKey(nextRow);</span>
<span class="fc" id="L1885">			RowIdWrapper wrapper = new RowIdWrapper(nextRow, key, row);</span>
<span class="fc" id="L1886">			calcChildrenRowIds(rows, wrapper, model, row, expanded, mode, forUpdate, editable);</span>
		}
<span class="fc" id="L1888">	}</span>

	/**
	 * @return the current page row indexes and their keys
	 */
	private Map&lt;List&lt;Integer&gt;, Object&gt; getCurrentRowIndexAndKeys() {
<span class="fc" id="L1894">		List&lt;RowIdWrapper&gt; wrappers = repeater.getBeanList();</span>
<span class="pc bpc" id="L1895" title="2 of 4 branches missed.">		if (wrappers == null || wrappers.isEmpty()) {</span>
<span class="nc" id="L1896">			return Collections.EMPTY_MAP;</span>
		}

<span class="fc" id="L1899">		Map&lt;List&lt;Integer&gt;, Object&gt; rows = new HashMap&lt;&gt;(wrappers.size());</span>
<span class="fc bfc" id="L1900" title="All 2 branches covered.">		for (RowIdWrapper wrapper : wrappers) {</span>
<span class="fc" id="L1901">			rows.put(wrapper.getRowIndex(), wrapper.getRowKey());</span>
<span class="fc" id="L1902">		}</span>
<span class="fc" id="L1903">		return rows;</span>
	}

	/**
	 * Contains the table's UI state.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
<span class="fc" id="L1912">	public static final class WTableComponentModel extends BeanAndProviderBoundComponentModel {</span>

		/**
		 * The margins to be used on the table.
		 */
		private Margin margin;

		/**
		 * This controls how sorting should function. Sortability is determined by the data model.
		 */
<span class="fc" id="L1922">		private SortMode sortMode = SortMode.NONE;</span>

		/**
		 * The data model for the table.
		 */
<span class="fc" id="L1927">		private TableModel tableModel = EmptyTableModel.INSTANCE;</span>

		/**
		 * Controls whether background striping is used to distinguish rows/columns from each other.
		 */
<span class="fc" id="L1932">		private StripingType stripingType = StripingType.NONE;</span>

		/**
		 * Controls whether a visual separator is used to distinguish rows/columns from each other.
		 */
<span class="fc" id="L1937">		private SeparatorType separatorType = SeparatorType.NONE;</span>

		/**
		 * This flag indicates whether column headers should be displayed.
		 */
<span class="fc" id="L1942">		private boolean showColumnHeaders = true;</span>

		/**
		 * The action to execute when the table's row selection changes.
		 */
		private Action selectionChangeAction;

		/**
		 * The text to display when the table contains no data.
		 */
<span class="fc" id="L1952">		private String noDataMessage = InternalMessages.DEFAULT_NO_TABLE_DATA;</span>

		/**
		 * The table summary text.
		 */
		private String summary;

		/**
		 * The table caption text.
		 */
		private String caption;

		/**
		 * The column order, only used for re-ordering columns.
		 */
		private int[] columnOrder;

		/**
		 * This is used to control how table data should be displayed.
		 */
<span class="fc" id="L1972">		private Type type = Type.TABLE;</span>

		// Pagination
		/**
		 * Indicates how pagination should occur.
		 */
<span class="fc" id="L1978">		private PaginationMode paginationMode = PaginationMode.NONE;</span>

		/**
		 * Indicates how many rows to display per page.
		 */
<span class="fc" id="L1983">		private int rowsPerPage = DEFAULT_ROWS;</span>

		/**
		 * Options for rows per page.
		 */
		private List&lt;Integer&gt; rowsPerPageOptions;

		/**
		 * Stores the current page index.
		 */
		private int currentPage;

		/**
		 * Stores the location to show the pagination controls.
		 */
<span class="fc" id="L1998">		private PaginationLocation paginationLocation = PaginationLocation.AUTO;</span>

		// Selection
		/**
		 * Indicates how row selection should function.
		 */
<span class="fc" id="L2004">		private SelectMode selectMode = SelectMode.NONE;</span>

		/**
		 * Indicates how the &quot;select all&quot; control should appear.
		 */
<span class="fc" id="L2009">		private SelectAllType selectAllMode = SelectAllType.TEXT;</span>

		/**
		 * Holds the keys of the currently selected rows.
		 */
		private Set&lt;?&gt; selectedRows;

		/**
		 * Indicates that de/selecting a row with sub rows will de/select the sub rows.
		 */
<span class="fc" id="L2019">		private boolean toggleSubRowSelection = false;</span>

		// Row expansion
		/**
		 * Indicates how row expansion should function.
		 */
<span class="fc" id="L2025">		private ExpandMode expandMode = ExpandMode.NONE;</span>

		/**
		 * Indicates whether a &quot;expand/collapse all&quot; control should be displayed.
		 */
<span class="fc" id="L2030">		private boolean expandAll = false;</span>

		/**
		 * Holds the keys of currently expanded rows.
		 */
		private Set&lt;?&gt; expandedRows;

		/**
		 * Holds the keys of rows that have been expanded (used for bean updating logic).
		 */
		private Set&lt;Object&gt; prevExpandedRows;

		/**
		 * Holds the keys of rows that have been rendered (used for bean updating logic).
		 */
		private Set&lt;Object&gt; prevRenderedRows;

		/**
		 * Flag if table cells/rows are editable. If true, extra details about each row need to be stored.
		 */
		private boolean editable;

		// Sorting
		/**
		 * Holds the currently sorted column index. A value of -1 indicates no active sort.
		 */
<span class="fc" id="L2056">		private int sortColIndex = -1;</span>

		/**
		 * Indicates whether the sort is ascending (true) or descending (false).
		 */
		private boolean sortAscending;

		/**
		 * This is used to map rendered table row indices to table model row indices, if the table model supports this
		 * mode of sorting.
		 */
		private int[] rowIndexMapping;

		// Action constraints
		/**
		 * This map holds the action constraints per table action (button).
		 */
<span class="fc" id="L2073">		private final Map&lt;WComponent, List&lt;ActionConstraint&gt;&gt; actionConstraints = new HashMap&lt;&gt;();</span>

		/**
		 * @return the maximum page number.
		 */
		private int getMaxPage() {
<span class="fc" id="L2079">			int rowCount = tableModel.getRowCount();</span>

<span class="fc bfc" id="L2081" title="All 2 branches covered.">			if (rowCount == 0) {</span>
<span class="fc" id="L2082">				return 0;</span>
<span class="fc bfc" id="L2083" title="All 4 branches covered.">			} else if (paginationMode == PaginationMode.NONE || rowsPerPage == 0) {</span>
				// NONE Pagination or Zero rows per page indicates no pagination when using rows per page options
<span class="fc" id="L2085">				return 0;</span>
			} else {
<span class="fc bfc" id="L2087" title="All 2 branches covered.">				return rowCount / rowsPerPage - (rowCount % rowsPerPage == 0 ? 1 : 0);</span>
			}
		}

		/**
		 * Adds a constraint to the list of constraints for the given button.
		 *
		 * @param button the button to add the constraint for.
		 * @param constraint the constraint to add.
		 */
		public void addActionConstraint(final WButton button, final ActionConstraint constraint) {
<span class="fc" id="L2098">			List&lt;ActionConstraint&gt; constraintForComponent = actionConstraints.get(button);</span>

<span class="fc bfc" id="L2100" title="All 2 branches covered.">			if (constraintForComponent == null) {</span>
<span class="fc" id="L2101">				constraintForComponent = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2102">				actionConstraints.put(button, constraintForComponent);</span>
			}

<span class="fc" id="L2105">			constraintForComponent.add(constraint);</span>
<span class="fc" id="L2106">		}</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public int getChildCount() {
<span class="fc" id="L2115">		return super.getChildCount();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public WComponent getChildAt(final int index) {
<span class="fc" id="L2124">		return super.getChildAt(index);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public int getIndexOfChild(final WComponent childComponent) {
<span class="fc" id="L2133">		return super.getIndexOfChild(childComponent);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public List&lt;WComponent&gt; getChildren() {
<span class="nc" id="L2142">		return super.getChildren();</span>
	}

	/**
	 * @return a String representation of this component, for debugging purposes.
	 */
	@Override
	public String toString() {
<span class="nc" id="L2150">		TableModel model = getTableModel();</span>
<span class="nc" id="L2151">		return toString(model.getClass().getSimpleName() + &quot;, &quot; + model.getRowCount() + &quot; rows&quot;, -1,</span>
				-1);
	}

	/**
	 * A naming context is only considered active if it has been set active via {@link #setNamingContext(boolean)} and
	 * also has an id name set via {@link #setIdName(String)}.
	 *
	 * @param context set true if this is a naming context.
	 */
	public void setNamingContext(final boolean context) {
<span class="fc" id="L2162">		setFlag(ComponentModel.NAMING_CONTEXT_FLAG, context);</span>
<span class="fc" id="L2163">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isNamingContext() {
<span class="fc" id="L2170">		return isFlagSet(ComponentModel.NAMING_CONTEXT_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getNamingContextId() {
<span class="fc" id="L2178">		return getId();</span>
	}

	/**
	 * Creates a new component model.
	 *
	 * @return a new TableModel.
	 */
	@Override
	protected WTableComponentModel newComponentModel() {
<span class="fc" id="L2188">		return new WTableComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// for type safety only
	protected WTableComponentModel getComponentModel() {
<span class="fc" id="L2197">		return (WTableComponentModel) super.getComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// for type safety only
	protected WTableComponentModel getOrCreateComponentModel() {
<span class="fc" id="L2206">		return (WTableComponentModel) super.getOrCreateComponentModel();</span>
	}

	/**
	 * &lt;p&gt;
	 * TableModel provides the data for tables. In a MVC sense, the TableModel is the Model, the {@link WTable} is the
	 * controller and the view is comprised of the WTable layout and column renderers.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Note that Data may be stored locally or sourced remotely, depending on the particular TableModel implementation.
	 * &lt;p&gt;
	 * &lt;p&gt;
	 * The row indexes used in the interface are a list of row indexes. Each item in the list is the index of the row
	 * for that level. The size of the list passed in matches the depth of the row.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Row and column indices for all methods are zero-based, and TableModels are not expected to perform
	 * bounds-checking.
	 * &lt;/p&gt;
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface TableModel {

		/**
		 * Retrieves the value at the given row and column.
		 *
		 * @param row - the row index.
		 * @param col - the column index. Column of -1 indicates row has a renderer.
		 * @return the value at the given row and column.
		 */
		Object getValueAt(List&lt;Integer&gt; row, int col);

		/**
		 * Indicates whether the given cell is editable.
		 *
		 * @param row - the row index.
		 * @param col - the column index. Column of -1 indicates row has a renderer.
		 * @return true if the given cell is editable, false otherwise.
		 */
		boolean isCellEditable(List&lt;Integer&gt; row, int col);

		/**
		 * Sets the value at the given row and column.
		 *
		 * @param value the value to set.
		 * @param row - the row index.
		 * @param col - the column index.
		 */
		void setValueAt(Object value, List&lt;Integer&gt; row, int col);

		/**
		 * Indicates whether the model supports sorting by the given column.
		 *
		 * @param col the column index.
		 * @return true if the model is sortable by the given column, false otherwise.
		 */
		boolean isSortable(int col);

		/**
		 * &lt;p&gt;
		 * Sorts the data by the given column. Any previous sorting should be disregarded.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * Data models must implement sorting in one of two ways.
		 * &lt;/p&gt;
		 * &lt;ol&gt;
		 * &lt;li&gt;
		 * &lt;p&gt;
		 * If the data is accessible locally by the data model (ie. a sort won't result in a service call to obtain
		 * sorted data), then this method should not sort the actual data, but return a row-index mapping which the
		 * table will use to access the data. Row selection and expansion will be updated to use the new row indices.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * For example, if the data for the column is {&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;c&quot;}, then an ascending sort should return {0, 1,
		 * 3, 2}, and a descending sort {2, 3, 1, 0}.
		 * &lt;/p&gt;
		 * &lt;/li&gt;
		 * &lt;li&gt;
		 * &lt;p&gt;
		 * If the data is not accessible locally by the data model, or the model is otherwise unable to perform a
		 * mapping between old and new row indices, then the model should sort the actual data, and return null. In this
		 * case, the table will reset any row selection or expansion.
		 * &lt;/p&gt;
		 * &lt;/li&gt;
		 * &lt;/ol&gt;
		 *
		 * @param col the column to sort on
		 * @param ascending true for an ascending sort, false for descending.
		 * @return the row indices in sort order, or null if row mappings can not be determined.
		 */
		int[] sort(int col, boolean ascending);

		/**
		 * Indicates whether the given row is disabled.
		 *
		 * @param row the row index
		 * @return true if the row is disabled, false otherwise.
		 */
		boolean isDisabled(List&lt;Integer&gt; row);

		/**
		 * Indicates whether the given row is selectable.
		 *
		 * @param row the row index
		 * @return true if the row is selectable, false otherwise.
		 */
		boolean isSelectable(List&lt;Integer&gt; row);

		/**
		 * Indicates whether the given row is expandable.
		 *
		 * @param row the row index
		 * @return true if the row is expandable, false otherwise.
		 */
		boolean isExpandable(List&lt;Integer&gt; row);

		/**
		 * Retrieves the number of rows for the root (ie top) level.
		 *
		 * @return the number of rows in the model for the root (ie top) level.
		 */
		int getRowCount();

		/**
		 * Allows the model to report if the row has children without actually having to determine the number of
		 * children (as it might not be known).
		 *
		 * @param row the row index
		 * @return true if the row has children
		 */
		boolean hasChildren(List&lt;Integer&gt; row);

		/**
		 * Retrieves the number of children a row has.
		 *
		 * @param row the row index
		 * @return the number of rows in the model for this level.
		 */
		int getChildCount(List&lt;Integer&gt; row);

		/**
		 * Retrieves the custom renderer for this row.
		 *
		 * @param row the row index
		 * @return the renderer class, or null if the default renderer is to be used.
		 */
		Class&lt;? extends WComponent&gt; getRendererClass(List&lt;Integer&gt; row);

		/**
		 * Retrieves the key (ie bean) used to uniquely identify this row.
		 * &lt;p&gt;
		 * The usual implementation of this method would just return the row id passed in.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * However, if you are required to dynamically add/remove rows in the model, which would change the row index,
		 * then the implementation of this method needs to return an object that uniquely identifies this row.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * When rows have been added/removed, the {@link WTable#handleDataChanged} method on WTable needs to be called.
		 * &lt;/p&gt;
		 *
		 * @param row the row index
		 * @return the key (ie bean) used to uniquely identify this row
		 */
		Object getRowKey(List&lt;Integer&gt; row);
	}

	/**
	 * This extension of {@link TableModel} is primarily for models that do not store their data locally. Models
	 * implementing this interface can provide more efficient calls to back-end systems, as the data model is notified
	 * of which rows are likely to be used in the near future.
	 * &lt;p&gt;
	 * It is expected this TableModel is always used with Pagination.
	 * &lt;/p&gt;
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface ScrollableTableModel extends TableModel {

		/**
		 * This method will be called by the table to notify the TableModel of which rows are likely to be used in the
		 * near future.
		 *
		 * @param start the starting row index.
		 * @param end the ending row index.
		 */
		void setCurrentRows(int start, int end);
	}

	/**
	 * The BeanBoundTableModel provides a link between a bean (bound to a table), and the table model API.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface BeanBoundTableModel extends TableModel, BeanProviderBound {

	}

	/**
	 * This repeater extension is necessary to ensure that tree-tables are painted correctly.
	 */
	public static class TableRepeater extends WRepeater {

		/**
		 * Parent table.
		 */
		private final WTable table;

		/**
		 * @param table the parent table.
		 */
<span class="fc" id="L2421">		public TableRepeater(final WTable table) {</span>
<span class="fc" id="L2422">			this.table = table;</span>
<span class="fc" id="L2423">			setRowIdProperty(&quot;rowKey&quot;);</span>
<span class="fc" id="L2424">			setIdName(ROW_ID_CONTEXT_PREFIX);</span>
<span class="fc" id="L2425">			setNamingContext(true);</span>
<span class="fc" id="L2426">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String getId() {
<span class="fc" id="L2433">			return table.getId() + ID_CONTEXT_SEPERATOR + getIdName();</span>
		}

		/**
		 * Override paintComponent, as the table renderer does all the work.
		 *
		 * @param renderContext the RenderContext to send output to.
		 */
		@Override
		protected void paintComponent(final RenderContext renderContext) {
			// Do nothing
<span class="nc" id="L2444">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public List&lt;RowIdWrapper&gt; getBeanList() {
<span class="fc" id="L2451">			return super.getBeanList();</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		protected void cleanupStaleContexts(final Set&lt;?&gt; rowIds) {
			// Tables that are not editable, clean up contexts. Editable tables do not do the clean up so the contexts
			// are available when changing pages
<span class="nc bnc" id="L2461" title="All 2 branches missed.">			if (!table.isEditable()) {</span>
<span class="nc" id="L2462">				super.cleanupStaleContexts(rowIds);</span>
			}
<span class="nc" id="L2464">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		protected String getRowIdName(final Object rowBean, final Object rowId) {
<span class="fc" id="L2471">			RowIdWrapper wrapper = (RowIdWrapper) rowBean;</span>
<span class="fc" id="L2472">			List&lt;Integer&gt; rowIndex = wrapper.getRowIndex();</span>
<span class="fc" id="L2473">			return table.getRowIdName(rowIndex, rowId);</span>
		}
	}

	/**
	 * Used to wrap the row index and the row key (used to uniquely identify the row).
	 * &lt;p&gt;
	 * Intended for internal use only.
	 * &lt;/p&gt;
	 */
	public static class RowIdWrapper {

		/**
		 * The row index.
		 */
		private final List&lt;Integer&gt; rowIndex;
		/**
		 * The row key.
		 */
		private final Object rowKey;
		/**
		 * The children of the row.
		 */
<span class="fc" id="L2496">		private final List&lt;RowIdWrapper&gt; children = new ArrayList&lt;&gt;();</span>
		/**
		 * Flag if row has children.
		 */
<span class="fc" id="L2500">		private boolean hasChildrenFlag = false;</span>
		/**
		 * Parent of the row.
		 */
		private final RowIdWrapper parent;
		/**
		 * Hold its position in the list.
		 */
		private int position;

		/**
		 * @param rowIndex the row index
		 * @param rowKey the row key
		 * @param parent the parent of the row, or null if no parent
		 */
		public RowIdWrapper(final List&lt;Integer&gt; rowIndex, final Object rowKey,
<span class="fc" id="L2516">				final RowIdWrapper parent) {</span>
<span class="fc" id="L2517">			this.rowIndex = rowIndex;</span>
<span class="fc" id="L2518">			this.rowKey = rowKey;</span>
<span class="fc" id="L2519">			this.parent = parent;</span>
<span class="fc" id="L2520">		}</span>

		/**
		 * @return the row index
		 */
		public List&lt;Integer&gt; getRowIndex() {
<span class="fc" id="L2526">			return rowIndex;</span>
		}

		/**
		 * @return the row key
		 */
		public Object getRowKey() {
<span class="fc" id="L2533">			return rowKey;</span>
		}

		/**
		 * @return the children of the row, or null if no children
		 */
		public List&lt;RowIdWrapper&gt; getChildren() {
<span class="nc" id="L2540">			return children;</span>
		}

		/**
		 * @param hasChildren true if row has children
		 */
		public void setHasChildren(final boolean hasChildren) {
<span class="fc" id="L2547">			this.hasChildrenFlag = hasChildren;</span>
<span class="fc" id="L2548">		}</span>

		/**
		 * @return true if the row has children
		 */
		public boolean hasChildren() {
<span class="nc" id="L2554">			return hasChildrenFlag;</span>
		}

		/**
		 * @param child the child row to add
		 */
		public void addChild(final RowIdWrapper child) {
<span class="fc" id="L2561">			children.add(child);</span>
<span class="fc" id="L2562">		}</span>

		/**
		 * @return the parent of the row, or null if no parent
		 */
		public RowIdWrapper getParent() {
<span class="fc" id="L2568">			return parent;</span>
		}

		/**
		 * @return the position of this row id in the list of row ids.
		 */
		public int getPosition() {
<span class="nc" id="L2575">			return position;</span>
		}

		/**
		 * @param position the position of this row id in the list of row ids.
		 */
		public void setPosition(final int position) {
<span class="fc" id="L2582">			this.position = position;</span>
<span class="fc" id="L2583">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>