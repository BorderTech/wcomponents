<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>WTable.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">WTable.java</span></div><h1>WTable.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.AdapterBasicTableModel.BasicTableModel;
import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.InternalMessages;
import com.github.bordertech.wcomponents.util.TableUtil;
import com.github.bordertech.wcomponents.util.Util;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * The WTable component is used to display tabular data. It supports common functions such as sorting and pagination of
 * data.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The WTable component is only concerned with how the UI functions, not the data behind the table. In a MVC sense, the
 * WTable is the Controller, the view is comprised of the WTable layout and column renderers, and the {@link TableModel}
 * is the model.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Columns may only be added statically to the table, but individual columns can be shown/hidden per user by toggling
 * their visibility. See {@link #getColumn(int)} and {@link WComponent#setVisible(boolean)}. Making columns not visible
 * can be problematic with sorting.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Another way to make columns not visible is by using {@link #setColumnOrder(int[])}. This can be used to change the
 * column order but also hide columns by not including their index in the array.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For data that is not in a tree like structure (ie not expandable), the {@link BasicTableModel} interface can be used
 * via the {@link AdapterBasicTableModel}.
 * &lt;/p&gt;
 *
 * @author Jonathan Austin
 * @since 1.0.0
 */
public class WTable extends WBeanComponent implements Container, AjaxTarget, SubordinateTarget,
		Marginable, NamingContextable {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L53">	private static final Log LOG = LogFactory.getLog(WTable.class);</span>

	/**
	 * Default rows per page.
	 */
	private static final int DEFAULT_ROWS = 10;

	/**
	 * For easy access to the columns, including the ability to hide them all at once.
	 */
<span class="fc" id="L63">	private final WContainer columns = new WContainer();</span>

	/**
	 * The repeater that is used to handle the repeated (row) content.
	 */
<span class="fc" id="L68">	private final TableRepeater repeater = new TableRepeater(this);</span>

	/**
	 * Table actions, which are normally visible at the bottom of the table.
	 */
<span class="fc" id="L73">	private final WContainer actions = new WContainer();</span>

	/**
	 * This is used to control how row selection should work.
	 */
<span class="pc" id="L78">	public enum SelectMode {</span>
		/**
		 * Indicates that row selection is not available.
		 */
<span class="fc" id="L82">		NONE,</span>
		/**
		 * Indicates that only a single row may be selected.
		 */
<span class="fc" id="L86">		SINGLE,</span>
		/**
		 * Indicates that multiple rows may be selected.
		 */
<span class="fc" id="L90">		MULTIPLE</span>
	};

	/**
	 * This is used to control how the &quot;select all&quot; function should work.
	 */
<span class="pc" id="L96">	public enum SelectAllType {</span>
		/**
		 * Indicates that the select all/none function should not be available.
		 */
<span class="fc" id="L100">		NONE,</span>
		/**
		 * Indicates that the select all/none function should is displayed as text.
		 */
<span class="fc" id="L104">		TEXT,</span>
		/**
		 * Indicates that the select all/none function should is displayed as a control (checkbox).
		 */
<span class="fc" id="L108">		CONTROL</span>
	};

	/**
	 * This is used to control how row expansion should work.
	 */
<span class="pc" id="L114">	public enum ExpandMode {</span>
		/**
		 * Indicates that row expansion is not supported.
		 */
<span class="fc" id="L118">		NONE,</span>
		/**
		 * Indicates that row expansion occurs on the client.
		 */
<span class="fc" id="L122">		CLIENT,</span>
		/**
		 * Indicates that row expansion occurs once, via AJAX.
		 */
<span class="fc" id="L126">		LAZY,</span>
		/**
		 * Indicates that row expansion should make an AJAX call every time.
		 */
<span class="fc" id="L130">		DYNAMIC</span>
	};

	/**
	 * This is used to control how pagination should work.
	 */
<span class="pc" id="L136">	public enum PaginationMode {</span>
		/**
		 * Indicates that pagination is not supported, all data will be displayed in the one page.
		 */
<span class="fc" id="L140">		NONE,</span>
		/**
		 * Indicates that pagination occurs on the client. All data will be sent at once.
		 */
<span class="fc" id="L144">		CLIENT,</span>
		/**
		 * Indicates that pagination occurs via AJAX calls to the server.
		 */
<span class="fc" id="L148">		DYNAMIC</span>
	};

	/**
	 * This is used to control the type of striping used, if any.
	 */
<span class="pc" id="L154">	public enum StripingType {</span>
		/**
		 * Indicates that no zebra striping should be used.
		 */
<span class="fc" id="L158">		NONE,</span>
		/**
		 * Indicates that zebra striping should be used to highlight rows.
		 */
<span class="fc" id="L162">		ROWS,</span>
		/**
		 * Indicates that zebra striping should be used to highlight columns.
		 */
<span class="fc" id="L166">		COLUMNS</span>
	};

	/**
	 * This is used to control the type of striping used, if any.
	 */
<span class="pc" id="L172">	public enum SeparatorType {</span>
		/**
		 * Indicates that no separators should be displayed.
		 */
<span class="fc" id="L176">		NONE,</span>
		/**
		 * Indicates that horizontal separators should be displayed.
		 */
<span class="fc" id="L180">		HORIZONTAL,</span>
		/**
		 * Indicates that vertical separators should be displayed.
		 */
<span class="fc" id="L184">		VERTICAL,</span>
		/**
		 * Indicates that both horizontal and vertical separators should be displayed.
		 */
<span class="fc" id="L188">		BOTH</span>
	};

	/**
	 * This is used to control how sorting should work.
	 */
<span class="pc" id="L194">	public enum SortMode {</span>
		/**
		 * Indicates that sorting should be disabled.
		 */
<span class="fc" id="L198">		NONE,</span>
		/**
		 * Indicates that sorting is via AJAX calls.
		 */
<span class="fc" id="L202">		DYNAMIC</span>
	};

	/**
	 * This is used to control how table data should be displayed.
	 */
<span class="pc" id="L208">	public enum Type {</span>
		/**
		 * Indicates that the table should be displayed as a normal table.
		 */
<span class="fc" id="L212">		TABLE,</span>
		/**
		 * Indicates that the table should be displayed as a hierarchical list.
		 */
<span class="fc" id="L216">		HIERARCHIC</span>
	};

	/**
	 * Prefix used in row ids.
	 */
	public static final String ROW_ID_CONTEXT_PREFIX = &quot;row&quot;;

	/**
	 * Selection action command.
	 */
	public static final String SELECTION_ACTION_COMMAND = &quot;selection&quot;;

	/**
	 * Creates a WTable.
	 */
<span class="fc" id="L232">	public WTable() {</span>
<span class="fc" id="L233">		add(columns);</span>
<span class="fc" id="L234">		add(repeater);</span>
<span class="fc" id="L235">		add(actions);</span>

<span class="fc" id="L237">		repeater.setRepeatedComponent(new WTableRowRenderer(this));</span>
<span class="fc" id="L238">		repeater.setBeanProvider(new RepeaterRowIdBeanProvider(this));</span>
<span class="fc" id="L239">	}</span>

	/**
	 * Adds a column to the table.
	 *
	 * @param column the column to add.
	 */
	public void addColumn(final WTableColumn column) {
<span class="fc" id="L247">		columns.add(column);</span>
<span class="fc" id="L248">		WTableRowRenderer renderer = (WTableRowRenderer) repeater.getRepeatedComponent();</span>
<span class="fc" id="L249">		renderer.addColumn(column, columns.getChildCount() - 1);</span>
<span class="fc" id="L250">	}</span>

	/**
	 * Retrieves the column at the specified index. Bounds checking is not performed, see {@link #getColumnCount()}.
	 *
	 * @param index the column index. Zero based.
	 * @return the column at the specified index.
	 */
	public WTableColumn getColumn(final int index) {
<span class="fc" id="L259">		return (WTableColumn) columns.getChildAt(index);</span>
	}

	/**
	 * Returns the number of columns contained in this table. Invisible columns still count towards the total.
	 *
	 * @return the number of columns contained in this table.
	 */
	public int getColumnCount() {
<span class="fc" id="L268">		return columns.getChildCount();</span>
	}

	/**
	 * @return the repeater used to render table rows.
	 */
	public TableRepeater getRepeater() {
<span class="fc" id="L275">		return repeater;</span>
	}

	/**
	 * @return the table model
	 */
	public TableModel getTableModel() {
<span class="fc" id="L282">		return getComponentModel().tableModel;</span>
	}

	/**
	 * Sets the table model which provides the row/column data.
	 *
	 * @param tableModel the table model.
	 */
	public void setTableModel(final TableModel tableModel) {
<span class="fc" id="L291">		getOrCreateComponentModel().tableModel = tableModel;</span>
<span class="fc" id="L292">		getOrCreateComponentModel().rowIndexMapping = null;</span>
<span class="fc" id="L293">		setSelectedRows(null);</span>
<span class="fc" id="L294">		setExpandedRows(null);</span>
<span class="fc" id="L295">		clearPrevExpandedRows();</span>
<span class="fc" id="L296">		clearPrevRenderedRows();</span>

<span class="fc bfc" id="L298" title="All 2 branches covered.">		if (tableModel instanceof BeanBoundTableModel) {</span>
<span class="fc" id="L299">			((BeanBoundTableModel) tableModel).</span>
<span class="fc" id="L300">					setBeanProvider(new BeanBoundTableModelBeanProvider(this));</span>
<span class="fc" id="L301">			((BeanBoundTableModel) tableModel).setBeanProperty(&quot;.&quot;);</span>
		}

<span class="pc bpc" id="L304" title="1 of 2 branches missed.">		if (tableModel instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L306">				throw new IllegalStateException(</span>
						&quot;Set a ScrollableTableModel on a table that is not paginated.&quot;);
			}

<span class="nc" id="L310">			int startIndex = getCurrentPage() * getRowsPerPage();</span>
<span class="nc" id="L311">			int endIndex = startIndex + getRowsPerPage() - 1;</span>
<span class="nc" id="L312">			((ScrollableTableModel) tableModel).setCurrentRows(startIndex, endIndex);</span>
		}

		// Flush the repeater's row contexts and scratch maps
<span class="fc" id="L316">		repeater.reset();</span>
<span class="fc" id="L317">	}</span>

	/**
	 * Updates the bean using the table data model's {@link TableModel#setValueAt(Object, List, int)} method.
	 * &lt;p&gt;
	 * The update is only applied if the table has been set as editable via {@link #setEditable(boolean)}. Only rows
	 * that have been rendered are updated.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * For {@link ScrollableTableModel}, only the rows on the current page are updated.
	 * &lt;/p&gt;
	 */
	@Override
	public void updateBeanValue() {
<span class="nc" id="L331">		TableModel model = getTableModel();</span>

		// Only apply updates if table was editable
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (!isEditable()) {</span>
<span class="nc" id="L335">			LOG.warn(&quot;UpdateBeanValue called for table that is not editable&quot;);</span>
<span class="nc" id="L336">			return;</span>
		}

<span class="nc" id="L339">		int rows = model.getRowCount();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (rows == 0) {</span>
<span class="nc" id="L341">			return;</span>
		}

<span class="nc" id="L344">		int startIndex = 0;</span>
<span class="nc" id="L345">		int endIndex = rows - 1;</span>

		// For scrollable table model, only update the rows on the current page
<span class="nc bnc" id="L348" title="All 2 branches missed.">		if (model instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L350">				throw new IllegalStateException(</span>
						&quot;UpdateBeanValue tried to update a ScrollableTableModel with no pagination.&quot;);
			}

<span class="nc" id="L354">			int rowsPerPage = getRowsPerPage();</span>
<span class="nc" id="L355">			int currentPage = getCurrentPage();</span>
			// Only update the rows on the current page
<span class="nc" id="L357">			startIndex = currentPage * rowsPerPage;</span>
<span class="nc" id="L358">			endIndex = Math.min(startIndex + rowsPerPage, rows) - 1;</span>
<span class="nc" id="L359">			LOG.warn(&quot;UpdateBeanValue only updating the current page for ScrollableTableModel&quot;);</span>
		}

<span class="nc bnc" id="L362" title="All 2 branches missed.">		if (endIndex &lt; startIndex) {</span>
<span class="nc" id="L363">			return;</span>
		}

		// Temporarily widen the pagination on the repeater to hold all rows
		// Calling setBean with a non-null value overrides the DataTableBeanProvider
<span class="nc" id="L368">		repeater.setBean(getRowIds(startIndex, endIndex, true));</span>
<span class="nc" id="L369">		updateBeanValueForRenderedRows();</span>
<span class="nc" id="L370">		repeater.setBean(null);</span>
<span class="nc" id="L371">	}</span>

	/**
	 * Updates the bean using the table data model's {@link TableModel#setValueAt(Object, List, int)} method. This
	 * method only updates the data for the currently set row ids.
	 */
	private void updateBeanValueForRenderedRows() {
<span class="nc" id="L378">		WTableRowRenderer rowRenderer = (WTableRowRenderer) repeater.getRepeatedComponent();</span>
<span class="nc" id="L379">		TableModel model = getTableModel();</span>

<span class="nc" id="L381">		int index = 0;</span>

<span class="nc" id="L383">		List&lt;RowIdWrapper&gt; wrappers = repeater.getBeanList();</span>

<span class="nc" id="L385">		int columnCount = getColumnCount();</span>

<span class="nc bnc" id="L387" title="All 2 branches missed.">		for (RowIdWrapper wrapper : wrappers) {</span>
<span class="nc" id="L388">			UIContext rowContext = repeater.getRowContext(wrapper, index++);</span>
<span class="nc" id="L389">			List&lt;Integer&gt; rowIndex = wrapper.getRowIndex();</span>

<span class="nc" id="L391">			Class&lt;? extends WComponent&gt; expandRenderer = model.getRendererClass(rowIndex);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			if (expandRenderer == null) {</span>
				// Process Columns
<span class="nc bnc" id="L394" title="All 2 branches missed.">				for (int col = 0; col &lt; columnCount; col++) {</span>
					// Check if this cell is editable
<span class="nc bnc" id="L396" title="All 2 branches missed.">					if (model.isCellEditable(rowIndex, col)) {</span>
<span class="nc" id="L397">						updateBeanValueForColumnInRow(rowRenderer, rowContext, rowIndex, col, model);</span>
					}
				}
<span class="nc bnc" id="L400" title="All 2 branches missed.">			} else if (model.isCellEditable(rowIndex, -1)) {</span>
				// Check if this expanded row is editable
<span class="nc" id="L402">				updateBeanValueForRowRenderer(rowRenderer, rowContext, expandRenderer);</span>
			}

<span class="nc" id="L405">		}</span>
<span class="nc" id="L406">	}</span>

	/**
	 * Update the column in the row.
	 *
	 * @param rowRenderer the table row renderer
	 * @param rowContext the row context
	 * @param rowIndex the row id to update
	 * @param col the column to update
	 * @param model the table model
	 */
	private void updateBeanValueForColumnInRow(final WTableRowRenderer rowRenderer,
			final UIContext rowContext,
			final List&lt;Integer&gt; rowIndex, final int col, final TableModel model) {
		// The actual component is wrapped in a renderer wrapper, so we have to fetch it from that
<span class="nc" id="L421">		WComponent renderer = ((Container) rowRenderer.getRenderer(col)).getChildAt(0);</span>

<span class="nc" id="L423">		UIContextHolder.pushContext(rowContext);</span>

		try {
			// If the column is a Container then call updateBeanValue to let the column renderer and its children update
			// the &quot;bean&quot; returned by getValueAt(row, col)
<span class="nc bnc" id="L428" title="All 2 branches missed.">			if (renderer instanceof Container) {</span>
<span class="nc" id="L429">				WebUtilities.updateBeanValue(renderer);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">			} else if (renderer instanceof DataBound) { // Update Databound renderer</span>
<span class="nc" id="L431">				Object oldValue = model.getValueAt(rowIndex, col);</span>
<span class="nc" id="L432">				Object newValue = ((DataBound) renderer).getData();</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">				if (!Util.equals(oldValue, newValue)) {</span>
<span class="nc" id="L434">					model.setValueAt(newValue, rowIndex, col);</span>
				}
			}

		} finally {
<span class="nc" id="L439">			UIContextHolder.popContext();</span>
<span class="nc" id="L440">		}</span>

<span class="nc" id="L442">	}</span>

	/**
	 * Update the expandable row renderer.
	 *
	 * @param rowRenderer the table row renderer
	 * @param rowContext the row context
	 * @param expandRenderer the renderer for the expandable row.
	 */
	private void updateBeanValueForRowRenderer(final WTableRowRenderer rowRenderer,
			final UIContext rowContext,
			final Class&lt;? extends WComponent&gt; expandRenderer) {

<span class="nc" id="L455">		Container expandWrapper = (Container) rowRenderer.</span>
<span class="nc" id="L456">				getExpandedTreeNodeRenderer(expandRenderer);</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">		if (expandWrapper == null) {</span>
<span class="nc" id="L458">			return;</span>
		}

		// The actual component is wrapped in a renderer wrapper, so we have to fetch it from that
<span class="nc" id="L462">		WComponent expandInstance = expandWrapper.getChildAt(0);</span>

<span class="nc" id="L464">		UIContextHolder.pushContext(rowContext);</span>
		try {
			// Will apply updates to the &quot;bean&quot; returned by the model for this expanded renderer (ie
			// getValueAt(rowIndex, -1))
<span class="nc" id="L468">			WebUtilities.updateBeanValue(expandInstance);</span>
		} finally {
<span class="nc" id="L470">			UIContextHolder.popContext();</span>
<span class="nc" id="L471">		}</span>

<span class="nc" id="L473">	}</span>

	/**
	 * @return the separator type used to visually separate rows or columns.
	 */
	public SeparatorType getSeparatorType() {
<span class="fc" id="L479">		return getComponentModel().separatorType;</span>
	}

	/**
	 * Sets the separator used to visually separate rows or columns.
	 *
	 * @param separatorType the separator type to set.
	 */
	public void setSeparatorType(final SeparatorType separatorType) {
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">		getOrCreateComponentModel().separatorType = separatorType == null ? SeparatorType.NONE : separatorType;</span>
<span class="fc" id="L489">	}</span>

	/**
	 * @return the striping type used to highlight alternate rows or columns
	 */
	public StripingType getStripingType() {
<span class="fc" id="L495">		return getComponentModel().stripingType;</span>
	}

	/**
	 * Sets the striping type used to highlight alternate rows or columns.
	 *
	 * @param stripingType the striping type to set.
	 */
	public void setStripingType(final StripingType stripingType) {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">		getOrCreateComponentModel().stripingType = stripingType == null ? StripingType.NONE : stripingType;</span>
<span class="fc" id="L505">	}</span>

	/**
	 * Indicates whether table column headers should be displayed.
	 *
	 * @return true if column headers should be displayed, false otherwise.
	 */
	public boolean isShowColumnHeaders() {
<span class="fc" id="L513">		return getComponentModel().showColumnHeaders;</span>
	}

	/**
	 * Sets whether table column headers should be displayed.
	 *
	 * @param showColumnHeaders true to display table column headers, false otherwise.
	 */
	public void setShowColumnHeaders(final boolean showColumnHeaders) {
<span class="fc" id="L522">		getOrCreateComponentModel().showColumnHeaders = showColumnHeaders;</span>
<span class="fc" id="L523">	}</span>

	/**
	 * @return the action to execute when row selection changes.
	 */
	public Action getSelectionChangeAction() {
<span class="fc" id="L529">		return getComponentModel().selectionChangeAction;</span>
	}

	/**
	 * Sets the action to execute when row selection changes.
	 *
	 * @param selectionChangeAction the action to execute on row selection change.
	 */
	public void setSelectionChangeAction(final Action selectionChangeAction) {
<span class="fc" id="L538">		getOrCreateComponentModel().selectionChangeAction = selectionChangeAction;</span>
<span class="fc" id="L539">	}</span>

	/**
	 * @return the message to display when the table contains no rows.
	 */
	public String getNoDataMessage() {
<span class="fc" id="L545">		return I18nUtilities.format(null, getComponentModel().noDataMessage);</span>
	}

	/**
	 * Sets the message to display when the table contains no rows.
	 *
	 * @param noDataMessage the no data message.
	 */
	public void setNoDataMessage(final String noDataMessage) {
<span class="fc" id="L554">		getOrCreateComponentModel().noDataMessage = noDataMessage;</span>
<span class="fc" id="L555">	}</span>

	/**
	 * @return the table summary text.
	 */
	public String getSummary() {
<span class="fc" id="L561">		return I18nUtilities.format(null, getComponentModel().summary);</span>
	}

	/**
	 * Sets the table summary text.
	 *
	 * @param summary the table summary text to set.
	 */
	public void setSummary(final String summary) {
<span class="fc" id="L570">		getOrCreateComponentModel().summary = summary;</span>
<span class="fc" id="L571">	}</span>

	/**
	 * @return the table caption text.
	 */
	public String getCaption() {
<span class="fc" id="L577">		return I18nUtilities.format(null, getComponentModel().caption);</span>
	}

	/**
	 * Sets the table caption text.
	 *
	 * @param caption the table caption text to set.
	 */
	public void setCaption(final String caption) {
<span class="fc" id="L586">		getOrCreateComponentModel().caption = caption;</span>
<span class="fc" id="L587">	}</span>

	/**
	 * @return the column order, or null if the default ordering is to be used.
	 */
	public int[] getColumnOrder() {
<span class="fc" id="L593">		return getComponentModel().columnOrder;</span>
	}

	/**
	 * Provide an array of column indexes in the order they should be rendered. At least one column must be specifed.
	 * &lt;p&gt;
	 * This can also be used to &quot;hide&quot; columns by not including them in the array.
	 * &lt;/p&gt;
	 *
	 * @param columnOrder the column order to set, or null to use default ordering.
	 */
	public void setColumnOrder(final int[] columnOrder) {
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">		if (columnOrder == null) {</span>
<span class="nc" id="L606">			getOrCreateComponentModel().columnOrder = null;</span>
		} else {
<span class="fc" id="L608">			int count = getColumnCount();</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">			if (columnOrder.length == 0) {</span>
<span class="fc" id="L610">				throw new IllegalArgumentException(&quot;Cannot have an empty column order indices.&quot;);</span>
			}
<span class="fc bfc" id="L612" title="All 2 branches covered.">			if (columnOrder.length &gt; count) {</span>
<span class="fc" id="L613">				throw new IllegalArgumentException(</span>
						&quot;Number of column order indices cannot be greater than the number of table columns&quot;);
			}
<span class="fc bfc" id="L616" title="All 2 branches covered.">			for (int idx : columnOrder) {</span>
<span class="pc bpc" id="L617" title="1 of 4 branches missed.">				if (idx &lt; 0 || idx &gt; count - 1) {</span>
<span class="fc" id="L618">					throw new IllegalArgumentException(</span>
							&quot;Illegal index in column order indices [&quot; + idx + &quot;]&quot;);
				}
			}
<span class="fc" id="L622">			getOrCreateComponentModel().columnOrder = Arrays.copyOf(columnOrder, columnOrder.length);</span>
		}
<span class="fc" id="L624">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setMargin(final Margin margin) {
<span class="fc" id="L631">		getOrCreateComponentModel().margin = margin;</span>
<span class="fc" id="L632">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Margin getMargin() {
<span class="fc" id="L639">		return getComponentModel().margin;</span>
	}

	/**
	 * @return the pagination mode.
	 */
	public PaginationMode getPaginationMode() {
<span class="fc" id="L646">		return getComponentModel().paginationMode;</span>
	}

	/**
	 * Sets the pagination mode.
	 *
	 * @param paginationMode the paginationMode to set.
	 */
	public void setPaginationMode(final PaginationMode paginationMode) {
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">		getOrCreateComponentModel().paginationMode = paginationMode == null ? PaginationMode.NONE : paginationMode;</span>
<span class="fc" id="L656">	}</span>

	/**
	 * The number of rows to display per page. A value of zero, which is only valid when used with
	 * {@link #setRowsPerPageOptions(java.util.List)}, indicates display all rows.
	 *
	 * @return the number of rows to display per page.
	 */
	public int getRowsPerPage() {
<span class="fc" id="L665">		return getComponentModel().rowsPerPage;</span>
	}

	/**
	 * Sets the number of rows to display per page when pagination is enabled.
	 * &lt;p&gt;
	 * If rows per page options have been set, then the value must be a valid option, which can include zero to indicate
	 * show all rows, otherwise the value must be greater than zero.
	 * &lt;/p&gt;
	 *
	 * @param rowsPerPage the rowsPerPage to set
	 */
	public void setRowsPerPage(final int rowsPerPage) {
<span class="fc" id="L678">		List&lt;Integer&gt; rowsOptions = getRowsPerPageOptions();</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">		if (rowsOptions == null) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">			if (rowsPerPage &lt; 1) {</span>
<span class="fc" id="L681">				throw new IllegalArgumentException(</span>
						&quot;Rows per page must be greater than 0, but got: &quot; + rowsPerPage);
			}
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">		} else if (!rowsOptions.contains(rowsPerPage)) {</span>
<span class="nc" id="L685">			throw new IllegalArgumentException(</span>
					&quot;Rows per page is not a valid rows per page option, got: &quot; + rowsPerPage);
		}
<span class="fc" id="L688">		getOrCreateComponentModel().rowsPerPage = rowsPerPage;</span>
<span class="fc" id="L689">	}</span>

	/**
	 * @return the rows per page options, otherwise null
	 */
	public List&lt;Integer&gt; getRowsPerPageOptions() {
<span class="fc" id="L695">		return getComponentModel().rowsPerPageOptions;</span>
	}

	/**
	 * Set the rows per page options.
	 * &lt;p&gt;
	 * If the current value of {@link #getRowsPerPage()} is not a valid option, it will be set to the first option.
	 * &lt;/p&gt;
	 *
	 * @param rowsPerPageOptions the rows per page options
	 */
	public void setRowsPerPageOptions(final List&lt;Integer&gt; rowsPerPageOptions) {
<span class="fc" id="L707">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc bfc" id="L708" title="All 4 branches covered.">		if (rowsPerPageOptions == null || rowsPerPageOptions.isEmpty()) {</span>
<span class="fc" id="L709">			model.rowsPerPageOptions = null;</span>
			// If the rows per page is currently 0, reset it to the default value
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">			if (model.rowsPerPage == 0) {</span>
<span class="fc" id="L712">				model.rowsPerPage = DEFAULT_ROWS;</span>
			}
		} else {
			// Validate options
<span class="fc bfc" id="L716" title="All 2 branches covered.">			for (Integer rows : rowsPerPageOptions) {</span>
<span class="fc bfc" id="L717" title="All 4 branches covered.">				if (rows == null || rows &lt; 0) {</span>
<span class="fc" id="L718">					throw new IllegalArgumentException(</span>
							&quot;Rows per page option cannot be less than 0 or null, got: &quot; + rows);
				}
<span class="fc" id="L721">			}</span>
<span class="fc" id="L722">			model.rowsPerPageOptions = new ArrayList&lt;&gt;(rowsPerPageOptions);</span>
			// If the current rows per page is not a valid option, default to the first option
<span class="fc bfc" id="L724" title="All 2 branches covered.">			if (!rowsPerPageOptions.contains(model.rowsPerPage)) {</span>
<span class="fc" id="L725">				model.rowsPerPage = rowsPerPageOptions.get(0);</span>
			}
		}
<span class="fc" id="L728">	}</span>

	/**
	 * @return true if table is currently displaying paginated rows
	 */
	public boolean isPaginated() {
<span class="pc bpc" id="L734" title="2 of 4 branches missed.">		return getPaginationMode() != PaginationMode.NONE &amp;&amp; getRowsPerPage() &gt; 0;</span>
	}

	/**
	 * @return the row selection mode.
	 */
	public SelectMode getSelectMode() {
<span class="fc" id="L741">		return getComponentModel().selectMode;</span>
	}

	/**
	 * Sets the row selection mode.
	 *
	 * @param selectMode the row selection mode to set.
	 */
	public void setSelectMode(final SelectMode selectMode) {
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">		getOrCreateComponentModel().selectMode = selectMode == null ? SelectMode.NONE : selectMode;</span>
<span class="fc" id="L751">	}</span>

	/**
	 * @return the sort mode.
	 */
	public SortMode getSortMode() {
<span class="fc" id="L757">		return getComponentModel().sortMode;</span>
	}

	/**
	 * Sets the table sort mode. The data model controls which columns are sortable.
	 *
	 * @param sortMode The sort mode to set.
	 */
	public void setSortMode(final SortMode sortMode) {
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">		getOrCreateComponentModel().sortMode = sortMode == null ? SortMode.NONE : sortMode;</span>
<span class="fc" id="L767">	}</span>

	/**
	 * &lt;p&gt;
	 * For tables that are editable, extra details about each row must be stored to allow them to be updated. Therefore,
	 * if the table is not editable, the table is able to have improved performance.
	 * &lt;/p&gt;
	 *
	 * @return true if table is editable
	 */
	public boolean isEditable() {
<span class="fc" id="L778">		return getComponentModel().editable;</span>
	}

	/**
	 * Sets the table to be editable.
	 * &lt;p&gt;
	 * For tables that are editable, extra details about each row must be stored to allow them to be updated. Therefore,
	 * if the table is not editable, the table is able to have improved performance.
	 * &lt;/p&gt;
	 *
	 * @param editable true if editable
	 */
	public void setEditable(final boolean editable) {
<span class="nc" id="L791">		getOrCreateComponentModel().editable = editable;</span>
<span class="nc" id="L792">	}</span>

	/**
	 * @return the table type that controls how the table is displayed.
	 */
	public Type getType() {
<span class="fc" id="L798">		return getComponentModel().type;</span>
	}

	/**
	 * Sets the table type that controls how the table is displayed.
	 *
	 * @param type the table type to set.
	 */
	public void setType(final Type type) {
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">		getOrCreateComponentModel().type = type == null ? Type.TABLE : type;</span>
<span class="fc" id="L808">	}</span>

	/**
	 * Indicates how the table row &quot;select all&quot; function should be displayed.
	 *
	 * @return the select all mode.
	 */
	public SelectAllType getSelectAllMode() {
<span class="fc" id="L816">		return getComponentModel().selectAllMode;</span>
	}

	/**
	 * Sets how the table row &quot;select all&quot; function should be displayed.
	 *
	 * @param selectAllMode the select all mode to set.
	 */
	public void setSelectAllMode(final SelectAllType selectAllMode) {
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">		getOrCreateComponentModel().selectAllMode = selectAllMode == null ? SelectAllType.TEXT : selectAllMode;</span>
<span class="fc" id="L826">	}</span>

	/**
	 * @return the row expansion mode.
	 */
	public ExpandMode getExpandMode() {
<span class="fc" id="L832">		return getComponentModel().expandMode;</span>
	}

	/**
	 * Sets the row expansion mode.
	 *
	 * @param expandMode the expand mode to set.
	 */
	public void setExpandMode(final ExpandMode expandMode) {
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">		getOrCreateComponentModel().expandMode = expandMode == null ? ExpandMode.NONE : expandMode;</span>
<span class="fc" id="L842">	}</span>

	/**
	 * Indicates whether the &quot;expand all&quot; control should be available.
	 *
	 * @return true if the expand all control should be available, false if not.
	 */
	public boolean isExpandAll() {
<span class="fc" id="L850">		return getComponentModel().expandAll;</span>
	}

	/**
	 * Sets whether the &quot;expand all&quot; control should be available.
	 *
	 * @param expandAll true if the expand-all control should be available, false if not.
	 */
	public void setExpandAll(final boolean expandAll) {
<span class="fc" id="L859">		getOrCreateComponentModel().expandAll = expandAll;</span>
<span class="fc" id="L860">	}</span>

	/**
	 * @return the current page. Zero based.
	 */
	public int getCurrentPage() {
		// Table data may have changed.
<span class="fc" id="L867">		int currentPage = getComponentModel().currentPage;</span>
<span class="fc" id="L868">		int maxPage = getComponentModel().getMaxPage();</span>

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">		if (currentPage &gt; maxPage) {</span>
<span class="nc" id="L871">			currentPage = maxPage;</span>
<span class="nc" id="L872">			setCurrentPage(maxPage);</span>
		}

<span class="fc" id="L875">		return currentPage;</span>
	}

	/**
	 * @param currentPage the currentPage to set. Zero based.
	 */
	public void setCurrentPage(final int currentPage) {
<span class="fc bfc" id="L882" title="All 2 branches covered.">		if (currentPage &lt; 0) {</span>
<span class="fc" id="L883">			throw new IllegalArgumentException(&quot;Page number must be greater than or equal to zero.&quot;);</span>
		}

<span class="fc" id="L886">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L887">		model.currentPage = Math.min(model.getMaxPage(), currentPage);</span>

		// Notify the table model that the page has changed
<span class="fc" id="L890">		TableModel dataModel = getTableModel();</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">		if (dataModel instanceof ScrollableTableModel) {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">			if (!isPaginated()) {</span>
<span class="nc" id="L893">				throw new IllegalStateException(</span>
						&quot;Table with no pagination tried to set the current page on a ScrollableTableModel.&quot;);
			}
<span class="nc" id="L896">			int startIndex = getCurrentPage() * getRowsPerPage();</span>
<span class="nc" id="L897">			int endIndex = Math.min(startIndex + getRowsPerPage(), dataModel.getRowCount()) - 1;</span>
<span class="nc" id="L898">			((ScrollableTableModel) dataModel).setCurrentRows(startIndex, endIndex);</span>
		}
<span class="fc" id="L900">	}</span>

	/**
	 * Set the row keys that are expanded.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @param rowKeys the keys of expanded rows.
	 */
	public void setExpandedRows(final Set&lt;?&gt; rowKeys) {
<span class="fc" id="L912">		getOrCreateComponentModel().expandedRows = rowKeys;</span>
<span class="fc" id="L913">	}</span>

	/**
	 * Retrieve the row keys that are expanded.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @return the expanded row keys.
	 */
	public Set&lt;?&gt; getExpandedRows() {
<span class="fc" id="L925">		Set&lt;?&gt; keys = getComponentModel().expandedRows;</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">		if (keys == null) {</span>
<span class="fc" id="L927">			return Collections.emptySet();</span>
		} else {
<span class="fc" id="L929">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Set the row keys that are selected.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @param rowKeys the keys of selected rows.
	 */
	public void setSelectedRows(final Set&lt;?&gt; rowKeys) {
<span class="fc" id="L943">		getOrCreateComponentModel().selectedRows = rowKeys;</span>
<span class="fc" id="L944">	}</span>

	/**
	 * Retrieve the row keys that are selected.
	 * &lt;p&gt;
	 * A row key uniquely identifies each row and is determined by the {@link TableModel}. Refer to
	 * {@link TableModel#getRowKey(List)}.
	 * &lt;/p&gt;
	 *
	 * @return the selected row keys.
	 */
	public Set&lt;?&gt; getSelectedRows() {
<span class="fc" id="L956">		Set&lt;?&gt; keys = getComponentModel().selectedRows;</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">		if (keys == null) {</span>
<span class="fc" id="L958">			return Collections.emptySet();</span>
		} else {
<span class="fc" id="L960">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Return the row keys that have been expanded.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @return the previously expanded row keys.
	 */
	protected Set&lt;?&gt; getPrevExpandedRows() {
<span class="nc" id="L973">		Set&lt;?&gt; keys = getComponentModel().prevExpandedRows;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">		if (keys == null) {</span>
<span class="nc" id="L975">			return Collections.emptySet();</span>
		} else {
<span class="nc" id="L977">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Track the row keys that have been expanded.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @param rowKey the row key that has been expanded.
	 */
	protected void addPrevExpandedRow(final Object rowKey) {
<span class="nc" id="L990">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">		if (model.prevExpandedRows == null) {</span>
<span class="nc" id="L992">			model.prevExpandedRows = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L994">		model.prevExpandedRows.add(rowKey);</span>
<span class="nc" id="L995">	}</span>

	/**
	 * Clear the previously expanded row keys.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 */
	protected void clearPrevExpandedRows() {
<span class="fc" id="L1004">		getOrCreateComponentModel().prevExpandedRows = null;</span>
<span class="fc" id="L1005">	}</span>

	/**
	 * Return the row keys that have been rendered.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @return the previously rendered row keys.
	 */
	protected Set&lt;?&gt; getPrevRenderedRows() {
<span class="nc" id="L1016">		Set&lt;?&gt; keys = getComponentModel().prevRenderedRows;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">		if (keys == null) {</span>
<span class="nc" id="L1018">			return Collections.emptySet();</span>
		} else {
<span class="nc" id="L1020">			return Collections.unmodifiableSet(keys);</span>
		}
	}

	/**
	 * Track the row keys that have been rendered.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 *
	 * @param rowKey the row key that has been rendered.
	 */
	protected void addPrevRenderedRow(final Object rowKey) {
<span class="nc" id="L1033">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">		if (model.prevRenderedRows == null) {</span>
<span class="nc" id="L1035">			model.prevRenderedRows = new HashSet&lt;&gt;();</span>
		}
<span class="nc" id="L1037">		model.prevRenderedRows.add(rowKey);</span>
<span class="nc" id="L1038">	}</span>

	/**
	 * Clear the previously rendered row keys.
	 * &lt;p&gt;
	 * Note - Only used for when the table is editable.
	 * &lt;/p&gt;
	 */
	protected void clearPrevRenderedRows() {
<span class="fc" id="L1047">		getOrCreateComponentModel().prevRenderedRows = null;</span>
<span class="fc" id="L1048">	}</span>

	/**
	 * For rendering purposes only - has no effect on model.
	 *
	 * @param index the sort column index, or -1 for no sort.
	 * @param ascending true for ascending order, false for descending
	 */
	protected void setSort(final int index, final boolean ascending) {
<span class="fc" id="L1057">		WTableComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1058">		model.sortColIndex = index;</span>
<span class="fc" id="L1059">		model.sortAscending = ascending;</span>
<span class="fc" id="L1060">	}</span>

	/**
	 * @return true if the table is currently sorted
	 */
	public boolean isSorted() {
<span class="fc bfc" id="L1066" title="All 2 branches covered.">		return getComponentModel().sortColIndex &gt;= 0;</span>
	}

	/**
	 * @return the index of the column the table is sorted by.
	 */
	public int getSortColumnIndex() {
<span class="fc" id="L1073">		return getComponentModel().sortColIndex;</span>
	}

	/**
	 * Indicates whether the sort on this table is ascending. Note that a return value of false does not necessarily
	 * indicate a descending sort - see {@link #isSorted()}.
	 *
	 * @return true if the sort order is ascending, false for descending.
	 */
	public boolean isSortAscending() {
<span class="fc" id="L1083">		return getComponentModel().sortAscending;</span>
	}

	/**
	 * Indicates whether the table supports sorting.
	 *
	 * @return true if the table and model both support sorting, false otherwise.
	 */
	public boolean isSortable() {
		// First check global override which turns sorting off
<span class="fc bfc" id="L1093" title="All 2 branches covered.">		if (getSortMode() == SortMode.NONE) {</span>
<span class="fc" id="L1094">			return false;</span>
		}

		// Otherwise, the table is sortable if at least one column is sortable.
<span class="fc" id="L1098">		TableModel dataModel = getTableModel();</span>
<span class="fc" id="L1099">		final int columnCount = getColumnCount();</span>

<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">		for (int i = 0; i &lt; columnCount; i++) {</span>
<span class="pc bpc" id="L1102" title="1 of 2 branches missed.">			if (dataModel.isSortable(i)) {</span>
<span class="fc" id="L1103">				return true;</span>
			}
		}

<span class="nc" id="L1107">		return false;</span>
	}

	/**
	 * Retrieves the actions for the table.
	 *
	 * @return the list of table actions
	 */
	public List&lt;WButton&gt; getActions() {
<span class="fc" id="L1116">		final int numActions = actions.getChildCount();</span>
<span class="fc" id="L1117">		List&lt;WButton&gt; buttons = new ArrayList&lt;&gt;(numActions);</span>

<span class="fc bfc" id="L1119" title="All 2 branches covered.">		for (int i = 0; i &lt; numActions; i++) {</span>
<span class="fc" id="L1120">			WButton button = (WButton) actions.getChildAt(i);</span>
<span class="fc" id="L1121">			buttons.add(button);</span>
		}

<span class="fc" id="L1124">		return Collections.unmodifiableList(buttons);</span>
	}

	/**
	 * Adds a component to the set of table actions.
	 *
	 * @param button the button to add.
	 */
	public void addAction(final WButton button) {
<span class="fc" id="L1133">		actions.add(button);</span>
<span class="fc" id="L1134">	}</span>

	/**
	 * Adds a constraint to when the given action can be used.
	 *
	 * @param button the button which the constraint applies to.
	 * @param constraint the constraint to add.
	 */
	public void addActionConstraint(final WButton button, final ActionConstraint constraint) {
<span class="fc bfc" id="L1143" title="All 2 branches covered.">		if (button.getParent() != actions) {</span>
<span class="fc" id="L1144">			throw new IllegalArgumentException(</span>
					&quot;Can only add a constraint to a button which is in this table's actions&quot;);
		}

<span class="fc" id="L1148">		getOrCreateComponentModel().addActionConstraint(button, constraint);</span>
<span class="fc" id="L1149">	}</span>

	/**
	 * Retrieves the constraints for the given action.
	 *
	 * @param button the button to retrieve the constraints for.
	 * @return the constraints for the given action, or null if there are no constraints.
	 */
	public List&lt;ActionConstraint&gt; getActionConstraints(final WButton button) {
<span class="fc" id="L1158">		List&lt;ActionConstraint&gt; constraints = getComponentModel().actionConstraints.get(button);</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">		return constraints == null ? null : Collections.unmodifiableList(constraints);</span>
	}

	/**
	 * Override handleRequest to add table-specific functionality such as pagination and row selection.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	public void handleRequest(final Request request) {
<span class="fc" id="L1169">		super.handleRequest(request);</span>

<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">		if (isPresent(request)) {</span>
<span class="fc bfc" id="L1172" title="All 2 branches covered.">			if (getExpandMode() != ExpandMode.NONE) {</span>
<span class="fc" id="L1173">				handleExpansionRequest(request);</span>
			}

<span class="fc bfc" id="L1176" title="All 2 branches covered.">			if (getSelectMode() != SelectMode.NONE) {</span>
<span class="fc" id="L1177">				handleSelectionRequest(request);</span>
			}

<span class="fc bfc" id="L1180" title="All 2 branches covered.">			if (getPaginationMode() != PaginationMode.NONE) {</span>
<span class="fc" id="L1181">				handlePaginationRequest(request);</span>
			}

<span class="fc bfc" id="L1184" title="All 2 branches covered.">			if (isSortable()) {</span>
<span class="fc" id="L1185">				handleSortRequest(request);</span>
			}
		}
<span class="fc" id="L1188">	}</span>

	/**
	 * Indicates whether this table was present in the request.
	 *
	 * @param request the request being responded to.
	 * @return true if this table was present in the request, false if not.
	 */
	protected boolean isPresent(final Request request) {
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">		return request.getParameter(getId() + &quot;-h&quot;) != null;</span>
	}

	/**
	 * Handles a request containing sort instruction data.
	 *
	 * @param request the request containing sort instruction data.
	 */
	private void handleSortRequest(final Request request) {
<span class="fc" id="L1206">		String sortColStr = request.getParameter(getId() + &quot;.sort&quot;);</span>
<span class="fc" id="L1207">		String sortDescStr = request.getParameter(getId() + &quot;.sortDesc&quot;);</span>

<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">		if (sortColStr != null) {</span>
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">			if (&quot;&quot;.equals(sortColStr)) {</span>
				// Reset sort
<span class="nc" id="L1212">				setSort(-1, false);</span>
<span class="nc" id="L1213">				getOrCreateComponentModel().rowIndexMapping = null;</span>
			} else {
				try {
<span class="fc" id="L1216">					int sortCol = Integer.parseInt(sortColStr);</span>
					// Allow for column order
<span class="fc" id="L1218">					int[] cols = getColumnOrder();</span>
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">					if (cols != null) {</span>
<span class="nc" id="L1220">						sortCol = cols[sortCol];</span>
					}
<span class="fc bfc" id="L1222" title="All 2 branches covered.">					boolean sortAsc = !&quot;true&quot;.equalsIgnoreCase(sortDescStr);</span>

					// Only process the sort request if it differs from the current sort order
<span class="pc bpc" id="L1225" title="3 of 4 branches missed.">					if (sortCol != getSortColumnIndex() || sortAsc != isSortAscending()) {</span>
<span class="fc" id="L1226">						sort(sortCol, sortAsc);</span>
<span class="fc" id="L1227">						setFocussed();</span>
					}
<span class="nc" id="L1229">				} catch (NumberFormatException e) {</span>
<span class="nc" id="L1230">					LOG.warn(&quot;Invalid sort column: &quot; + sortColStr);</span>
<span class="fc" id="L1231">				}</span>
			}
		}
<span class="fc" id="L1234">	}</span>

	/**
	 * Sort the table data by the specified column.
	 *
	 * @param sortCol the column to sort
	 * @param sortAsc true if sort ascending, otherwise sort descending
	 */
	public void sort(final int sortCol, final boolean sortAsc) {
<span class="fc" id="L1243">		int[] rowIndexMappings = getTableModel().sort(sortCol, sortAsc);</span>
<span class="fc" id="L1244">		getOrCreateComponentModel().rowIndexMapping = rowIndexMappings;</span>

<span class="fc" id="L1246">		setSort(sortCol, sortAsc);</span>

<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">		if (rowIndexMappings == null) {</span>
			// There's no way to correlate the previously selected row indices
			// with the new order of rows, so we need to clear out the selection.
<span class="nc" id="L1251">			setSelectedRows(null);</span>
<span class="nc" id="L1252">			setExpandedRows(null);</span>
		}
<span class="fc" id="L1254">	}</span>

	/**
	 * Handles a request containing row selection data.
	 *
	 * @param request the request containing row selection data.
	 */
	private void handleSelectionRequest(final Request request) {
<span class="fc" id="L1262">		String[] paramValue = request.getParameterValues(getId() + &quot;.selected&quot;);</span>

<span class="fc bfc" id="L1264" title="All 2 branches covered.">		if (paramValue == null) {</span>
<span class="fc" id="L1265">			paramValue = new String[0];</span>
		}

<span class="fc" id="L1268">		Map&lt;List&lt;Integer&gt;, Object&gt; pageRowKeys = getCurrentRowIndexAndKeys();</span>

<span class="fc" id="L1270">		String[] selectedRows = removeEmptyStrings(paramValue);</span>
<span class="fc" id="L1271">		Set&lt;?&gt; oldSelections = getSelectedRows();</span>
		Set&lt;Object&gt; newSelections;

<span class="fc bfc" id="L1274" title="All 2 branches covered.">		boolean singleSelect = getSelectMode() == SelectMode.SINGLE;</span>

<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">		if (getTableModel().getRowCount() == 0) {</span>
<span class="nc" id="L1277">			newSelections = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1278">			selectedRows = new String[0];</span>
<span class="pc bpc" id="L1279" title="5 of 6 branches missed.">		} else if (getPaginationMode() == PaginationMode.NONE || getPaginationMode() == PaginationMode.CLIENT</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">				|| oldSelections == null || !isPaginated()) {</span>
<span class="fc" id="L1281">			newSelections = new HashSet&lt;&gt;(selectedRows.length);</span>
<span class="nc bnc" id="L1282" title="All 4 branches missed.">		} else if (singleSelect &amp;&amp; selectedRows.length &gt; 0) {</span>
			// For single-select, we need to remove the old entries
<span class="nc" id="L1284">			newSelections = new HashSet&lt;&gt;(1);</span>
		} else {
			// For multi-select, we need the entries for the current page only
<span class="nc" id="L1287">			newSelections = new HashSet&lt;&gt;(oldSelections);</span>
<span class="nc" id="L1288">			newSelections.removeAll(pageRowKeys.values());</span>
		}

<span class="fc bfc" id="L1291" title="All 2 branches covered.">		for (String selectedRow : selectedRows) {</span>
<span class="fc" id="L1292">			List&lt;Integer&gt; rowIndex = TableUtil.rowIndexStringToList(selectedRow);</span>
<span class="fc" id="L1293">			Object key = pageRowKeys.get(rowIndex);</span>
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">			if (key == null) {</span>
<span class="nc" id="L1295">				continue;</span>
			}
<span class="fc" id="L1297">			newSelections.add(key);</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">			if (singleSelect) {</span>
<span class="fc" id="L1299">				break;</span>
			}
		}

<span class="fc" id="L1303">		setSelectedRows(newSelections);</span>

		// If there is a selection change action specified, it may need to be fired
<span class="fc" id="L1306">		Action selectionChangeAction = getSelectionChangeAction();</span>

<span class="pc bpc" id="L1308" title="3 of 4 branches missed.">		if (selectionChangeAction != null &amp;&amp; !newSelections.equals(oldSelections)) {</span>
<span class="nc" id="L1309">			selectionChangeAction.execute(new ActionEvent(this, SELECTION_ACTION_COMMAND));</span>
		}
<span class="fc" id="L1311">	}</span>

	/**
	 * Handles a request containing row expansion data.
	 *
	 * @param request the request containing row expansion data.
	 */
	private void handleExpansionRequest(final Request request) {
<span class="fc" id="L1319">		String[] paramValue = request.getParameterValues(getId() + &quot;.expanded&quot;);</span>

<span class="fc bfc" id="L1321" title="All 2 branches covered.">		if (paramValue == null) {</span>
<span class="fc" id="L1322">			paramValue = new String[0];</span>
		}

<span class="fc" id="L1325">		Map&lt;List&lt;Integer&gt;, Object&gt; pageRowKeys = getCurrentRowIndexAndKeys();</span>

<span class="fc" id="L1327">		String[] expandedRows = removeEmptyStrings(paramValue);</span>
<span class="fc" id="L1328">		Set&lt;?&gt; oldExpansions = getExpandedRows();</span>
		Set&lt;Object&gt; newExpansions;

<span class="fc" id="L1331">		TableModel model = getTableModel();</span>

<span class="pc bpc" id="L1333" title="1 of 2 branches missed.">		if (model.getRowCount() == 0) {</span>
<span class="nc" id="L1334">			newExpansions = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1335">			expandedRows = new String[0];</span>
<span class="pc bpc" id="L1336" title="5 of 6 branches missed.">		} else if (getPaginationMode() == PaginationMode.NONE || getPaginationMode() == PaginationMode.CLIENT</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">				|| oldExpansions == null || !isPaginated()) {</span>
<span class="fc" id="L1338">			newExpansions = new HashSet&lt;&gt;(expandedRows.length);</span>
		} else {
			// row expansions only apply to the current page
<span class="nc" id="L1341">			newExpansions = new HashSet&lt;&gt;(oldExpansions);</span>
<span class="nc" id="L1342">			newExpansions.removeAll(pageRowKeys.values());</span>
		}

<span class="fc bfc" id="L1345" title="All 2 branches covered.">		for (String expandedRow : expandedRows) {</span>
<span class="fc" id="L1346">			List&lt;Integer&gt; rowIndex = TableUtil.rowIndexStringToList(expandedRow);</span>
<span class="fc" id="L1347">			Object key = pageRowKeys.get(rowIndex);</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">			if (key != null) {</span>
<span class="fc" id="L1349">				newExpansions.add(key);</span>
			}
		}

<span class="fc" id="L1353">		setExpandedRows(newExpansions);</span>
<span class="fc" id="L1354">	}</span>

	/**
	 * Handles a request containing pagination data.
	 *
	 * @param request the request containing a pagination data.
	 */
	private void handlePaginationRequest(final Request request) {
<span class="fc" id="L1362">		String rowsStr = request.getParameter(getId() + &quot;.rows&quot;);</span>

<span class="fc" id="L1364">		int prevPage = getCurrentPage();</span>
<span class="fc" id="L1365">		int prevRows = getRowsPerPage();</span>

<span class="fc" id="L1367">		boolean rowsChanged = false;</span>

		// Check for rows per page option and is valid
<span class="pc bpc" id="L1370" title="1 of 4 branches missed.">		if (rowsStr != null &amp;&amp; getRowsPerPageOptions() != null) {</span>
			try {
<span class="fc" id="L1372">				int newRows = Integer.parseInt(rowsStr);</span>
				// If rows option changed
<span class="fc bfc" id="L1374" title="All 2 branches covered.">				if (prevRows != newRows) {</span>
					// Set rows
<span class="fc" id="L1376">					setRowsPerPage(newRows);</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">					if (newRows == 0) {</span>
<span class="fc" id="L1378">						setCurrentPage(0);</span>
					} else {
						// Try to calc the page the previous top row was on
<span class="fc" id="L1381">						int startIdx = prevPage * prevRows;</span>
<span class="fc" id="L1382">						int page = startIdx / newRows;</span>
<span class="fc" id="L1383">						setCurrentPage(page);</span>
					}
<span class="fc" id="L1385">					rowsChanged = true;</span>
				}
<span class="nc" id="L1387">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L1388">				LOG.warn(&quot;Invalid rows option: &quot; + rowsStr);</span>
<span class="fc" id="L1389">			}</span>
		}

		// Check for the current page
<span class="pc bpc" id="L1393" title="1 of 4 branches missed.">		if (!rowsChanged &amp;&amp; isPaginated()) {</span>
<span class="fc" id="L1394">			String pageStr = request.getParameter(getId() + &quot;.page&quot;);</span>
<span class="pc bpc" id="L1395" title="1 of 2 branches missed.">			if (pageStr == null) {</span>
<span class="nc" id="L1396">				setCurrentPage(0);</span>
			} else {
				try {
<span class="fc" id="L1399">					int pageNum = Integer.parseInt(pageStr);</span>
<span class="fc" id="L1400">					setCurrentPage(pageNum);</span>
<span class="nc" id="L1401">				} catch (NumberFormatException e) {</span>
<span class="nc" id="L1402">					LOG.warn(&quot;Invalid page number: &quot; + pageStr);</span>
<span class="fc" id="L1403">				}</span>
			}
		}

<span class="fc" id="L1407">	}</span>

	/**
	 * Helper that removes empty/null string from the &lt;code&gt;original&lt;/code&gt; string array.
	 *
	 * @param originals The string array from which the null/empty strings should be removed from.
	 * @return Array of non empty strings from the &lt;code&gt;original&lt;/code&gt; string array.
	 */
	private String[] removeEmptyStrings(final String[] originals) {
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">		if (originals == null) {</span>
<span class="nc" id="L1417">			return null;</span>
		} else {
<span class="fc" id="L1419">			List&lt;String&gt; parsed = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L1421" title="All 2 branches covered.">			for (String original : originals) {</span>
<span class="pc bpc" id="L1422" title="2 of 4 branches missed.">				if (original != null &amp;&amp; original.length() &gt; 0) {</span>
<span class="fc" id="L1423">					parsed.add(original);</span>
				}
			}

<span class="fc" id="L1427">			return parsed.toArray(new String[parsed.size()]);</span>
		}
	}

	/**
	 * Override preparePaint to register an AJAX operation if necessary.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	protected void preparePaintComponent(final Request request) {
<span class="fc" id="L1438">		super.preparePaintComponent(request);</span>

<span class="fc bfc" id="L1440" title="All 4 branches covered.">		if (getRowsPerPageOptions() != null || PaginationMode.DYNAMIC.equals(getPaginationMode()) || SortMode.DYNAMIC.</span>
<span class="fc bfc" id="L1441" title="All 2 branches covered.">				equals(getSortMode())</span>
<span class="fc bfc" id="L1442" title="All 4 branches covered.">				|| ExpandMode.DYNAMIC.equals(getExpandMode()) || ExpandMode.LAZY.equals(</span>
<span class="fc" id="L1443">				getExpandMode())) {</span>
<span class="fc" id="L1444">			AjaxHelper.registerComponentTargetItself(getId(), request);</span>
		}
<span class="fc" id="L1446">	}</span>

	/**
	 * Method to call when the model data has changed. For example, when a row has been added or removed.
	 * &lt;p&gt;
	 * Handles resorting the data (if table sorted) and making sure the table pagination is still correct.
	 * &lt;/p&gt;
	 */
	public void handleDataChanged() {
		// Apply sort (if required)
<span class="nc bnc" id="L1456" title="All 2 branches missed.">		if (isSorted()) {</span>
<span class="nc" id="L1457">			sort(getSortColumnIndex(), isSortAscending());</span>
		}
<span class="nc" id="L1459">		setCurrentPage(getCurrentPage());</span>
<span class="nc" id="L1460">	}</span>

	/**
	 * Allows a subclass to provide the ID used in the row naming context. It is important this ID is unique for each
	 * row.
	 * &lt;p&gt;
	 * The returned ID must only contain letters, digits or underscores.
	 * &lt;/p&gt;
	 *
	 * @param rowIndex the current row index
	 * @param rowKey the current row key.
	 * @return the unique row id or null to use the default context id
	 */
	protected String getRowIdName(final List&lt;Integer&gt; rowIndex, final Object rowKey) {
<span class="fc" id="L1474">		return null;</span>
	}

	/**
	 * Describes a constraint on a table action.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public static final class ActionConstraint implements Serializable {

		/**
		 * The minimum number of rows which must be selected to fulfil the constraint.
		 */
		private int minSelectedRowCount;

		/**
		 * The maximum number of rows which must be selected to fulfil the constraint.
		 */
		private int maxSelectedRowCount;

		/**
		 * True if the constraint is an error, false for a warning.
		 */
		private boolean error;

		/**
		 * The message to display when the constraint is not met.
		 */
		private String message;

		/**
		 * Creates an action constraint.
		 *
		 * @param minSelectedRowCount the minimum number of rows which must be selected to fulfil the constraint, or
		 * zero for any number of rows.
		 * @param maxSelectedRowCount the maximum number of rows which can be selected to fulfil the constraint, or zero
		 * for any number of rows.
		 * @param error true if the constraint is an error, false for a warning.
		 * @param message the message to display when the constraint is not met.
		 */
		public ActionConstraint(final int minSelectedRowCount, final int maxSelectedRowCount,
				final boolean error,
<span class="fc" id="L1517">				final String message) {</span>
<span class="fc" id="L1518">			this.minSelectedRowCount = minSelectedRowCount;</span>
<span class="fc" id="L1519">			this.maxSelectedRowCount = maxSelectedRowCount;</span>
<span class="fc" id="L1520">			this.error = error;</span>
<span class="fc" id="L1521">			this.message = message;</span>
<span class="fc" id="L1522">		}</span>

		/**
		 * Indicates the minimum number of rows which must be selected for the error/warning not to occur.
		 *
		 * @return the minimum selected row count.
		 */
		public int getMinSelectedRowCount() {
<span class="fc" id="L1530">			return minSelectedRowCount;</span>
		}

		/**
		 * @param minSelectedRowCount the minimum selected row count to set.
		 */
		public void setMinSelectedRowCount(final int minSelectedRowCount) {
<span class="fc" id="L1537">			this.minSelectedRowCount = minSelectedRowCount;</span>
<span class="fc" id="L1538">		}</span>

		/**
		 * Indicates the maximum number of rows which can be selected for the error/warning not to occur.
		 *
		 * @return the maximum selected row count.
		 */
		public int getMaxSelectedRowCount() {
<span class="fc" id="L1546">			return maxSelectedRowCount;</span>
		}

		/**
		 * @param maxSelectedRowCount the maximum selected row count to set.
		 */
		public void setMaxSelectedRowCount(final int maxSelectedRowCount) {
<span class="fc" id="L1553">			this.maxSelectedRowCount = maxSelectedRowCount;</span>
<span class="fc" id="L1554">		}</span>

		/**
		 * Indicates whether the constraint is an error or warning.
		 *
		 * @return true if the constraint is an error, false for a warning.
		 */
		public boolean isError() {
<span class="fc" id="L1562">			return error;</span>
		}

		/**
		 * Sets whether the constraint is an error or warning.
		 *
		 * @param error true if the constraint is an error, false for a warning.
		 */
		public void setError(final boolean error) {
<span class="fc" id="L1571">			this.error = error;</span>
<span class="fc" id="L1572">		}</span>

		/**
		 * @return the message.
		 */
		public String getMessage() {
<span class="fc" id="L1578">			return message;</span>
		}

		/**
		 * @param message the message to set.
		 */
		public void setMessage(final String message) {
<span class="fc" id="L1585">			this.message = message;</span>
<span class="fc" id="L1586">		}</span>
	}

	/**
	 * A bean provider implementation which uses the bean bound to the table.
	 */
	private static final class BeanBoundTableModelBeanProvider implements BeanProvider, Serializable {

		private final WTable table;

		/**
		 * @param table the parent table
		 */
<span class="fc" id="L1599">		private BeanBoundTableModelBeanProvider(final WTable table) {</span>
<span class="fc" id="L1600">			this.table = table;</span>
<span class="fc" id="L1601">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Object getBean(final BeanProviderBound beanProviderBound) {
<span class="fc" id="L1608">			return table.getBeanValue();</span>
		}
	}

	/**
	 * A bean provider implementation which provides beans to the table repeater. This provider takes the table's
	 * pagination state into account, so that only visible rows are rendered.
	 */
	private static final class RepeaterRowIdBeanProvider implements BeanProvider, Serializable {

		private final WTable table;

		/**
		 * @param table the parent table
		 */
<span class="fc" id="L1623">		private RepeaterRowIdBeanProvider(final WTable table) {</span>
<span class="fc" id="L1624">			this.table = table;</span>
<span class="fc" id="L1625">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public Object getBean(final BeanProviderBound beanProviderBound) {
<span class="fc" id="L1632">			TableModel dataModel = table.getTableModel();</span>
<span class="fc" id="L1633">			int rowCount = dataModel.getRowCount();</span>

<span class="fc bfc" id="L1635" title="All 2 branches covered.">			if (rowCount == 0) {</span>
<span class="fc" id="L1636">				return Collections.emptyList();</span>
			}

<span class="fc" id="L1639">			int startIndex = 0;</span>
<span class="fc" id="L1640">			int endIndex = rowCount - 1;</span>

<span class="pc bpc" id="L1642" title="1 of 4 branches missed.">			if (PaginationMode.DYNAMIC == table.getPaginationMode() &amp;&amp; table.isPaginated()) {</span>
<span class="fc" id="L1643">				int rowsPerPage = table.getRowsPerPage();</span>
<span class="fc" id="L1644">				int currentPage = table.getCurrentPage();</span>
				// Only render the rows on the current page
				// If total row count has changed, calc the new last page
<span class="fc" id="L1647">				startIndex = Math.</span>
<span class="fc" id="L1648">						min(currentPage * rowsPerPage, rowCount - (rowCount % rowsPerPage));</span>
<span class="fc" id="L1649">				endIndex = Math.min(startIndex + rowsPerPage, rowCount) - 1;</span>
			}

<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">			if (endIndex &lt; startIndex) {</span>
				// No data
<span class="nc" id="L1654">				return Collections.EMPTY_LIST;</span>
			}

<span class="fc" id="L1657">			return table.getRowIds(startIndex, endIndex, false);</span>
		}
	}

	/**
	 * Determine the row ids for the provided index range.
	 *
	 * @param startIndex the startIndex
	 * @param endIndex the endIndex
	 * @param forUpdate true if building list of rowids for rows that need updating
	 * @return the list of rowIds for the provided index range
	 */
	private List&lt;RowIdWrapper&gt; getRowIds(final int startIndex, final int endIndex,
			final boolean forUpdate) {
<span class="fc" id="L1671">		TableModel model = getTableModel();</span>

		// If the table is sorted, we may require a mapping for table row index &lt;--&gt; data model index.
<span class="fc" id="L1674">		int[] rowIndexMapping = getComponentModel().rowIndexMapping;</span>

		// Check if sort mapping needs updating
<span class="pc bpc" id="L1677" title="2 of 6 branches missed.">		if (isSorted() &amp;&amp; rowIndexMapping != null &amp;&amp; rowIndexMapping.length != model.getRowCount()) {</span>
<span class="nc" id="L1678">			rowIndexMapping = model.sort(getSortColumnIndex(), isSortAscending());</span>
<span class="nc" id="L1679">			getOrCreateComponentModel().rowIndexMapping = rowIndexMapping;</span>
		}

<span class="fc" id="L1682">		List&lt;RowIdWrapper&gt; rowIds = new ArrayList&lt;&gt;(endIndex - startIndex + 1);</span>

<span class="fc" id="L1684">		ExpandMode mode = getExpandMode();</span>
<span class="fc bfc" id="L1685" title="All 2 branches covered.">		boolean expandable = mode != ExpandMode.NONE;</span>

		// Expanded rows - for update, include rows that have been previously expanded
<span class="fc" id="L1688">		Set&lt;?&gt; expanded = null;</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">		if (expandable) {</span>
<span class="pc bpc" id="L1690" title="1 of 2 branches missed.">			expanded = forUpdate ? getPrevExpandedRows() : getExpandedRows();</span>
		}

		// Rendered rows - for update, only process rows that have been rendered
<span class="fc" id="L1694">		Set&lt;?&gt; rendered = null;</span>
<span class="fc" id="L1695">		int renderedCount = 0;</span>
<span class="pc bpc" id="L1696" title="1 of 2 branches missed.">		if (forUpdate) {</span>
<span class="nc" id="L1697">			rendered = getPrevRenderedRows();</span>
			// Check if no rows previously rendered
<span class="nc bnc" id="L1699" title="All 2 branches missed.">			if (rendered.isEmpty()) {</span>
<span class="nc" id="L1700">				return Collections.EMPTY_LIST;</span>
			}
		}

<span class="fc" id="L1704">		boolean editable = isEditable();</span>

<span class="fc bfc" id="L1706" title="All 2 branches covered.">		for (int i = startIndex; i &lt;= endIndex; i++) {</span>
			// Create top level
<span class="fc" id="L1708">			List&lt;Integer&gt; rowIndex = new ArrayList&lt;&gt;(1);</span>

			// Map ids (if sorted)
<span class="fc bfc" id="L1711" title="All 2 branches covered.">			if (rowIndexMapping == null) {</span>
<span class="fc" id="L1712">				rowIndex.add(i);</span>
			} else {
<span class="fc" id="L1714">				rowIndex.add(rowIndexMapping[i]);</span>
			}

			// Row key
<span class="fc" id="L1718">			Object key = model.getRowKey(rowIndex);</span>

			// For update, only process rows that have been rendered
<span class="pc bpc" id="L1721" title="3 of 4 branches missed.">			if (forUpdate &amp;&amp; !rendered.contains(key)) {</span>
<span class="nc" id="L1722">				continue;</span>
			}

			// Create wrapper
<span class="fc" id="L1726">			RowIdWrapper wrapper = new RowIdWrapper(rowIndex, key, null);</span>

<span class="fc bfc" id="L1728" title="All 2 branches covered.">			if (expandable) {</span>
<span class="fc" id="L1729">				calcChildrenRowIds(rowIds, wrapper, model, null, expanded, mode, forUpdate, editable);</span>
			} else {
<span class="fc" id="L1731">				rowIds.add(wrapper);</span>
			}

			// For update, check if all rendered rows have been processed
<span class="pc bpc" id="L1735" title="1 of 2 branches missed.">			if (forUpdate) {</span>
<span class="nc" id="L1736">				renderedCount++;</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">				if (renderedCount == rendered.size()) {</span>
					// No need to keep processing
<span class="nc" id="L1739">					break;</span>
				}
			}

			// For render, keep rows that have been rendered for update logic (only if table editable)
<span class="pc bpc" id="L1744" title="3 of 4 branches missed.">			if (editable &amp;&amp; !forUpdate) {</span>
<span class="nc" id="L1745">				addPrevRenderedRow(key);</span>
			}
		}

		// Set the position of each row in the list of row ids.
<span class="fc" id="L1750">		int i = 0;</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">		for (RowIdWrapper row : rowIds) {</span>
<span class="fc" id="L1752">			row.setPosition(i++);</span>
<span class="fc" id="L1753">		}</span>

<span class="fc" id="L1755">		return rowIds;</span>
	}

	/**
	 * Calculate the row ids of a row's children.
	 *
	 * @param rows the list of row ids
	 * @param row the current row
	 * @param model the table model
	 * @param parent the row's parent
	 * @param expanded the set of expanded rows
	 * @param mode the table expand mode
	 * @param forUpdate true if building list of row ids to update
	 * @param editable true if the table is editable
	 */
	@SuppressWarnings(&quot;checkstyle:parameternumber&quot;)
	private void calcChildrenRowIds(final List&lt;RowIdWrapper&gt; rows, final RowIdWrapper row,
			final TableModel model,
			final RowIdWrapper parent, final Set&lt;?&gt; expanded, final ExpandMode mode,
			final boolean forUpdate, final boolean editable) {
		// Add row
<span class="fc" id="L1776">		rows.add(row);</span>

		// Add to parent
<span class="fc bfc" id="L1779" title="All 2 branches covered.">		if (parent != null) {</span>
<span class="fc" id="L1780">			parent.addChild(row);</span>
		}

<span class="fc" id="L1783">		List&lt;Integer&gt; rowIndex = row.getRowIndex();</span>

		// If row has a renderer, then dont need to process its children (should not have any anyway as it is a &quot;leaf&quot;)
<span class="fc bfc" id="L1786" title="All 2 branches covered.">		if (model.getRendererClass(rowIndex) != null) {</span>
<span class="fc" id="L1787">			return;</span>
		}

		// Check row is expandable
<span class="fc bfc" id="L1791" title="All 2 branches covered.">		if (!model.isExpandable(rowIndex)) {</span>
<span class="fc" id="L1792">			return;</span>
		}

		// Check has children
<span class="fc bfc" id="L1796" title="All 2 branches covered.">		if (!model.hasChildren(rowIndex)) {</span>
<span class="fc" id="L1797">			return;</span>
		}
<span class="fc" id="L1799">		row.setHasChildren(true);</span>

		// Always add children if CLIENT mode or row is expanded
<span class="pc bpc" id="L1802" title="5 of 6 branches missed.">		boolean addChildren = (mode == ExpandMode.CLIENT) || (expanded != null &amp;&amp; expanded.contains(</span>
<span class="nc" id="L1803">				row.getRowKey()));</span>
<span class="pc bpc" id="L1804" title="1 of 2 branches missed.">		if (!addChildren) {</span>
<span class="nc" id="L1805">			return;</span>
		}

		// Get actual child count
<span class="fc" id="L1809">		int children = model.getChildCount(rowIndex);</span>
<span class="pc bpc" id="L1810" title="1 of 2 branches missed.">		if (children == 0) {</span>
			// Could be there are no children even though hasChildren returned true
<span class="nc" id="L1812">			row.setHasChildren(false);</span>
<span class="nc" id="L1813">			return;</span>
		}

		// Render mode, Keep rows that have been expanded (only if table editable)
<span class="pc bpc" id="L1817" title="2 of 4 branches missed.">		if (!forUpdate &amp;&amp; editable) {</span>
<span class="nc" id="L1818">			addPrevExpandedRow(row.getRowKey());</span>
		}

		// Add children by processing each child row
<span class="fc bfc" id="L1822" title="All 2 branches covered.">		for (int i = 0; i &lt; children; i++) {</span>
			// Add next level
<span class="fc" id="L1824">			List&lt;Integer&gt; nextRow = new ArrayList&lt;&gt;(row.getRowIndex());</span>
<span class="fc" id="L1825">			nextRow.add(i);</span>
			// Create Wrapper
<span class="fc" id="L1827">			Object key = model.getRowKey(nextRow);</span>
<span class="fc" id="L1828">			RowIdWrapper wrapper = new RowIdWrapper(nextRow, key, row);</span>
<span class="fc" id="L1829">			calcChildrenRowIds(rows, wrapper, model, row, expanded, mode, forUpdate, editable);</span>
		}
<span class="fc" id="L1831">	}</span>

	/**
	 * @return the current page row indexes and their keys
	 */
	private Map&lt;List&lt;Integer&gt;, Object&gt; getCurrentRowIndexAndKeys() {
<span class="fc" id="L1837">		List&lt;RowIdWrapper&gt; wrappers = repeater.getBeanList();</span>
<span class="pc bpc" id="L1838" title="2 of 4 branches missed.">		if (wrappers == null || wrappers.isEmpty()) {</span>
<span class="nc" id="L1839">			return Collections.EMPTY_MAP;</span>
		}

<span class="fc" id="L1842">		Map&lt;List&lt;Integer&gt;, Object&gt; rows = new HashMap&lt;&gt;(wrappers.size());</span>
<span class="fc bfc" id="L1843" title="All 2 branches covered.">		for (RowIdWrapper wrapper : wrappers) {</span>
<span class="fc" id="L1844">			rows.put(wrapper.getRowIndex(), wrapper.getRowKey());</span>
<span class="fc" id="L1845">		}</span>
<span class="fc" id="L1846">		return rows;</span>
	}

	/**
	 * Contains the table's UI state.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
<span class="fc" id="L1855">	public static final class WTableComponentModel extends BeanAndProviderBoundComponentModel {</span>

		/**
		 * The margins to be used on the table.
		 */
		private Margin margin;

		/**
		 * This controls how sorting should function. Sortability is determined by the data model.
		 */
<span class="fc" id="L1865">		private SortMode sortMode = SortMode.NONE;</span>

		/**
		 * The data model for the table.
		 */
<span class="fc" id="L1870">		private TableModel tableModel = EmptyTableModel.INSTANCE;</span>

		/**
		 * Controls whether background striping is used to distinguish rows/columns from each other.
		 */
<span class="fc" id="L1875">		private StripingType stripingType = StripingType.NONE;</span>

		/**
		 * Controls whether a visual separator is used to distinguish rows/columns from each other.
		 */
<span class="fc" id="L1880">		private SeparatorType separatorType = SeparatorType.NONE;</span>

		/**
		 * This flag indicates whether column headers should be displayed.
		 */
<span class="fc" id="L1885">		private boolean showColumnHeaders = true;</span>

		/**
		 * The action to execute when the table's row selection changes.
		 */
		private Action selectionChangeAction;

		/**
		 * The text to display when the table contains no data.
		 */
<span class="fc" id="L1895">		private String noDataMessage = InternalMessages.DEFAULT_NO_TABLE_DATA;</span>

		/**
		 * The table summary text.
		 */
		private String summary;

		/**
		 * The table caption text.
		 */
		private String caption;

		/**
		 * The column order, only used for re-ordering columns.
		 */
		private int[] columnOrder;

		/**
		 * This is used to control how table data should be displayed.
		 */
<span class="fc" id="L1915">		private Type type = Type.TABLE;</span>

		// Pagination
		/**
		 * Indicates how pagination should occur.
		 */
<span class="fc" id="L1921">		private PaginationMode paginationMode = PaginationMode.NONE;</span>

		/**
		 * Indicates how many rows to display per page.
		 */
<span class="fc" id="L1926">		private int rowsPerPage = DEFAULT_ROWS;</span>

		/**
		 * Options for rows per page.
		 */
		private List&lt;Integer&gt; rowsPerPageOptions;

		/**
		 * Stores the current page index.
		 */
		private int currentPage;

		// Selection
		/**
		 * Indicates how row selection should function.
		 */
<span class="fc" id="L1942">		private SelectMode selectMode = SelectMode.NONE;</span>

		/**
		 * Indicates how the &quot;select all&quot; control should appear.
		 */
<span class="fc" id="L1947">		private SelectAllType selectAllMode = SelectAllType.TEXT;</span>

		/**
		 * Holds the keys of the currently selected rows.
		 */
		private Set&lt;?&gt; selectedRows;

		// Row expansion
		/**
		 * Indicates how row expansion should function.
		 */
<span class="fc" id="L1958">		private ExpandMode expandMode = ExpandMode.NONE;</span>

		/**
		 * Indicates whether a &quot;expand/collapse all&quot; control should be displayed.
		 */
<span class="fc" id="L1963">		private boolean expandAll = false;</span>

		/**
		 * Holds the keys of currently expanded rows.
		 */
		private Set&lt;?&gt; expandedRows;

		/**
		 * Holds the keys of rows that have been expanded (used for bean updating logic).
		 */
		private Set&lt;Object&gt; prevExpandedRows;

		/**
		 * Holds the keys of rows that have been rendered (used for bean updating logic).
		 */
		private Set&lt;Object&gt; prevRenderedRows;

		/**
		 * Flag if table cells/rows are editable. If true, extra details about each row need to be stored.
		 */
		private boolean editable;

		// Sorting
		/**
		 * Holds the currently sorted column index. A value of -1 indicates no active sort.
		 */
<span class="fc" id="L1989">		private int sortColIndex = -1;</span>

		/**
		 * Indicates whether the sort is ascending (true) or descending (false).
		 */
		private boolean sortAscending;

		/**
		 * This is used to map rendered table row indices to table model row indices, if the table model supports this
		 * mode of sorting.
		 */
		private int[] rowIndexMapping;

		// Action constraints
		/**
		 * This map holds the action constraints per table action (button).
		 */
<span class="fc" id="L2006">		private final Map&lt;WComponent, List&lt;ActionConstraint&gt;&gt; actionConstraints = new HashMap&lt;&gt;();</span>

		/**
		 * @return the maximum page number.
		 */
		private int getMaxPage() {
<span class="fc" id="L2012">			int rowCount = tableModel.getRowCount();</span>

<span class="fc bfc" id="L2014" title="All 2 branches covered.">			if (rowCount == 0) {</span>
<span class="fc" id="L2015">				return 0;</span>
<span class="fc bfc" id="L2016" title="All 4 branches covered.">			} else if (paginationMode == PaginationMode.NONE || rowsPerPage == 0) {</span>
				// NONE Pagination or Zero rows per page indicates no pagination when using rows per page options
<span class="fc" id="L2018">				return 0;</span>
			} else {
<span class="fc bfc" id="L2020" title="All 2 branches covered.">				return rowCount / rowsPerPage - (rowCount % rowsPerPage == 0 ? 1 : 0);</span>
			}
		}

		/**
		 * Adds a constraint to the list of constraints for the given button.
		 *
		 * @param button the button to add the constraint for.
		 * @param constraint the constraint to add.
		 */
		public void addActionConstraint(final WButton button, final ActionConstraint constraint) {
<span class="fc" id="L2031">			List&lt;ActionConstraint&gt; constraintForComponent = actionConstraints.get(button);</span>

<span class="fc bfc" id="L2033" title="All 2 branches covered.">			if (constraintForComponent == null) {</span>
<span class="fc" id="L2034">				constraintForComponent = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2035">				actionConstraints.put(button, constraintForComponent);</span>
			}

<span class="fc" id="L2038">			constraintForComponent.add(constraint);</span>
<span class="fc" id="L2039">		}</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public int getChildCount() {
<span class="fc" id="L2048">		return super.getChildCount();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public WComponent getChildAt(final int index) {
<span class="fc" id="L2057">		return super.getChildAt(index);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public int getIndexOfChild(final WComponent childComponent) {
<span class="fc" id="L2066">		return super.getIndexOfChild(childComponent);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// to make public
	public List&lt;WComponent&gt; getChildren() {
<span class="nc" id="L2075">		return super.getChildren();</span>
	}

	/**
	 * @return a String representation of this component, for debugging purposes.
	 */
	@Override
	public String toString() {
<span class="nc" id="L2083">		TableModel model = getTableModel();</span>
<span class="nc" id="L2084">		return toString(model.getClass().getSimpleName() + &quot;, &quot; + model.getRowCount() + &quot; rows&quot;, -1,</span>
				-1);
	}

	/**
	 * A naming context is only considered active if it has been set active via {@link #setNamingContext(boolean)} and
	 * also has an id name set via {@link #setIdName(String)}.
	 *
	 * @param context set true if this is a naming context.
	 */
	public void setNamingContext(final boolean context) {
<span class="fc" id="L2095">		setFlag(ComponentModel.NAMING_CONTEXT_FLAG, context);</span>
<span class="fc" id="L2096">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isNamingContext() {
<span class="fc" id="L2103">		return isFlagSet(ComponentModel.NAMING_CONTEXT_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getNamingContextId() {
<span class="fc" id="L2111">		return getId();</span>
	}

	/**
	 * Creates a new component model.
	 *
	 * @return a new TableModel.
	 */
	@Override
	protected WTableComponentModel newComponentModel() {
<span class="fc" id="L2121">		return new WTableComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// for type safety only
	protected WTableComponentModel getComponentModel() {
<span class="fc" id="L2130">		return (WTableComponentModel) super.getComponentModel();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	// for type safety only
	protected WTableComponentModel getOrCreateComponentModel() {
<span class="fc" id="L2139">		return (WTableComponentModel) super.getOrCreateComponentModel();</span>
	}

	/**
	 * &lt;p&gt;
	 * TableModel provides the data for tables. In a MVC sense, the TableModel is the Model, the {@link WTable} is the
	 * controller and the view is comprised of the WTable layout and column renderers.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Note that Data may be stored locally or sourced remotely, depending on the particular TableModel implementation.
	 * &lt;p&gt;
	 * &lt;p&gt;
	 * The row indexes used in the interface are a list of row indexes. Each item in the list is the index of the row
	 * for that level. The size of the list passed in matches the depth of the row.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Row and column indices for all methods are zero-based, and TableModels are not expected to perform
	 * bounds-checking.
	 * &lt;/p&gt;
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface TableModel {

		/**
		 * Retrieves the value at the given row and column.
		 *
		 * @param row - the row index.
		 * @param col - the column index. Column of -1 indicates row has a renderer.
		 * @return the value at the given row and column.
		 */
		Object getValueAt(List&lt;Integer&gt; row, int col);

		/**
		 * Indicates whether the given cell is editable.
		 *
		 * @param row - the row index.
		 * @param col - the column index. Column of -1 indicates row has a renderer.
		 * @return true if the given cell is editable, false otherwise.
		 */
		boolean isCellEditable(List&lt;Integer&gt; row, int col);

		/**
		 * Sets the value at the given row and column.
		 *
		 * @param value the value to set.
		 * @param row - the row index.
		 * @param col - the column index.
		 */
		void setValueAt(Object value, List&lt;Integer&gt; row, int col);

		/**
		 * Indicates whether the model supports sorting by the given column.
		 *
		 * @param col the column index.
		 * @return true if the model is sortable by the given column, false otherwise.
		 */
		boolean isSortable(int col);

		/**
		 * &lt;p&gt;
		 * Sorts the data by the given column. Any previous sorting should be disregarded.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * Data models must implement sorting in one of two ways.
		 * &lt;/p&gt;
		 * &lt;ol&gt;
		 * &lt;li&gt;
		 * &lt;p&gt;
		 * If the data is accessible locally by the data model (ie. a sort won't result in a service call to obtain
		 * sorted data), then this method should not sort the actual data, but return a row-index mapping which the
		 * table will use to access the data. Row selection and expansion will be updated to use the new row indices.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * For example, if the data for the column is {&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;c&quot;}, then an ascending sort should return {0, 1,
		 * 3, 2}, and a descending sort {2, 3, 1, 0}.
		 * &lt;/p&gt;
		 * &lt;/li&gt;
		 * &lt;li&gt;
		 * &lt;p&gt;
		 * If the data is not accessible locally by the data model, or the model is otherwise unable to perform a
		 * mapping between old and new row indices, then the model should sort the actual data, and return null. In this
		 * case, the table will reset any row selection or expansion.
		 * &lt;/p&gt;
		 * &lt;/li&gt;
		 * &lt;/ol&gt;
		 *
		 * @param col the column to sort on
		 * @param ascending true for an ascending sort, false for descending.
		 * @return the row indices in sort order, or null if row mappings can not be determined.
		 */
		int[] sort(int col, boolean ascending);

		/**
		 * Indicates whether the given row is disabled.
		 *
		 * @param row the row index
		 * @return true if the row is disabled, false otherwise.
		 */
		boolean isDisabled(List&lt;Integer&gt; row);

		/**
		 * Indicates whether the given row is selectable.
		 *
		 * @param row the row index
		 * @return true if the row is selectable, false otherwise.
		 */
		boolean isSelectable(List&lt;Integer&gt; row);

		/**
		 * Indicates whether the given row is expandable.
		 *
		 * @param row the row index
		 * @return true if the row is expandable, false otherwise.
		 */
		boolean isExpandable(List&lt;Integer&gt; row);

		/**
		 * Retrieves the number of rows for the root (ie top) level.
		 *
		 * @return the number of rows in the model for the root (ie top) level.
		 */
		int getRowCount();

		/**
		 * Allows the model to report if the row has children without actually having to determine the number of
		 * children (as it might not be known).
		 *
		 * @param row the row index
		 * @return true if the row has children
		 */
		boolean hasChildren(List&lt;Integer&gt; row);

		/**
		 * Retrieves the number of children a row has.
		 *
		 * @param row the row index
		 * @return the number of rows in the model for this level.
		 */
		int getChildCount(List&lt;Integer&gt; row);

		/**
		 * Retrieves the custom renderer for this row.
		 *
		 * @param row the row index
		 * @return the renderer class, or null if the default renderer is to be used.
		 */
		Class&lt;? extends WComponent&gt; getRendererClass(List&lt;Integer&gt; row);

		/**
		 * Retrieves the key (ie bean) used to uniquely identify this row.
		 * &lt;p&gt;
		 * The usual implementation of this method would just return the row id passed in.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * However, if you are required to dynamically add/remove rows in the model, which would change the row index,
		 * then the implementation of this method needs to return an object that uniquely identifies this row.
		 * &lt;/p&gt;
		 * &lt;p&gt;
		 * When rows have been added/removed, the {@link WTable#handleDataChanged} method on WTable needs to be called.
		 * &lt;/p&gt;
		 *
		 * @param row the row index
		 * @return the key (ie bean) used to uniquely identify this row
		 */
		Object getRowKey(List&lt;Integer&gt; row);
	}

	/**
	 * This extension of {@link TableModel} is primarily for models that do not store their data locally. Models
	 * implementing this interface can provide more efficient calls to back-end systems, as the data model is notified
	 * of which rows are likely to be used in the near future.
	 * &lt;p&gt;
	 * It is expected this TableModel is always used with Pagination.
	 * &lt;/p&gt;
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface ScrollableTableModel extends TableModel {

		/**
		 * This method will be called by the table to notify the TableModel of which rows are likely to be used in the
		 * near future.
		 *
		 * @param start the starting row index.
		 * @param end the ending row index.
		 */
		void setCurrentRows(int start, int end);
	}

	/**
	 * The BeanBoundTableModel provides a link between a bean (bound to a table), and the table model API.
	 *
	 * @author Jonathan Austin
	 * @since 1.0.0
	 */
	public interface BeanBoundTableModel extends TableModel, BeanProviderBound {

	}

	/**
	 * This repeater extension is necessary to ensure that tree-tables are painted correctly.
	 */
	public static class TableRepeater extends WRepeater {

		/**
		 * Parent table.
		 */
		private final WTable table;

		/**
		 * @param table the parent table.
		 */
<span class="fc" id="L2354">		public TableRepeater(final WTable table) {</span>
<span class="fc" id="L2355">			this.table = table;</span>
<span class="fc" id="L2356">			setRowIdProperty(&quot;rowKey&quot;);</span>
<span class="fc" id="L2357">			setIdName(ROW_ID_CONTEXT_PREFIX);</span>
<span class="fc" id="L2358">			setNamingContext(true);</span>
<span class="fc" id="L2359">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String getId() {
<span class="fc" id="L2366">			return table.getId() + ID_CONTEXT_SEPERATOR + getIdName();</span>
		}

		/**
		 * Override paintComponent, as the table renderer does all the work.
		 *
		 * @param renderContext the RenderContext to send output to.
		 */
		@Override
		protected void paintComponent(final RenderContext renderContext) {
			// Do nothing
<span class="nc" id="L2377">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		public List&lt;RowIdWrapper&gt; getBeanList() {
<span class="fc" id="L2384">			return super.getBeanList();</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		protected void cleanupStaleContexts(final Set&lt;?&gt; rowIds) {
			// Tables that are not editable, clean up contexts. Editable tables do not do the clean up so the contexts
			// are available when changing pages
<span class="nc bnc" id="L2394" title="All 2 branches missed.">			if (!table.isEditable()) {</span>
<span class="nc" id="L2395">				super.cleanupStaleContexts(rowIds);</span>
			}
<span class="nc" id="L2397">		}</span>

		/**
		 * {@inheritDoc}
		 */
		@Override
		protected String getRowIdName(final Object rowBean, final Object rowId) {
<span class="fc" id="L2404">			RowIdWrapper wrapper = (RowIdWrapper) rowBean;</span>
<span class="fc" id="L2405">			List&lt;Integer&gt; rowIndex = wrapper.getRowIndex();</span>
<span class="fc" id="L2406">			return table.getRowIdName(rowIndex, rowId);</span>
		}
	}

	/**
	 * Used to wrap the row index and the row key (used to uniquely identify the row).
	 * &lt;p&gt;
	 * Intended for internal use only.
	 * &lt;/p&gt;
	 */
	public static class RowIdWrapper {

		/**
		 * The row index.
		 */
		private final List&lt;Integer&gt; rowIndex;
		/**
		 * The row key.
		 */
		private final Object rowKey;
		/**
		 * The children of the row.
		 */
<span class="fc" id="L2429">		private final List&lt;RowIdWrapper&gt; children = new ArrayList&lt;&gt;();</span>
		/**
		 * Flag if row has children.
		 */
<span class="fc" id="L2433">		private boolean hasChildrenFlag = false;</span>
		/**
		 * Parent of the row.
		 */
		private final RowIdWrapper parent;
		/**
		 * Hold its position in the list.
		 */
		private int position;

		/**
		 * @param rowIndex the row index
		 * @param rowKey the row key
		 * @param parent the parent of the row, or null if no parent
		 */
		public RowIdWrapper(final List&lt;Integer&gt; rowIndex, final Object rowKey,
<span class="fc" id="L2449">				final RowIdWrapper parent) {</span>
<span class="fc" id="L2450">			this.rowIndex = rowIndex;</span>
<span class="fc" id="L2451">			this.rowKey = rowKey;</span>
<span class="fc" id="L2452">			this.parent = parent;</span>
<span class="fc" id="L2453">		}</span>

		/**
		 * @return the row index
		 */
		public List&lt;Integer&gt; getRowIndex() {
<span class="fc" id="L2459">			return rowIndex;</span>
		}

		/**
		 * @return the row key
		 */
		public Object getRowKey() {
<span class="fc" id="L2466">			return rowKey;</span>
		}

		/**
		 * @return the children of the row, or null if no children
		 */
		public List&lt;RowIdWrapper&gt; getChildren() {
<span class="nc" id="L2473">			return children;</span>
		}

		/**
		 * @param hasChildren true if row has children
		 */
		public void setHasChildren(final boolean hasChildren) {
<span class="fc" id="L2480">			this.hasChildrenFlag = hasChildren;</span>
<span class="fc" id="L2481">		}</span>

		/**
		 * @return true if the row has children
		 */
		public boolean hasChildren() {
<span class="nc" id="L2487">			return hasChildrenFlag;</span>
		}

		/**
		 * @param child the child row to add
		 */
		public void addChild(final RowIdWrapper child) {
<span class="fc" id="L2494">			children.add(child);</span>
<span class="fc" id="L2495">		}</span>

		/**
		 * @return the parent of the row, or null if no parent
		 */
		public RowIdWrapper getParent() {
<span class="fc" id="L2501">			return parent;</span>
		}

		/**
		 * @return the position of this row id in the list of row ids.
		 */
		public int getPosition() {
<span class="nc" id="L2508">			return position;</span>
		}

		/**
		 * @param position the position of this row id in the list of row ids.
		 */
		public void setPosition(final int position) {
<span class="fc" id="L2515">			this.position = position;</span>
<span class="fc" id="L2516">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>