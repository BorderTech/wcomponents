<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>WDataTableRowRenderer.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">WDataTableRowRenderer.java</span></div><h1>WDataTableRowRenderer.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.WRepeater.SubUIContext;
import com.github.bordertech.wcomponents.util.Util;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * WDataTableRowRenderer is used by the table's repeater to render row data. This class is intended for internal use
 * only.
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 *
 * @deprecated Use {@link WTable} and {@link WTableRowRenderer} instead.
 */
@Deprecated
public final class WDataTableRowRenderer extends WDataRenderer {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L25">	private static final Log LOG = LogFactory.getLog(WDataTableRowRenderer.class);</span>

	/**
	 * The table that this renderer belongs to.
	 */
	private final WDataTable table;

	/**
	 * The row header.
	 */
<span class="fc" id="L35">	private final WDecoratedLabel rowHeader = new WDecoratedLabel(new WText() {</span>
		@Override
		public String getData() {
<span class="nc" id="L38">			UIContext uic = UIContextHolder.getCurrent();</span>
<span class="nc" id="L39">			int row = getRowIndex((SubUIContext) uic);</span>
<span class="nc" id="L40">			return table.getDataModel().getRowHeader(row);</span>
		}
	});

	/**
	 * A Map of expanded renderers.
	 */
<span class="fc" id="L47">	private final Map&lt;Class&lt;? extends WComponent&gt;, WComponent&gt; expandedRenderers = new HashMap&lt;&gt;();</span>

	/**
	 * Creates a WDataTableRowRenderer.
	 *
	 * @param table the table that this renderer belongs to.
	 */
<span class="fc" id="L54">	protected WDataTableRowRenderer(final WDataTable table) {</span>
<span class="fc" id="L55">		this.table = table;</span>
<span class="fc" id="L56">		add(rowHeader);</span>
<span class="fc" id="L57">	}</span>

	/**
	 * Retrieves the component that is used to render the given column.
	 *
	 * @param columnIndex the column index.
	 * @return the component used to render the given column.
	 */
	public WComponent getRenderer(final int columnIndex) {
<span class="fc" id="L66">		int childIndex = columnIndex + 1; // the first child is the row header</span>
<span class="fc" id="L67">		return getChildAt(childIndex);</span>
	}

	/**
	 * @return the table that this row renderer belongs to.
	 */
	public WDataTable getTable() {
<span class="fc" id="L74">		return table;</span>
	}

	/**
	 * @return the row header.
	 */
	public WDecoratedLabel getRowHeader() {
<span class="nc" id="L81">		return rowHeader;</span>
	}

	/**
	 * &lt;p&gt;
	 * The preparePaintComponent method has been overridden to ensure that expanded row renderers have been correctly
	 * initialised.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Expanded row renderers are lazily instantiated and added to the shared structure as needed. This means for the
	 * first use of a renderer, it will not have been part of the WComponent tree, and would not have had its
	 * preparePaintComponent called. We therefore add the renderer to the tree here, and manually call its
	 * preparePaint.&lt;/p&gt;
	 *
	 * @param request the Request being responded to.
	 */
	@Override
	protected void preparePaintComponent(final Request request) {
<span class="fc" id="L99">		super.preparePaintComponent(request);</span>

<span class="fc" id="L101">		Class&lt;? extends WComponent&gt; rowRendererClass = getRowRendererClass();</span>

<span class="pc bpc" id="L103" title="3 of 4 branches missed.">		if (rowRendererClass != null &amp;&amp; !expandedRenderers.containsKey(rowRendererClass)) {</span>
<span class="nc" id="L104">			getExpandedTreeNodeRenderer(rowRendererClass).preparePaint(request);</span>
		}
<span class="fc" id="L106">	}</span>

	/**
	 * &lt;p&gt;
	 * This is called to lazily add expanded renderers as necessary. To save memory, only one instance of a renderer
	 * class is ever added to the row renderer instance. The RendererWrapper ensures that data binding occurs at the
	 * right time.&lt;/p&gt;
	 *
	 * @param rendererClass the renderer class.
	 * @return the expanded renderer for the given row.
	 */
	public WComponent getExpandedTreeNodeRenderer(final Class&lt;? extends WComponent&gt; rendererClass) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (rendererClass == null) {</span>
<span class="nc" id="L119">			return null;</span>
		}

		// If we already have an additional renderer for this class, return it.
		// This is synchronized, as it updates the shared model using locking/unlocking, which is a bit dodgy.
<span class="nc" id="L124">		synchronized (expandedRenderers) {</span>
<span class="nc" id="L125">			WComponent renderer = expandedRenderers.get(rendererClass);</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (renderer != null) {</span>
<span class="nc" id="L128">				return renderer;</span>
			}

			// Not found, create a new instance of the given class
<span class="nc" id="L132">			renderer = new RendererWrapper(this, rendererClass, -1);</span>
<span class="nc" id="L133">			expandedRenderers.put(rendererClass, renderer);</span>
<span class="nc" id="L134">			setLocked(false);</span>
<span class="nc" id="L135">			add(renderer);</span>
<span class="nc" id="L136">			setLocked(true);</span>

<span class="nc" id="L138">			return renderer;</span>
<span class="nc" id="L139">		}</span>
	}

	/**
	 * @param uic the SubUIContext to determine the row index for
	 * @return the row index for the specified SubUIContext.
	 */
	private int getRowIndex(final SubUIContext uic) {
		// SubUIContext does not cater for pagination
<span class="fc" id="L148">		return (Integer) table.getRepeater().getBeanList().get(uic.getRowIndex());</span>
	}

	/**
	 * Retrieves the renderer class for a given row.
	 *
	 * @return the renderer class for a given row (if it's an expanded row), otherwise null.
	 */
	private Class&lt;? extends WComponent&gt; getRowRendererClass() {
<span class="fc" id="L157">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L159" title="3 of 4 branches missed.">		if (table.getDataModel() instanceof TreeTableDataModel &amp;&amp; uic instanceof SubUIContext) {</span>
<span class="nc" id="L160">			int row = getRowIndex((SubUIContext) uic);</span>
<span class="nc" id="L161">			TreeTableDataModel dataModel = (TreeTableDataModel) table.getDataModel();</span>

<span class="nc" id="L163">			TableTreeNode node = dataModel.getNodeAtLine(row);</span>
<span class="nc" id="L164">			return node.getRendererClass();</span>
		}

<span class="fc" id="L167">		return null;</span>
	}

	/**
	 * The renderer wrapper is responsible for ensuring that the renderer is only used when needed (ie. it is only
	 * involved in processing of certain rows), and ensuring that data is passed to / from the renderer when required.
	 */
	private static final class RendererWrapper extends WBeanContainer implements BeanProvider {

		/**
		 * The table that this wrapper belongs to.
		 */
		private final WDataTableRowRenderer rowRenderer;

		/**
		 * The actual renderer used to render the column/expanded content.
		 */
		private final WComponent renderer;

		/**
		 * The index of the column which this wrapper renders, or -1 if this is an expended renderer.
		 */
		private final int columnIndex;

		/**
		 * Creates a RendererWrapper.
		 *
		 * @param rowRenderer the row renderer.
		 * @param rendererClass the column/expanded content renderer class.
		 * @param columnIndex the index of the column renderer, or -1 if the renderer is for expanded content.
		 */
		private RendererWrapper(final WDataTableRowRenderer rowRenderer,
<span class="fc" id="L199">				final Class&lt;? extends WComponent&gt; rendererClass, final int columnIndex) {</span>
<span class="fc" id="L200">			this.rowRenderer = rowRenderer;</span>
<span class="fc" id="L201">			this.columnIndex = columnIndex;</span>
<span class="fc" id="L202">			WComponent rendererComponent = null;</span>

			// Not found, create a new instance of the given class
			try {
<span class="fc" id="L206">				rendererComponent = rendererClass.newInstance();</span>

<span class="pc bpc" id="L208" title="1 of 2 branches missed.">				if (rendererComponent instanceof BeanProviderBound) {</span>
<span class="fc" id="L209">					((BeanProviderBound) rendererComponent).setBeanProvider(this);</span>
				}

<span class="fc" id="L212">				add(rendererComponent);</span>
<span class="nc" id="L213">			} catch (Exception e) {</span>
<span class="nc" id="L214">				LOG.error(&quot;Failed to instantiate renderer: &quot; + rendererClass.getName(), e);</span>
<span class="nc" id="L215">				setVisible(false);</span>
<span class="fc" id="L216">			}</span>

<span class="fc" id="L218">			renderer = rendererComponent;</span>
<span class="fc" id="L219">		}</span>

		/**
		 * Creates a RendererWrapper.
		 *
		 * @param rowRenderer the row renderer.
		 * @param renderer the column/expanded content renderer component.
		 * @param columnIndex the index of the column renderer, or -1 if the renderer is for expanded content.
		 */
		private RendererWrapper(final WDataTableRowRenderer rowRenderer, final WComponent renderer,
<span class="fc" id="L229">				final int columnIndex) {</span>
<span class="fc" id="L230">			this.rowRenderer = rowRenderer;</span>
<span class="fc" id="L231">			this.columnIndex = columnIndex;</span>
<span class="fc" id="L232">			this.renderer = renderer;</span>

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			if (renderer instanceof BeanProviderBound) {</span>
<span class="fc" id="L235">				((BeanProviderBound) renderer).setBeanProvider(this);</span>
			}

<span class="fc" id="L238">			add(renderer);</span>
<span class="fc" id="L239">		}</span>

		/**
		 * Column Renderers are invisible for expanded rows with an expanded renderer set.
		 *
		 * @return true if this component is visible, false if invisible.
		 */
		@Override
		public boolean isVisible() {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">			if (!super.isVisible()) {</span>
<span class="nc" id="L249">				return false;</span>
			}

<span class="fc" id="L252">			Class&lt;? extends WComponent&gt; rendererClass = rowRenderer.getRowRendererClass();</span>

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">			if (columnIndex &gt;= 0) {</span>
				// column renderer
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">				return rendererClass == null;</span>
			} else {
				// expanded content renderer
<span class="nc bnc" id="L259" title="All 4 branches missed.">				return renderer != null &amp;&amp; Util.equals(renderer.getClass(), rendererClass);</span>
			}
		}

		/**
		 * Provides data to a component rendering a column.
		 *
		 * @param beanProviderBound the component rendering the column.
		 * @return a bean value for component that is rendering the specified row/column
		 */
		@Override
		public Object getBean(final BeanProviderBound beanProviderBound) {
<span class="fc" id="L271">			UIContext uic = UIContextHolder.getCurrent();</span>

			// Make sure we have the correct uic
<span class="pc bpc" id="L274" title="2 of 4 branches missed.">			while (uic instanceof SubUIContext &amp;&amp; !((SubUIContext) uic).isInContext(</span>
					(WComponent) beanProviderBound)) {
<span class="nc" id="L276">				uic = ((SubUIContext) uic).getParentContext();</span>
			}

<span class="pc bpc" id="L279" title="1 of 2 branches missed.">			if (!(uic instanceof SubUIContext)) {</span>
<span class="nc" id="L280">				LOG.error(&quot;Unable to handle UIContext type: &quot; + uic.getClass().getName());</span>
<span class="nc" id="L281">				return null;</span>
			}

<span class="fc" id="L284">			int row = rowRenderer.getRowIndex((SubUIContext) uic);</span>

<span class="pc bpc" id="L286" title="1 of 2 branches missed.">			if (columnIndex &lt; 0) {</span>
				// This is not a column renderer, it must be an additional row renderer
<span class="nc" id="L288">				TreeTableDataModel dataModel = (TreeTableDataModel) rowRenderer.table.getDataModel();</span>
<span class="nc" id="L289">				return dataModel.getNodeAtLine(row).getData();</span>
			} else {
<span class="fc" id="L291">				return rowRenderer.table.getDataModel().getValueAt(row, columnIndex);</span>
			}
		}

		/**
		 * Some renderers may not be bean provider bound, or not bean-aware. We need to make sure that the data is set
		 * correctly for these columns.
		 *
		 * @param request the request being responded to.
		 */
		@Override
		protected void preparePaintComponent(final Request request) {
<span class="fc" id="L303">			super.preparePaintComponent(request);</span>

<span class="fc" id="L305">			TableDataModel model = rowRenderer.table.getDataModel();</span>
<span class="fc" id="L306">			UIContext uic = UIContextHolder.getCurrent();</span>
<span class="fc" id="L307">			int row = rowRenderer.getRowIndex((SubUIContext) uic);</span>

			// Update input read-only status
<span class="fc bfc" id="L310" title="All 2 branches covered.">			if (renderer instanceof Input) {</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">				((Input) renderer).setReadOnly(!model.isCellEditable(row, columnIndex));</span>
			}

<span class="pc bpc" id="L314" title="1 of 2 branches missed.">			if (!(renderer instanceof BeanProviderBound)) {</span>
<span class="nc" id="L315">				Object bean = null;</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">				if (columnIndex &gt;= 0) {</span>
<span class="nc" id="L318">					bean = model.getValueAt(row, columnIndex);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">				} else if (model instanceof TreeTableDataModel) {</span>
<span class="nc" id="L320">					TreeTableDataModel treeModel = (TreeTableDataModel) model;</span>
<span class="nc" id="L321">					bean = treeModel.getNodeAtLine(row).getData();</span>
				}

<span class="nc bnc" id="L324" title="All 2 branches missed.">				if (renderer instanceof BeanBound) {</span>
<span class="nc" id="L325">					((BeanBound) renderer).setBean(bean);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">				} else if (renderer instanceof DataBound) {</span>
<span class="nc" id="L327">					((DataBound) renderer).setData(bean);</span>
				}
			}
<span class="fc" id="L330">		}</span>
	}

	/**
	 * Adds a column to the renderer. This method is called by {@link WDataTable} to keep the renderer's and table's
	 * columns in sync.
	 *
	 * @param column the column to add.
	 * @param columnIndex the index of the column.
	 */
	void addColumn(final WTableColumn column, final int columnIndex) {
<span class="fc" id="L341">		WComponent renderer = column.getRenderer();</span>

<span class="fc bfc" id="L343" title="All 2 branches covered.">		if (renderer == null) {</span>
<span class="fc" id="L344">			Class&lt;? extends WComponent&gt; rendererClass = column.getRendererClass();</span>

<span class="pc bpc" id="L346" title="1 of 2 branches missed.">			if (!(BeanProviderBound.class.isAssignableFrom(rendererClass))</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">					&amp;&amp; !(BeanBound.class.isAssignableFrom(rendererClass))</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">					&amp;&amp; !(DataBound.class.isAssignableFrom(rendererClass))) {</span>
<span class="nc" id="L349">				throw new IllegalArgumentException(</span>
						&quot;Column renderers must be BeanProvider-, Bean- or Data-Bound&quot;);
			}

<span class="fc" id="L353">			add(new RendererWrapper(this, rendererClass, columnIndex));</span>
<span class="fc" id="L354">		} else {</span>
<span class="pc bpc" id="L355" title="5 of 6 branches missed.">			if (!(renderer instanceof BeanProviderBound)</span>
					&amp;&amp; !(renderer instanceof BeanBound)
					&amp;&amp; !(renderer instanceof DataBound)) {
<span class="nc" id="L358">				throw new IllegalArgumentException(</span>
						&quot;Column renderers must be BeanProvider-, Bean- or Data-Bound&quot;);
			}

<span class="fc" id="L362">			add(new RendererWrapper(this, renderer, columnIndex));</span>
		}
<span class="fc" id="L364">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>