<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>AbstractWComponent.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">AbstractWComponent.java</span></div><h1>AbstractWComponent.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.layout.UIManager;
import com.github.bordertech.wcomponents.registry.UIRegistry;
import com.github.bordertech.wcomponents.util.Config;
import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.SystemException;
import com.github.bordertech.wcomponents.util.Util;
import com.github.bordertech.wcomponents.validation.Diagnostic;
import com.github.bordertech.wcomponents.validation.DiagnosticImpl;
import com.github.bordertech.wcomponents.velocity.VelocityTemplateManager;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * AbstractWComponent is the parent class of all standard WComponents.
 * &lt;/p&gt;
 * &lt;p&gt;
 * WComponent trees (UIs) are intended to be shared between sessions in order to reduce their memory footprint. To
 * archive this a class called UIContext has been introduced to store WComponent information specific to an individual
 * session. Each session has its own UIContext instance which is passed to the component tree whenever it needs to
 * handle events and paint.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The attributes of a WComponent have an initial shared value that can be overridden on a per session basis. We call
 * this a private attribute value. The methods that manipulate a components attributes will normally have two method
 * signatures. One will manipulate the shared value and does not require a UIContext to be passed. The other will
 * manipulate the private session based value and will include a UIContext as the first parameter. The methods that
 * access a components attributes only require one method signature. Accessor methods will include a UIContext as their
 * first parameter. They will return the private attribute value if one exists else the shared value.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The shared/private concept makes WComponents very flexible but has the dangerous ramification that it is easy to
 * accidentally dynamically share attribute values and even whole chunks of UI with everyone. To reduce this risk, it is
 * possible to lock a component and all its children. When the lock is set, it becomes impossible to update a shared
 * value. Trying to update a shared value will result in a runtime exception. The intention is that shared component
 * trees will be held in a registry. Adding a component tree to a registry would be a sensible time to lock it.
 * &lt;/p&gt;
 *
 * @author James Gifford, Martin Shevchenko
 * @since 1.0.0
 */
<span class="fc" id="L57">public abstract class AbstractWComponent implements WComponent {</span>

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L62">	private static final Log LOG = LogFactory.getLog(AbstractWComponent.class);</span>

	/**
	 * Indicates whether this component is locked. Trying to update a shared value will result in a runtime exception
	 * when a component is locked.
	 */
<span class="fc" id="L68">	private boolean locked = false;</span>

	/**
	 * The shared model for this component.
	 */
<span class="fc" id="L73">	private final ComponentModel sharedModel = newComponentModel();</span>

	/**
	 * ID pattern.
	 */
<span class="fc" id="L78">	private static final Pattern ID_PATTERN = Pattern.compile(ID_VALIDATION_PATTERN);</span>

	/**
	 * This flag controls if component ids should be checked for duplicates. As verifying requires extra resources and
	 * memory, this can be disabled if required. It is encouraged projects at least have this set true in development
	 * environment.
	 */
<span class="fc" id="L85">	private static final boolean CHECK_DUPLICATE_IDS = Config.getInstance()</span>
<span class="fc" id="L86">			.getBoolean(&quot;bordertech.wcomponents.check.duplicate.ids.enabled&quot;, true);</span>

	// ================================
	// Identification
	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getInternalId() {
<span class="fc" id="L95">		String iid = null;</span>

		// As determining the internal id involves a fair bit of tree traversal, it is cached in the scratch map.
		// Try to retrieve the cached id first.
<span class="fc" id="L99">		Map scratchMap = getScratchMap();</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">		if (scratchMap != null) {</span>
<span class="fc" id="L102">			iid = (String) scratchMap.get(&quot;iid&quot;);</span>
		}

<span class="fc bfc" id="L105" title="All 2 branches covered.">		if (iid == null) {</span>
			// An id is a function of a component's position in the component tree.
			// The id will remain constant so long as the component tree does not
			// change.
<span class="fc" id="L109">			Container parent = getParent();</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">			if (parent == null) {</span>
<span class="fc" id="L112">				return DEFAULT_INTERNAL_ID;</span>
			}

<span class="fc" id="L115">			iid = parent.getInternalId();</span>
<span class="fc" id="L116">			final int nameLen = iid.length();</span>
<span class="fc" id="L117">			StringBuffer nameBuf = new StringBuffer(nameLen + 3);</span>
<span class="fc" id="L118">			nameBuf.append(iid);</span>
<span class="fc" id="L119">			nameBuf.append(getIndexOfChild(parent, this));</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">			if (iid.charAt(nameLen - 1) &lt;= '9') {</span>
				// last char was a number, change current to letters
<span class="fc bfc" id="L123" title="All 2 branches covered.">				for (int i = nameLen; i &lt; nameBuf.length(); i++) {</span>
<span class="fc" id="L124">					nameBuf.setCharAt(i, (char) (nameBuf.charAt(i) + ('a' - '0')));</span>
				}
			}

<span class="fc" id="L128">			iid = nameBuf.toString();</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">			if (scratchMap != null) {</span>
<span class="fc" id="L131">				scratchMap.put(&quot;iid&quot;, iid);</span>
			}
		}

<span class="fc" id="L135">		return iid;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getIdName() {
<span class="fc" id="L143">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L144">		return model.getIdName();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setIdName(final String idName) {
		// Not allow empty or null
<span class="fc bfc" id="L153" title="All 2 branches covered.">		if (Util.empty(idName)) {</span>
<span class="fc" id="L154">			throw new IllegalArgumentException(&quot;idName cannot be null or empty&quot;);</span>
		}

		// Must start with a letter and followed by letters, digits and or underscores
<span class="fc" id="L158">		Matcher matcher = ID_PATTERN.matcher(idName);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">		if (!matcher.matches()) {</span>
<span class="fc" id="L160">			throw new IllegalArgumentException(</span>
					&quot;idName &quot;
					+ idName
					+ &quot; must start with a letter and followed by letters, digits and or underscores.&quot;);
		}

<span class="fc" id="L166">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L167">		model.setIdName(idName);</span>
<span class="fc" id="L168">	}</span>

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated no longer used. use {@link #getId()} instead.
	 */
	@Override
	@Deprecated
	public String getName() {
<span class="fc" id="L178">		return getId();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getId() {
		// As determining the name involves a fair bit of tree traversal, it is cached in the scratch map.
		// Try to retrieve the cached name first.
<span class="fc" id="L188">		Map scratchMap = getScratchMap();</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">		if (scratchMap != null) {</span>
<span class="fc" id="L190">			String name = (String) scratchMap.get(&quot;name&quot;);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">			if (name != null) {</span>
<span class="fc" id="L192">				return name;</span>
			}
		}

		// Get ID name
<span class="fc" id="L197">		String idName = getIdName();</span>

		String name;
		// No ID name, so generate an ID
<span class="fc bfc" id="L201" title="All 2 branches covered.">		if (idName == null) {</span>
<span class="fc" id="L202">			name = generateId();</span>
		} else { // Has ID name, so derive the full context name
<span class="fc" id="L204">			name = deriveId(idName);</span>
		}

<span class="fc bfc" id="L207" title="All 2 branches covered.">		if (scratchMap != null) {</span>
<span class="fc" id="L208">			scratchMap.put(&quot;name&quot;, name);</span>
		}

		// Log warning if an Active Naming Context has no id name
<span class="pc bpc" id="L212" title="1 of 6 branches missed.">		if (this instanceof NamingContextable &amp;&amp; ((NamingContextable) this).isNamingContext() &amp;&amp; idName == null) {</span>
<span class="nc" id="L213">			LOG.warn(</span>
					&quot;NamingContext [ID:&quot; + name + &quot;] does not have an id name set. Will be ignored.&quot;);
		}

<span class="fc" id="L217">		return name;</span>
	}

	/**
	 * @return the generated unique id
	 */
	private String generateId() {
		// Direct parent
<span class="fc" id="L225">		Container parent = getParent();</span>

		// No Parent
<span class="fc bfc" id="L228" title="All 2 branches covered.">		if (parent == null) {</span>
<span class="fc" id="L229">			return DEFAULT_NO_ID;</span>
		}

		// Check if parent is an active naming context
<span class="fc" id="L233">		boolean parentIsNamingContext = WebUtilities.isActiveNamingContext(parent);</span>

		// Get ID prefix
		String prefix;
<span class="fc bfc" id="L237" title="All 2 branches covered.">		if (parentIsNamingContext) {</span>
<span class="fc" id="L238">			prefix = ((NamingContextable) parent).getNamingContextId();</span>
		} else {
<span class="fc" id="L240">			prefix = parent.getId();</span>
		}

		// Setup name buffer
<span class="fc" id="L244">		int prefixLen = prefix.length();</span>
<span class="fc" id="L245">		StringBuffer nameBuf = new StringBuffer(prefixLen + 3);</span>

		// Append prefix (if required)
<span class="fc bfc" id="L248" title="All 2 branches covered.">		if (prefixLen != 0) {</span>
<span class="fc" id="L249">			nameBuf.append(prefix);</span>
			// Parent is a NamingContext, so include context separator
<span class="fc bfc" id="L251" title="All 2 branches covered.">			if (parentIsNamingContext) {</span>
<span class="fc" id="L252">				nameBuf.append(ID_CONTEXT_SEPERATOR);</span>
			}
		}

		// Use the component's position in the tree (ie index) to build a unique ID
<span class="fc" id="L257">		int idx = getIndexOfChild(parent, this);</span>

		// Parent has a generated ID (ie no id name)
		// (NamingContexts must have an id name, so never null)
<span class="fc bfc" id="L261" title="All 2 branches covered.">		if (parent.getIdName() == null) {</span>
			// Generate ID - Append the index
<span class="fc" id="L263">			nameBuf.append(idx);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">			if (prefix.charAt(prefixLen - 1) &lt;= '9') {</span>
				// last char was a number, change current to letters
<span class="fc bfc" id="L266" title="All 2 branches covered.">				for (int i = prefixLen; i &lt; nameBuf.length(); i++) {</span>
<span class="fc" id="L267">					nameBuf.setCharAt(i, (char) (nameBuf.charAt(i) + ('a' - '0')));</span>
				}
			}
		} else { // Parent has an id name assigned
			// Generate ID (with separator)
<span class="fc" id="L272">			nameBuf.append(ID_FRAMEWORK_ASSIGNED_SEPERATOR);</span>
<span class="fc" id="L273">			nameBuf.append(idx);</span>
		}

<span class="fc" id="L276">		return nameBuf.toString();</span>
	}

	/**
	 * Derive the full id from its naming context.
	 *
	 * @param idName the component id name
	 * @return the derived id in its context
	 */
	private String deriveId(final String idName) {
		// Find parent naming context
<span class="fc" id="L287">		NamingContextable parent = WebUtilities.getParentNamingContext(this);</span>

		// No Parent
<span class="fc bfc" id="L290" title="All 2 branches covered.">		if (parent == null) {</span>
<span class="fc" id="L291">			return idName;</span>
		}

		// Get ID prefix
<span class="fc" id="L295">		String prefix = parent.getNamingContextId();</span>

		// No Prefix, just use id name
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">		if (prefix.length() == 0) {</span>
<span class="nc" id="L299">			return idName;</span>
		}

		// Add Prefix
<span class="fc" id="L303">		StringBuffer nameBuf = new StringBuffer(prefix.length() + idName.length() + 1);</span>
<span class="fc" id="L304">		nameBuf.append(prefix);</span>
<span class="fc" id="L305">		nameBuf.append(ID_CONTEXT_SEPERATOR);</span>
<span class="fc" id="L306">		nameBuf.append(idName);</span>

<span class="fc" id="L308">		return nameBuf.toString();</span>
	}

	/**
	 * Register this component's ID in its naming context.
	 */
	void registerInContext() {
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">		if (!CHECK_DUPLICATE_IDS) {</span>
<span class="nc" id="L316">			return;</span>
		}

		// Register Component if it has an ID name set
<span class="fc bfc" id="L320" title="All 2 branches covered.">		if (getIdName() != null) {</span>
			// Find parent context
<span class="fc" id="L322">			NamingContextable context = WebUtilities.getParentNamingContext(this);</span>

<span class="fc bfc" id="L324" title="All 2 branches covered.">			if (context == null) {</span>
				// If this is the top context, then register itself
<span class="fc bfc" id="L326" title="All 2 branches covered.">				if (WebUtilities.isActiveNamingContext(this)) {</span>
<span class="fc" id="L327">					this.registerId(this);</span>
				} else {
<span class="fc" id="L329">					LOG.warn(&quot;Component with id name [&quot; + getIdName()</span>
							+ &quot;] is not in a naming context and cannot be verified for duplicate id.&quot;);
				}
<span class="fc" id="L332">				return;</span>
			}
			// Assume context is AbstractWComponent
<span class="fc" id="L335">			((AbstractWComponent) context).registerId(this);</span>
		}
<span class="fc" id="L337">	}</span>

	/**
	 * Helper method to be used by a {@link NamingContextable} to register a component.
	 *
	 * @param component the component to register
	 */
	void registerId(final WComponent component) {
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">		if (!WebUtilities.isActiveNamingContext(this)) {</span>
<span class="nc" id="L346">			throw new SystemException(&quot;Can only register a component on an active NamingContext&quot;);</span>
		}

		// Get registered id names
<span class="fc" id="L350">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L351">		Map&lt;String, WComponent&gt; ids = model.getContextIds();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">		if (ids == null) {</span>
<span class="fc" id="L353">			ids = new HashMap&lt;&gt;();</span>
<span class="fc" id="L354">			model.setContextIds(ids);</span>
		}

		// Get id name
<span class="fc" id="L358">		String idName = component.getIdName();</span>

		// Check if already used
<span class="fc" id="L361">		WComponent mapped = ids.get(idName);</span>

		// Not in map
<span class="fc bfc" id="L364" title="All 2 branches covered.">		if (mapped == null) {</span>
			// Save ID / Component
<span class="fc" id="L366">			ids.put(idName, component);</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">		} else if (mapped != component) { // Check is same component</span>
<span class="fc" id="L368">			String contextName = getId();</span>
<span class="fc" id="L369">			throw new SystemException(&quot;Duplicate ID. ID \&quot;&quot; + idName + &quot;\&quot; for &quot; + component.</span>
<span class="fc" id="L370">					getClass().getName()</span>
<span class="fc" id="L371">					+ &quot; is already in use by &quot; + mapped.getClass().getName() + &quot; in context \&quot;&quot; + contextName + &quot;\&quot;.&quot;);</span>
		}

<span class="fc" id="L374">	}</span>

	/**
	 * Clear the ID register. Usually called when a naming context is being painted. This allows the IDs to be
	 * refreshed.
	 */
	void clearIdRegister() {
<span class="fc" id="L381">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L382">		model.setContextIds(null);</span>
<span class="fc" id="L383">	}</span>

	/**
	 * &lt;p&gt;
	 * Retrieves a short-lived map which can be used to cache data during request processing. This map will be
	 * guaranteed to be cleared at the end of processing a request, but may also be cleared during request processing.
	 * Do not rely on the contents of this map to exist at any time.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * This method will return &lt;code&gt;null&lt;/code&gt; if called outside of request processing.
	 * &lt;/p&gt;
	 *
	 * @return a map which can be used to temporarily cache data, or null
	 */
	protected Map getScratchMap() {
<span class="fc" id="L398">		UIContext uic = UIContextHolder.getCurrent();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">		return uic == null ? null : uic.getScratchMap(this);</span>
	}

	// ================================
	// Action/Event handling
	/**
	 * {@inheritDoc}
	 */
	@Override
	public final void serviceRequest(final Request request) {
<span class="fc" id="L409">		ArrayList&lt;WComponent&gt; visibles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L410">		collateVisible(this, visibles);</span>

<span class="pc bpc" id="L412" title="1 of 2 branches missed.">		if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L413">			LOG.debug(&quot;Calling handleRequest for &quot; + visibles.size() + &quot; components&quot;);</span>
		}

<span class="fc bfc" id="L416" title="All 2 branches covered.">		for (int i = 0; i &lt; visibles.size(); i++) {</span>
<span class="fc" id="L417">			WComponent next = visibles.get(i);</span>

<span class="pc bpc" id="L419" title="1 of 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L420">				LOG.debug(&quot;Calling handleRequest on &quot; + next.getId() + &quot; &quot; + next.getClass());</span>
			}

<span class="fc" id="L423">			next.handleRequest(request);</span>
		}

<span class="fc" id="L426">		invokeLaters();</span>
<span class="fc" id="L427">	}</span>

	/**
	 * Collates all the visible components in this branch of the WComponent tree. WComponents are added to the
	 * &lt;code&gt;list&lt;/code&gt; in depth-first order, as this list is traversed in order during the request handling phase.
	 *
	 * @param component the current branch to collate visible items in.
	 * @param list the list to add the visible components to.
	 */
	private static void collateVisible(final WComponent component, final List&lt;WComponent&gt; list) {
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if (component.isVisible()) {</span>

<span class="fc bfc" id="L439" title="All 2 branches covered.">			if (component instanceof Container) {</span>

<span class="fc" id="L441">				final int size = ((Container) component).getChildCount();</span>

<span class="fc bfc" id="L443" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L444">					collateVisible(((Container) component).getChildAt(i), list);</span>
				}
			}

<span class="fc" id="L448">			list.add(component);</span>
		}
<span class="fc" id="L450">	}</span>

	/**
	 * The framework calls this method at the end of the serviceRequest method. The default implementation is that only
	 * a root wcomponent actually runs them.
	 */
	protected void invokeLaters() {
<span class="fc bfc" id="L457" title="All 2 branches covered.">		if (getParent() == null) {</span>
<span class="fc" id="L458">			UIContext uic = UIContextHolder.getCurrent();</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">			if (uic != null) {</span>
<span class="fc" id="L461">				uic.doInvokeLaters();</span>
			}
		}
<span class="fc" id="L464">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void invokeLater(final Runnable runnable) {
<span class="fc" id="L471">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L473" title="1 of 2 branches missed.">		if (uic != null) {</span>
<span class="fc" id="L474">			uic.invokeLater(runnable);</span>
		}
<span class="fc" id="L476">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void handleRequest(final Request request) {
		// NOP - classes to override.
<span class="fc" id="L484">	}</span>

	// ---------------------------------
	// Non-WComponent web interface methods
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void forward(final String url) {
<span class="fc" id="L493">		invokeLater(new Runnable() {</span>
			@Override
			public void run() {
<span class="fc" id="L496">				throw new ForwardException(url);</span>
			}
		});
<span class="fc" id="L499">	}</span>

	// ================================
	// Painting
	/**
	 * Associates a Velocity template with this component by supplying a resource url.
	 *
	 * @param templateUrl the location of the velocity template resource.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	void setTemplate(final String templateUrl) {
<span class="fc" id="L511">		getOrCreateComponentModel().setTemplateUrl(templateUrl);</span>
<span class="fc" id="L512">	}</span>

	/**
	 * Directly associates Velocity mark-up with this component. The mark-up will be used for rendering.
	 *
	 * @param markUp Velocity mark-up.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	void setTemplateMarkUp(final String markUp) {
<span class="nc" id="L522">		getOrCreateComponentModel().setTemplateMarkUp(markUp);</span>
<span class="nc" id="L523">	}</span>

	/**
	 * Retrieves Velocity mark-up which has been explicitly associated with this component.
	 *
	 * @return the Velocity mark-up, or null if no mark-up has been set explicitly.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public String getTemplateMarkUp() {
<span class="fc" id="L533">		return getComponentModel().getTemplateMarkUp();</span>
	}

	/**
	 * Retrieves the resource url of the Velocity template associated with this component.
	 *
	 * @return the location of the Velocity template resource, or null if there is no template.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public String getTemplate() {
<span class="fc" id="L544">		return getComponentModel().getTemplateUrl();</span>
	}

	/**
	 * Associates a velocity template with this component. A simple mapping is applied to the given class to derive the
	 * name of a velocity template.
	 * &lt;p&gt;
	 * For instance, com.github.bordertech.wcomponents.WTextField would map to the template
	 * com/github/bordertech/wcomponents/WTextField.vm
	 * &lt;/p&gt;
	 *
	 * @param clazz the class to use to retrieve the template.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	void setTemplate(final Class clazz) {
<span class="fc" id="L560">		setTemplate(VelocityTemplateManager.toTemplateResourceName(clazz));</span>
<span class="fc" id="L561">	}</span>

	/**
	 * Prepares this component and all child componenents for painting (e.g. rendering to XML). This implementation
	 * calls {@link #preparePaintComponent(Request)}, then calls {@link #preparePaint(Request)} on all its children.
	 * Note that the this component's {@link #preparePaintComponent(Request)} is called before the childrens'
	 * {@link #preparePaintComponent(Request)} is called.
	 *
	 * @param request the request being responded to.
	 */
	@Override
	public final void preparePaint(final Request request) {
		// Don't prepare if it's invisible.
<span class="fc bfc" id="L574" title="All 2 branches covered.">		if (!isVisible()) {</span>
<span class="fc" id="L575">			return;</span>
		}

		// Prepare this component.
<span class="fc" id="L579">		preparePaintComponent(request);</span>

		// Prepare its children.
<span class="fc" id="L582">		final ArrayList&lt;WComponent&gt; children = (ArrayList&lt;WComponent&gt;) getComponentModel().</span>
<span class="fc" id="L583">				getChildren();</span>

<span class="fc bfc" id="L585" title="All 2 branches covered.">		if (children != null) {</span>
<span class="fc" id="L586">			final int size = children.size();</span>

<span class="fc bfc" id="L588" title="All 2 branches covered.">			for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L589">				children.get(i).preparePaint(request);</span>
			}

			// Chances are that the WComponent tree is fairly stable now, so take
			// the opportunity to trim the child list to size if we have one.
			// This is just a memory optimization - it won't prevent adding more
			// children later, of course.
<span class="fc" id="L596">			children.trimToSize();</span>
		}
<span class="fc" id="L598">	}</span>

	/**
	 * Subclasses may override this method to place the component in the correct state before it is painted. When
	 * overriding this method, it is good practice to also call the superclass implementation.
	 *
	 * @param request the request being responded to.
	 */
	protected void preparePaintComponent(final Request request) {
		// NOP
<span class="fc" id="L608">	}</span>

	/**
	 * Renders the component. If the component is visible then paint calls:
	 * &lt;ol&gt;
	 * &lt;li&gt;{@link #beforePaint(RenderContext) beforePaint(...)}&lt;/li&gt;
	 * &lt;li&gt;{@link #paintComponent(RenderContext) paintComponent(...)}&lt;/li&gt;
	 * &lt;li&gt;{@link #afterPaint(RenderContext) afterPaint(...)}&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @param renderContext the RenderContext to send the output to.
	 */
	@Override
	public final void paint(final RenderContext renderContext) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">		if (isVisible()) {</span>
			// If painting a NamingContext, reset its registered IDs
<span class="fc bfc" id="L624" title="All 2 branches covered.">			if (WebUtilities.isActiveNamingContext(this)) {</span>
<span class="fc" id="L625">				clearIdRegister();</span>
			}

<span class="fc" id="L628">			registerInContext();</span>

<span class="fc" id="L630">			beforePaint(renderContext);</span>
<span class="fc" id="L631">			paintComponent(renderContext);</span>
<span class="fc" id="L632">			afterPaint(renderContext);</span>
		}
<span class="fc" id="L634">	}</span>

	/**
	 * Indicates whether structural debugging info should be output for this component.
	 *
	 * @return false debug structure is never enabled for this component.
	 */
	protected boolean isDebugStructure() {
<span class="nc" id="L642">		return false;</span>
	}

	/**
	 * Subclasses may override this method to output content before the component has been painted. When overriding this
	 * method, it is good practice to call the superclass implementation
	 * &lt;b&gt;after&lt;/b&gt; emitting any additional content.
	 *
	 * @param renderContext the context to render to.
	 */
	protected void beforePaint(final RenderContext renderContext) {
		// NOP
<span class="fc" id="L654">	}</span>

	/**
	 * Subclasses may override this method to output content after the component has been painted. When overriding this
	 * method, it is good practice to call the superclass implementation
	 * &lt;b&gt;before&lt;/b&gt; emitting any additional content.
	 *
	 * @param renderContext the context to render to.
	 */
	protected void afterPaint(final RenderContext renderContext) {
		// NOP
<span class="fc" id="L665">	}</span>

	/**
	 * This is where most of the painting work is normally done. If a layout has been supplied either directly or by
	 * supplying a velocity template, then painting is delegated to the layout manager. If there is no layout, the
	 * default behaviour is to paint the child components in sequence.
	 *
	 * @param renderContext the context to render to.
	 */
	protected void paintComponent(final RenderContext renderContext) {
<span class="fc" id="L675">		Renderer renderer = UIManager.getRenderer(this, renderContext);</span>

<span class="pc bpc" id="L677" title="1 of 4 branches missed.">		if (getTemplate() != null || getTemplateMarkUp() != null) {</span>
<span class="fc" id="L678">			Renderer templateRenderer = UIManager.getTemplateRenderer(renderContext);</span>
<span class="fc" id="L679">			templateRenderer.render(this, renderContext);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">		} else if (renderer == null) {</span>
			// Default is juxtaposition
<span class="fc" id="L682">			List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="fc bfc" id="L684" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc" id="L685">				final int size = children.size();</span>

<span class="fc bfc" id="L687" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L688">					children.get(i).paint(renderContext);</span>
				}
			}
<span class="fc" id="L691">		} else {</span>
<span class="fc" id="L692">			renderer.render(this, renderContext);</span>
		}
<span class="fc" id="L694">	}</span>

	// ================================
	// Validation
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void validate(final List&lt;Diagnostic&gt; diags) {
		// Don't validate if it's invisible.
<span class="fc bfc" id="L704" title="All 2 branches covered.">		if (!isVisible()) {</span>
<span class="fc" id="L705">			return;</span>
		}

		// Also check the validation override flag.
<span class="fc bfc" id="L709" title="All 2 branches covered.">		if (!isValidate()) {</span>
<span class="fc" id="L710">			return;</span>
		}

		// Also don't validate if it's disabled.
<span class="fc bfc" id="L714" title="All 2 branches covered.">		if (this instanceof Disableable) {</span>
<span class="fc" id="L715">			Disableable dis = (Disableable) this;</span>

<span class="fc bfc" id="L717" title="All 2 branches covered.">			if (dis.isDisabled()) {</span>
<span class="fc" id="L718">				return;</span>
			}
		}

		// Also don't validate if it's readonly.
<span class="fc bfc" id="L723" title="All 2 branches covered.">		if (this instanceof Input) {</span>
<span class="fc" id="L724">			Input input = (Input) this;</span>

<span class="fc bfc" id="L726" title="All 2 branches covered.">			if (input.isReadOnly()) {</span>
<span class="fc" id="L727">				return;</span>
			}
		}

		// Validate this component.
<span class="fc" id="L732">		validateComponent(diags);</span>

		// Validate children
<span class="fc" id="L735">		List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">		if (children != null) {</span>
<span class="fc" id="L738">			final int size = children.size();</span>

<span class="fc bfc" id="L740" title="All 2 branches covered.">			for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L741">				children.get(i).validate(diags);</span>
			}
		}
<span class="fc" id="L744">	}</span>

	/**
	 * Subclasses may override to provide validation.
	 *
	 * @param diags the list into which any validation diagnostics are added.
	 */
	protected void validateComponent(final List&lt;Diagnostic&gt; diags) {
		// NOP
<span class="fc" id="L753">	}</span>

	/**
	 * Create and return an error diagnostic associated to this WComponent.
	 *
	 * @param message the error message, using {@link MessageFormat} syntax.
	 * @param args optional arguments for the message.
	 * @return an error diagnostic for this component.
	 */
	protected Diagnostic createErrorDiagnostic(final String message, final Serializable... args) {
<span class="fc" id="L763">		return createErrorDiagnostic(this, message, args);</span>
	}

	/**
	 * Create and return an error diagnostic associated to the given error source.
	 *
	 * @param source the source of the error.
	 * @param message the error message, using {@link MessageFormat} syntax.
	 * @param args optional arguments for the message.
	 * @return an error diagnostic for this component.
	 */
	protected Diagnostic createErrorDiagnostic(final WComponent source, final String message,
			final Serializable... args) {
<span class="fc" id="L776">		return new DiagnosticImpl(Diagnostic.ERROR, source, message, args);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void showErrorIndicators(final List&lt;Diagnostic&gt; diags) {
		// Don't show indicators if it's invisible.
<span class="fc bfc" id="L785" title="All 2 branches covered.">		if (isVisible()) {</span>
			// Show indicators for this component.
<span class="fc" id="L787">			showErrorIndicatorsForComponent(diags);</span>

			// Show indicators for its children.
<span class="fc" id="L790">			List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="fc bfc" id="L792" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc" id="L793">				final int size = children.size();</span>

<span class="fc bfc" id="L795" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L796">					children.get(i).showErrorIndicators(diags);</span>
				}
			}
		}
<span class="fc" id="L800">	}</span>

	/**
	 * &lt;p&gt;
	 * This does not affect the diag list at all. The ValidatableComponent should visually mark any fields or blocks
	 * that have errors in the given diag list.
	 * &lt;/p&gt;
	 *
	 * @param diags the list of diagnostics for this component.
	 */
	protected void showErrorIndicatorsForComponent(final List&lt;Diagnostic&gt; diags) {
		// NOP
<span class="fc" id="L812">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void showWarningIndicators(final List&lt;Diagnostic&gt; diags) {
		// Don't show indicators if it's invisible.
<span class="fc bfc" id="L820" title="All 2 branches covered.">		if (isVisible()) {</span>
			// Show indicators for this component.
<span class="fc" id="L822">			showWarningIndicatorsForComponent(diags);</span>

			// Show indicators for its children.
<span class="fc" id="L825">			List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="fc bfc" id="L827" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc" id="L828">				final int size = children.size();</span>

<span class="fc bfc" id="L830" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L831">					children.get(i).showWarningIndicators(diags);</span>
				}
			}
		}
<span class="fc" id="L835">	}</span>

	/**
	 * &lt;p&gt;
	 * This does not affect the diag list at all. The ValidatableComponent should visually mark any fields or blocks
	 * that have warnings in the given diag list.
	 * &lt;/p&gt;
	 *
	 * @param diags the list of diagnostics for this component.
	 */
	protected void showWarningIndicatorsForComponent(final List&lt;Diagnostic&gt; diags) {
		// NOP
<span class="fc" id="L847">	}</span>

	// ================================
	// Attributes
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setLocked(final boolean lock) {
<span class="fc" id="L856">		this.locked = lock;</span>

<span class="fc bfc" id="L858" title="All 2 branches covered.">		for (int i = 0; i &lt; getChildCount(); i++) {</span>
<span class="fc" id="L859">			getChildAt(i).setLocked(lock);</span>
		}
<span class="fc" id="L861">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isLocked() {
<span class="fc" id="L868">		return locked;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isInitialised() {
<span class="fc" id="L876">		return isFlagSet(ComponentModel.INITIALISED_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setInitialised(final boolean flag) {
<span class="fc" id="L884">		setFlag(ComponentModel.INITIALISED_FLAG, flag);</span>
<span class="fc" id="L885">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isValidate() {
<span class="fc" id="L892">		return isFlagSet(ComponentModel.VALIDATE_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setValidate(final boolean flag) {
<span class="fc" id="L900">		setFlag(ComponentModel.VALIDATE_FLAG, flag);</span>
<span class="fc" id="L901">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isVisible() {
<span class="fc" id="L908">		return isFlagSet(ComponentModel.VISIBLE_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setVisible(final boolean visible) {
<span class="fc" id="L916">		setFlag(ComponentModel.VISIBLE_FLAG, visible);</span>
<span class="fc" id="L917">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isHidden() {
<span class="fc" id="L924">		return isFlagSet(ComponentModel.HIDE_FLAG);</span>
	}

	/**
	 * &lt;p&gt;
	 * Sets the client visibility of this component. Hidden components take part in event handling and painting, but are
	 * not &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#palpable-content-2&quot;&gt;palpable&lt;/a&gt; on the client.
	 * &lt;p&gt;
	 *
	 * @param hidden true for hidden, false for displayed.
	 */
	public void setHidden(final boolean hidden) {
<span class="fc" id="L936">		setFlag(ComponentModel.HIDE_FLAG, hidden);</span>
<span class="fc" id="L937">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setTrackingEnabled(final boolean track) {
<span class="fc" id="L944">		setFlag(ComponentModel.TRACKABLE_FLAG, track);</span>
<span class="fc" id="L945">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isTrackingEnabled() {
<span class="fc" id="L952">		return isFlagSet(ComponentModel.TRACKABLE_FLAG);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isTracking() {
<span class="fc bfc" id="L960" title="All 2 branches covered.">		if (isTrackingEnabled()) {</span>
			// Check if id name set
<span class="fc" id="L962">			String idName = getIdName();</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">			if (idName != null) {</span>
<span class="fc" id="L964">				return true;</span>
			}
<span class="fc" id="L966">			LOG.warn(</span>
<span class="fc" id="L967">					&quot;Trying to track a component that has no id name set. Tracking will be ignored. [&quot; + getId() + &quot; &quot;</span>
<span class="fc" id="L968">					+ this.getClass().getName() + &quot;]&quot;);</span>
		}
<span class="fc" id="L970">		return false;</span>
	}

	/**
	 * Sets or clears one or more component flags in the component model for the given context..
	 *
	 * @param mask the bit mask for the flags to set/clear.
	 * @param flag true to set the flag(s), false to clear.
	 */
	protected void setFlag(final int mask, final boolean flag) {
		// Only store the flag value if it is not the default.
<span class="fc bfc" id="L981" title="All 2 branches covered.">		if (flag != isFlagSet(mask)) {</span>
<span class="fc" id="L982">			ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L983">			model.setFlags(switchFlag(model.getFlags(), mask, flag));</span>
		}
<span class="fc" id="L985">	}</span>

	/**
	 * A utility method to set or clear one or more bits in the given set of flags.
	 *
	 * @param flags the current set of flags.
	 * @param mask the bit mask for the flags to set/clear.
	 * @param value true to set the flag(s), false to clear.
	 * @return the new set of flags.
	 */
	private static int switchFlag(final int flags, final int mask, final boolean value) {
<span class="fc bfc" id="L996" title="All 2 branches covered.">		int newFlags = value ? flags | mask : flags &amp; ~mask;</span>
<span class="fc" id="L997">		return newFlags;</span>
	}

	/**
	 * Indicates whether any of the given flags are set. This is normally used to only check a single flag at a time.
	 *
	 * @param mask the bit mask for the flags to check.
	 * @return true if any flags are set, false otherwise.
	 */
	protected boolean isFlagSet(final int mask) {
<span class="fc" id="L1007">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1008">		return isFlagSet(model.getFlags(), mask);</span>
	}

	/**
	 * A utility method check whether any of the given flags are set. This is normally used to only check a single flag
	 * at a time.
	 *
	 * @param flags the current set of flags.
	 * @param mask the bit mask for the flags to set/clear.
	 * @return true if any flags are set, false otherwise.
	 */
	private static boolean isFlagSet(final int flags, final int mask) {
<span class="fc bfc" id="L1020" title="All 2 branches covered.">		boolean isSet = (flags &amp; mask) != 0;</span>
<span class="fc" id="L1021">		return isSet;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean hasTabIndex() {
<span class="fc" id="L1029">		return false;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public int getTabIndex() {
<span class="fc" id="L1037">		return 0;</span>
	}

	/**
	 * {@inheritDoc}
	 */
	void setLabel(final WLabel label) {
<span class="fc" id="L1044">		getOrCreateComponentModel().setLabel(label);</span>
<span class="fc" id="L1045">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public WLabel getLabel() {
<span class="fc" id="L1052">		return getComponentModel().getLabel();</span>
	}

	// --------------------------------
	// Focus management
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setFocussed() {
<span class="fc" id="L1062">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="fc bfc" id="L1064" title="All 2 branches covered.">		if (uic != null) {</span>
<span class="fc" id="L1065">			uic.setFocussed(this, uic);</span>
		}
<span class="fc" id="L1067">	}</span>

	// --------------------------------
	// Extrinsic state management
	/**
	 * Creates a new model appropriate for the type of component. Subclasses can override, and should narrow the return
	 * type.
	 *
	 * @return a new ComponentModel.
	 */
	protected ComponentModel newComponentModel() {
<span class="fc" id="L1078">		return new ComponentModel();</span>
	}

	/**
	 * &lt;p&gt;
	 * Performs initialisation that is required on this components model, and potentially its children. Subclasses can
	 * override.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * Note that the user's component model will automatically be populated from the shared model.
	 * &lt;/p&gt;
	 */
	protected void initialiseComponentModel() {
		// NOP
<span class="fc" id="L1092">	}</span>

	/**
	 * Check if this component has a model on this user's context.
	 *
	 * @param uic the user context
	 * @return true if has no component model
	 */
	protected boolean hasNoComponentModel(final UIContext uic) {
<span class="fc" id="L1101">		WebModel model = uic.getModel(this);</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">		return model == null;</span>
	}

	/**
	 * Returns the effective component model for this component. Subclass may override this method to narrow the return
	 * type to their specific model type.
	 *
	 * @return the effective component model
	 */
	protected ComponentModel getComponentModel() {
<span class="fc" id="L1112">		UIContext effectiveContext = UIContextHolder.getCurrent();</span>

<span class="fc bfc" id="L1114" title="All 2 branches covered.">		if (effectiveContext == null) {</span>
<span class="fc" id="L1115">			return sharedModel;</span>
		} else {
<span class="fc" id="L1117">			ComponentModel model = (ComponentModel) effectiveContext.getModel(this);</span>

<span class="fc bfc" id="L1119" title="All 2 branches covered.">			if (model == null) {</span>
<span class="fc" id="L1120">				return sharedModel;</span>
<span class="fc bfc" id="L1121" title="All 2 branches covered.">			} else if (model.getSharedModel() == null) {</span>
				// The reference to the sharedModel has disappeared,
				// probably due to session serialization
<span class="fc" id="L1124">				model.setSharedModel(sharedModel);</span>
			}

<span class="fc" id="L1127">			return model;</span>
		}
	}

	/**
	 * Returns the shared component model for this component. Subclass may override this method to narrow the return
	 * type to their specific model type.
	 *
	 * @return the shared component model
	 */
	protected ComponentModel getDefaultModel() {
<span class="fc" id="L1138">		return sharedModel;</span>
	}

	/**
	 * Retrieves the model for this component so that it can be modified. If this method is called during request
	 * processing, and a session specific model does not yet exist, then a new model is created. Subclasses may override
	 * this method to narrow the return type to their specific model type.
	 *
	 * @return the model for this component
	 */
	protected ComponentModel getOrCreateComponentModel() {
<span class="fc" id="L1149">		ComponentModel model = getComponentModel();</span>

<span class="fc bfc" id="L1151" title="All 4 branches covered.">		if (locked &amp;&amp; model == sharedModel) {</span>
<span class="fc" id="L1152">			UIContext effectiveContext = UIContextHolder.getCurrent();</span>

<span class="fc bfc" id="L1154" title="All 2 branches covered.">			if (effectiveContext != null) {</span>
<span class="fc" id="L1155">				model = newComponentModel();</span>
<span class="fc" id="L1156">				model.setSharedModel(sharedModel);</span>

<span class="fc" id="L1158">				effectiveContext.setModel(this, model);</span>
<span class="fc" id="L1159">				initialiseComponentModel();</span>
			}
		}

<span class="fc" id="L1163">		return model;</span>
	}

	/**
	 * &lt;p&gt;
	 * Resets this component and its children to their initial state for the given user context / session.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * &lt;b&gt;NOTE:&lt;/b&gt; The exception to this rule is if this component has been dynamically added to the UI, then the
	 * parent component will differ from the initial state.
	 * &lt;/p&gt;
	 */
	@Override
	public void reset() {
<span class="fc" id="L1177">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="fc bfc" id="L1179" title="All 2 branches covered.">		if (uic != null) {</span>
			// Note: The parent component is stored as a field within AbstractWComponent's
			// component model, which previously caused problems with code like the following:
			//
			// ...
			// WContainer parent = new WContainer();
			// WComponent child = new WTextField();
			// ...
			// parent.add(uic, child);
			// ...
			// child.reset(uic);
			// ...
			//
			// In this scenario, the parent still kept a reference to the child component,
			// but the child component has lost its reference to the parent, which caused
			// ancestor lookups to fail, and duplicate IDs to be generated.
			//
			// This implementation therefore does a top-down reset, clearing this
			// component's model before any child models. This allows child components
			// to correctly check for dynamic parenting in their reset methods and
			// restore the reference to the parent component if necessary.

<span class="fc" id="L1201">			final int childCount = getChildCount();</span>
<span class="fc" id="L1202">			List&lt;WComponent&gt; children = null;</span>

<span class="fc bfc" id="L1204" title="All 2 branches covered.">			if (childCount &gt; 0) {</span>
<span class="fc" id="L1205">				children = new ArrayList&lt;&gt;(getComponentModel().getChildren());</span>
			}

			// Keep a reference to the current (possibly dynamic) parent before it is potentially lost
<span class="fc" id="L1209">			Container dynamicParent = getParent();</span>

			// Reset this component's data first.
<span class="fc" id="L1212">			this.removeComponentModel();</span>
<span class="fc" id="L1213">			uic.clearScratchMap(this);</span>

			// Now reset all descendant components
<span class="fc bfc" id="L1216" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">				for (WComponent child : children) {</span>
<span class="fc" id="L1218">					child.reset();</span>
<span class="fc" id="L1219">				}</span>
			}

			// At this point, everything in the sub-tree where the reset
			// method was initially called has now been reset.
			// If the component was dynamically added
			// and the dynamic parent still has this component as a child
<span class="pc bpc" id="L1226" title="1 of 6 branches missed.">			if (dynamicParent != null &amp;&amp; getParent() != dynamicParent &amp;&amp; getIndexOfChild(</span>
					dynamicParent, this) != -1) {
				// then re-instate the reference to the dynamic parent.
<span class="nc" id="L1229">				getOrCreateComponentModel().setParent(dynamicParent);</span>
			}
		}
<span class="fc" id="L1232">	}</span>

	/**
	 * Reset this component to its initial state.
	 */
	protected void removeComponentModel() {
<span class="fc" id="L1238">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">		if (uic != null) {</span>
<span class="fc" id="L1241">			uic.removeModel(this);</span>
		}
<span class="fc" id="L1243">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void tidyUpUIContextForTree() {
<span class="fc" id="L1250">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">		if (uic != null) {</span>
<span class="fc" id="L1253">			tidyUpUIContext();</span>

<span class="fc" id="L1255">			List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="fc bfc" id="L1257" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc" id="L1258">				final int size = children.size();</span>

<span class="fc bfc" id="L1260" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1261">					children.get(i).tidyUpUIContextForTree();</span>
				}
			}
		}
<span class="fc" id="L1265">	}</span>

	/**
	 * Removes the user-specific component model if this component is in its default state.
	 */
	protected void tidyUpUIContext() {
<span class="fc bfc" id="L1271" title="All 2 branches covered.">		if (isDefaultState()) {</span>
<span class="fc" id="L1272">			removeComponentModel();</span>
		}
<span class="fc" id="L1274">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public boolean isDefaultState() {
<span class="fc" id="L1281">		return getComponentModel().equals(sharedModel);</span>
	}

	// ================================
	// Structure
	/**
	 * @return the number of child components currently contained within this component.
	 */
	int getChildCount() {
<span class="fc" id="L1290">		ComponentModel model = getComponentModel();</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">		return (model.getChildren() == null ? 0 : model.getChildren().size());</span>
	}

	/**
	 * Retrieves a child component by its index.
	 *
	 * @param index the index of the child component to be retrieved.
	 * @return the child component at the given index.
	 */
	WComponent getChildAt(final int index) {
<span class="fc" id="L1301">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1302">		return model.getChildren().get(index);</span>
	}

	/**
	 * Retrieves the index of the given child.
	 *
	 * @param childComponent the child component to retrieve the index for.
	 * @return the index of the given child component, or -1 if the component is not a child of this component.
	 */
	int getIndexOfChild(final WComponent childComponent) {
<span class="fc" id="L1312">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1313">		List&lt;WComponent&gt; children = model.getChildren();</span>

<span class="fc bfc" id="L1315" title="All 2 branches covered.">		return children == null ? -1 : children.indexOf(childComponent);</span>
	}

	/**
	 * Retrieves the children of this component.
	 *
	 * @return a list containing the children of this component, or an empty list.
	 */
	List&lt;WComponent&gt; getChildren() {
<span class="fc" id="L1324">		List&lt;WComponent&gt; children = getComponentModel().getChildren();</span>

<span class="pc bpc" id="L1326" title="1 of 4 branches missed.">		return children != null &amp;&amp; !children.isEmpty()</span>
<span class="fc" id="L1327">				? Collections.unmodifiableList(children)</span>
<span class="fc" id="L1328">				: Collections.&lt;WComponent&gt;emptyList();</span>
	}

	/**
	 * Internal utility method to find the index of a child within a container. This method makes use of the additional
	 * methods offered by the AbstractWComponent implementation (if available), otherwise it falls back the methods
	 * declared in the {@link WComponent} interface.
	 *
	 * @param parent the container to search for the child in
	 * @param childComponent the component to search for.
	 * @return the index of the &lt;code&gt;childComponent&lt;/code&gt; in &lt;code&gt;parent&lt;/code&gt;, or -1 if &lt;code&gt;childComponent&lt;/code&gt;
	 * is not a child of &lt;code&gt;parent&lt;/code&gt;.
	 */
	private static int getIndexOfChild(final Container parent, final WComponent childComponent) {
<span class="pc bpc" id="L1342" title="1 of 2 branches missed.">		if (parent instanceof AbstractWComponent) {</span>
<span class="fc" id="L1343">			return ((AbstractWComponent) parent).getIndexOfChild(childComponent);</span>
		} else {
			// We have to do this the hard way...
<span class="nc bnc" id="L1346" title="All 2 branches missed.">			for (int i = 0; i &lt; parent.getChildCount(); i++) {</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">				if (childComponent == parent.getChildAt(i)) {</span>
<span class="nc" id="L1348">					return i;</span>
				}
			}
		}

<span class="nc" id="L1353">		return -1;</span>
	}

	/**
	 * Adds the given component as a child of this component.
	 *
	 * @param component the component to add.
	 */
	void add(final WComponent component) {
<span class="fc" id="L1362">		assertAddSupported(component);</span>
<span class="fc" id="L1363">		assertNotReparenting(component);</span>

<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">		if (!(this instanceof Container)) {</span>
<span class="nc" id="L1366">			throw new UnsupportedOperationException(&quot;Components can only be added to a container&quot;);</span>
		}

<span class="fc" id="L1369">		ComponentModel model = getOrCreateComponentModel();</span>

<span class="fc bfc" id="L1371" title="All 2 branches covered.">		if (model.getChildren() == null) {</span>
<span class="fc" id="L1372">			model.setChildren(new ArrayList&lt;WComponent&gt;(1));</span>
		}

<span class="fc" id="L1375">		model.getChildren().add(component);</span>

<span class="fc bfc" id="L1377" title="All 2 branches covered.">		if (isLocked()) {</span>
<span class="fc" id="L1378">			component.setLocked(true);</span>
		}

<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">		if (component instanceof AbstractWComponent) {</span>
<span class="fc" id="L1382">			((AbstractWComponent) component).getOrCreateComponentModel().setParent((Container) this);</span>
<span class="fc" id="L1383">			((AbstractWComponent) component).addNotify();</span>
		}
<span class="fc" id="L1385">	}</span>

	/**
	 * Adds the given component as a child of this component. The tag is used to identify the child in a velocity
	 * template.
	 *
	 * @param component the component to add.
	 * @param tag the tag used to identify the component.
	 * @deprecated Use {@link WTemplate} instead.
	 */
	@Deprecated
	void add(final WComponent component, final String tag) {
<span class="fc" id="L1397">		add(component);</span>
<span class="fc" id="L1398">		component.setTag(tag);</span>
<span class="fc" id="L1399">	}</span>

	/**
	 * Some components may wish to throw an Exception if certain types of components can not be added. This
	 * implementation does nothing, and is here so that e.g. sub-classes do not have to override multiple add methods.
	 *
	 * @param componentToAdd the component being added.
	 */
	protected void assertAddSupported(final WComponent componentToAdd) {
		// NOP
<span class="fc" id="L1409">	}</span>

	/**
	 * Removes the given component from this component's list of children.
	 *
	 * @param aChild child component
	 */
	void remove(final WComponent aChild) {
<span class="fc" id="L1417">		ComponentModel model = getOrCreateComponentModel();</span>

<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">		if (model.getChildren() == null) {</span>
<span class="nc" id="L1420">			model.setChildren(copyChildren(getComponentModel().getChildren()));</span>
		}

<span class="fc bfc" id="L1423" title="All 2 branches covered.">		if (model.getChildren().remove(aChild)) {</span>
			// Deallocate children list if possible, to reduce session size.
<span class="fc bfc" id="L1425" title="All 2 branches covered.">			if (model.getChildren().isEmpty()) {</span>
<span class="fc" id="L1426">				model.setChildren(null);</span>
			}

			// The child component has been successfully removed so clean up the context.
<span class="fc" id="L1430">			aChild.reset();</span>

			// If the parent has been set in the shared model, we must override
			// it in the session model for the component to be considered removed.
			// This unfortunately means that the model will remain in the user's session.
<span class="pc bpc" id="L1435" title="1 of 4 branches missed.">			if (aChild.getParent() != null &amp;&amp; aChild instanceof AbstractWComponent) {</span>
<span class="fc" id="L1436">				((AbstractWComponent) aChild).getOrCreateComponentModel().setParent(null);</span>
<span class="fc" id="L1437">				((AbstractWComponent) aChild).removeNotify();</span>
			}
		}
<span class="fc" id="L1440">	}</span>

	/**
	 * Removes all of the children from this component.
	 */
	void removeAll() {
<span class="fc bfc" id="L1446" title="All 2 branches covered.">		while (getChildCount() &gt; 0) {</span>
<span class="fc" id="L1447">			remove(getChildAt(0));</span>
		}
<span class="fc" id="L1449">	}</span>

	/**
	 * Creates a copy of the given list of components.
	 *
	 * @param children the list to copy.
	 * @return a copy of the list.
	 */
	private static List&lt;WComponent&gt; copyChildren(final List&lt;WComponent&gt; children) {
		ArrayList&lt;WComponent&gt; copy;

<span class="nc bnc" id="L1460" title="All 2 branches missed.">		if (children == null) {</span>
<span class="nc" id="L1461">			copy = new ArrayList&lt;&gt;(1);</span>
		} else {
<span class="nc" id="L1463">			copy = new ArrayList&lt;&gt;(children);</span>
		}

<span class="nc" id="L1466">		return copy;</span>
	}

	/**
	 * Ensure that the given component is not about to be re-parented. If it is then this method throws a runtime
	 * exception to inform the developer of their mistake.
	 *
	 * @param component the component to check.
	 */
	private static void assertNotReparenting(final WComponent component) {
<span class="fc bfc" id="L1476" title="All 2 branches covered.">		if (component.getParent() != null) {</span>
<span class="nc" id="L1477">			throwReparentingException();</span>
		}
<span class="fc" id="L1479">	}</span>

	/**
	 * Called when an attempt is made to add a component to more than one parent. Throws a runtime exception.
	 */
	private static void throwReparentingException() {
<span class="fc" id="L1485">		String msg = &quot;Reparenting error. A wcomponent instance can only be added as a child to one parent wcomponent.&quot;;</span>
<span class="fc" id="L1486">		LOG.error(msg);</span>
<span class="fc" id="L1487">		throw new IllegalStateException(msg);</span>
	}

	/**
	 * Notifies this component that it now has a parent component. Subclasses can override this to perform any
	 * additional processing required. The default implementation does nothing.
	 */
	protected void addNotify() {
		// NOP
<span class="fc" id="L1496">	}</span>

	/**
	 * Notifies this component that it no longer has a parent component. Subclasses can override this to perform any
	 * additional processing required. The default implementation does nothing.
	 */
	protected void removeNotify() {
		// NOP
<span class="fc" id="L1504">	}</span>

	/**
	 * @return the current parent of this component.
	 */
	@Override
	public Container getParent() {
<span class="fc" id="L1511">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1512">		return model.getParent();</span>
	}

	// ----------------------------
	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	@Override
	public String getTag() {
<span class="fc" id="L1524">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1525">		return model.getTag();</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	@Override
	public void setTag(final String tag) {
<span class="fc" id="L1536">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1537">		model.setTag(tag);</span>
<span class="fc" id="L1538">	}</span>

	// ================================
	// Environment
	/**
	 * {@inheritDoc}
	 */
	@Override
	public Environment getEnvironment() {
<span class="fc" id="L1547">		UIContext uic = UIContextHolder.getCurrent();</span>
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">		return uic == null ? null : uic.getEnvironment();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setEnvironment(final Environment environment) {
<span class="fc" id="L1556">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">		if (uic != null) {</span>
<span class="fc" id="L1559">			uic.setEnvironment(environment);</span>
		}
<span class="fc" id="L1561">	}</span>

	// ------------------------------
	// Header support
	/**
	 * {@inheritDoc}
	 */
	@Override
	public Headers getHeaders() {
<span class="fc" id="L1570">		UIContext uic = UIContextHolder.getCurrent();</span>

<span class="pc bpc" id="L1572" title="1 of 2 branches missed.">		return uic == null ? null : uic.getHeaders();</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getBaseUrl() {
<span class="fc" id="L1580">		Environment env = getEnvironment();</span>
<span class="fc" id="L1581">		String baseUrl = null;</span>

<span class="pc bpc" id="L1583" title="1 of 2 branches missed.">		if (env != null) {</span>
<span class="fc" id="L1584">			baseUrl = env.getBaseUrl();</span>
		}

<span class="fc bfc" id="L1587" title="All 2 branches covered.">		return (baseUrl == null ? &quot;&quot; : baseUrl);</span>
	}

	// ================================
	// Component Attributes
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setAttribute(final String key, final Serializable value) {
<span class="fc" id="L1597">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1598">		model.setAttribute(key, value);</span>
<span class="fc" id="L1599">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Serializable getAttribute(final String key) {
<span class="fc" id="L1606">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1607">		return model.getAttribute(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Serializable removeAttribute(final String key) {
<span class="fc" id="L1615">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1616">		return model.removeAttribute(key);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setToolTip(final String text, final Serializable... args) {
<span class="fc" id="L1624">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1625">		model.setToolTip(text, args);</span>
<span class="fc" id="L1626">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getToolTip() {
<span class="fc" id="L1633">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1634">		return I18nUtilities.format(null, model.getToolTip());</span>
	}

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated use setToolTip
	 */
	@Override
	public void setAccessibleText(final String text, final Serializable... args) {
<span class="fc" id="L1644">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1645">		model.setAccessibleText(text, args);</span>
<span class="fc" id="L1646">	}</span>

	/**
	 * {@inheritDoc}
	 *
	 * @deprecated use getToolTip
	 */
	@Override
	public String getAccessibleText() {
<span class="fc" id="L1655">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1656">		return I18nUtilities.format(null, model.getAccessibleText());</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setHtmlClass(final String text, final Serializable... args) {
<span class="fc" id="L1664">		ComponentModel model = getOrCreateComponentModel();</span>
<span class="fc" id="L1665">		model.setHtmlClass(text, args);</span>
<span class="fc" id="L1666">	}</span>

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String getHtmlClass() {
<span class="fc" id="L1673">		ComponentModel model = getComponentModel();</span>
<span class="fc" id="L1674">		return I18nUtilities.format(null, model.getHtmlClass());</span>
	}

	// ================================
	// Debugging
	/**
	 * Creates a String representation of this component; usually for debugging purposes.
	 *
	 * @return a String representation of this component.
	 */
	@Override
	public String toString() {
<span class="fc" id="L1686">		return toString(null);</span>
	}

	/**
	 * Creates a String representation of this component, for debugging purposes.
	 *
	 * @param details some additional details to display in the output.
	 * @return a String representation of this component.
	 */
	final String toString(final String details) {
<span class="fc" id="L1696">		return toString(details, 0, getChildCount() - 1);</span>
	}

	/**
	 * Creates a String representation of this component, for debugging purposes.
	 *
	 * @param details some additional details to display in the output
	 * @param childStartIndex the start index of children to include in the output
	 * @param childEndIndex the end index of children to include in the output
	 * @return a String representation of this component
	 */
	final String toString(final String details, final int childStartIndex, final int childEndIndex) {
		// The simple class name will be empty for anonymous subclasses,
		// which is not particularly useful, so we recurse until we find a suitable one.
<span class="fc" id="L1710">		String className = null;</span>

<span class="pc bpc" id="L1712" title="1 of 4 branches missed.">		for (Class&lt;?&gt; clazz = getClass(); Util.empty(className) &amp;&amp; clazz != null; clazz = clazz.</span>
<span class="fc" id="L1713">				getSuperclass()) {</span>
<span class="fc" id="L1714">			className = clazz.getSimpleName();</span>
		}

<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">		StringBuffer buf = new StringBuffer(className == null ? &quot;?&quot; : className);</span>

<span class="fc bfc" id="L1719" title="All 2 branches covered.">		if (!isDefaultState()) {</span>
<span class="fc" id="L1720">			buf.append(&quot;&lt;user model&gt;&quot;);</span>
		}

<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">		buf.append(isVisible() ? &quot;&quot; : &quot;&lt;invisible&gt;&quot;);</span>
<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">		buf.append(!isHidden() ? &quot;&quot; : &quot;&lt;hidden&gt;&quot;);</span>

<span class="fc bfc" id="L1726" title="All 2 branches covered.">		if (this instanceof Disableable) {</span>
<span class="pc bpc" id="L1727" title="1 of 2 branches missed.">			buf.append(!((Disableable) this).isDisabled() ? &quot;&quot; : &quot;&lt;disabled&gt;&quot;);</span>
		}

<span class="fc bfc" id="L1730" title="All 2 branches covered.">		if (details != null) {</span>
<span class="fc" id="L1731">			buf.append('(').append(details).append(')');</span>
		}

<span class="pc bpc" id="L1734" title="1 of 8 branches missed.">		if (this instanceof Container &amp;&amp; childStartIndex &gt;= 0 &amp;&amp; childEndIndex &lt; getChildCount()</span>
				&amp;&amp; childStartIndex &lt;= childEndIndex) {
<span class="fc" id="L1736">			WComponent[] children = new WComponent[childEndIndex - childStartIndex + 1];</span>

<span class="fc bfc" id="L1738" title="All 2 branches covered.">			for (int i = childStartIndex; i &lt;= childEndIndex; i++) {</span>
<span class="fc" id="L1739">				children[i - childStartIndex] = getChildAt(i);</span>
			}

<span class="fc" id="L1742">			buf.append(childrenToString(children));</span>
		}

<span class="fc" id="L1745">		return buf.toString();</span>
	}

	/**
	 * Creates a String representation of a single child component to use with {@link #toString()}..
	 *
	 * @param children the children to output
	 * @return a String representation of the given component.
	 */
	final String childrenToString(final WComponent... children) {
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">		if (!(this instanceof Container)) {</span>
<span class="nc" id="L1756">			return &quot;&quot;;</span>
		}

<span class="pc bpc" id="L1759" title="2 of 4 branches missed.">		if (children == null || children.length == 0) {</span>
<span class="nc" id="L1760">			return &quot;[]&quot;;</span>
		}

<span class="fc" id="L1763">		StringBuffer buf = new StringBuffer(&quot;\n[&quot;);</span>

<span class="fc bfc" id="L1765" title="All 2 branches covered.">		for (int i = 0; i &lt; children.length; i++) {</span>
<span class="fc bfc" id="L1766" title="All 2 branches covered.">			buf.append(i == 0 ? &quot;\n   &quot; : &quot;,\n   &quot;);</span>
<span class="fc" id="L1767">			buf.append(children[i].toString().replaceAll(&quot;\n&quot;, &quot;\n   &quot;));</span>
		}

<span class="fc" id="L1770">		buf.append(&quot;\n]&quot;);</span>
<span class="fc" id="L1771">		return buf.toString();</span>
	}

	// ================================
	// Serialization
	/**
	 * &lt;p&gt;
	 * This class is used to hold a reference to the shared singleton instance of a wcomponent for the purpose of
	 * serialisation. Serialization of WComponent session information is tricky because of the separation of the session
	 * state data (the UIContext) and the shared application definition (the wcompontent stored in the UIRegistry). When
	 * serializing a UIContext, we don't want to serialize the entire shared application definition in each users
	 * session. The problem is that the data stored in the UIContext is keyed using the shared WComponent instances, so
	 * we must convert them all to references in order to prevent the entire application from being serialized.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * This extends WComponent in order to fulfil the readResolve contract, however it overrides writeObject/readObject
	 * to only write out the data needed to find the shared instance.
	 * &lt;/p&gt;
	 *
	 * @author Yiannis Paschalidis
	 */
<span class="fc" id="L1792">	public static final class WComponentRef extends AbstractWComponent {</span>

		/**
		 * The UIRegistry key under which the UI root component is registered. This is assumed to be the fully qualified
		 * class name of the root component.
		 */
		private String repositoryKey;

		/**
		 * The location path of the component in the UI tree, specified as child indices.
		 */
		private int[] nodeLocation;

		/**
		 * Creates a WComponentRef.
		 *
		 * @param repositoryKey the UIRegistry key under which the UI root component is registered.
		 * @param nodeLocation the location of the component in the UI tree.
		 */
<span class="fc" id="L1811">		public WComponentRef(final String repositoryKey, final int[] nodeLocation) {</span>
<span class="fc" id="L1812">			this.repositoryKey = repositoryKey;</span>
<span class="fc" id="L1813">			this.nodeLocation = nodeLocation;</span>
<span class="fc" id="L1814">		}</span>

		/**
		 * Implement writeObject to only write out the repositoryKey and nodeLocation fields.
		 *
		 * @param out the ObjectOutputStream to write to.
		 * @throws IOException if there is an error writing to the stream.
		 * @see java.io.Serializable
		 */
		private void writeObject(final ObjectOutputStream out) throws IOException {
<span class="fc" id="L1824">			out.writeObject(repositoryKey);</span>
<span class="fc" id="L1825">			out.writeInt(nodeLocation.length);</span>

<span class="fc bfc" id="L1827" title="All 2 branches covered.">			for (int i = 0; i &lt; nodeLocation.length; i++) {</span>
<span class="fc" id="L1828">				out.writeInt(nodeLocation[i]);</span>
			}
<span class="fc" id="L1830">		}</span>

		/**
		 * Implement readObject to only read in the repositoryKey and nodeLocation fields.
		 *
		 * @param in the ObjectInputStream to read from.
		 * @throws IOException if there is an error reading from the stream.
		 * @throws ClassNotFoundException if the class can't be found.
		 * @see java.io.Serializable
		 */
		private void readObject(final ObjectInputStream in) throws IOException,
				ClassNotFoundException {
<span class="fc" id="L1842">			repositoryKey = (String) in.readObject();</span>
<span class="fc" id="L1843">			int len = in.readInt();</span>
<span class="fc" id="L1844">			nodeLocation = new int[len];</span>

<span class="fc bfc" id="L1846" title="All 2 branches covered.">			for (int i = 0; i &lt; nodeLocation.length; i++) {</span>
<span class="fc" id="L1847">				nodeLocation[i] = in.readInt();</span>
			}
<span class="fc" id="L1849">		}</span>

		/**
		 * Implement readResolve so that on deserialization, the WComponent that is referred to by this WComponentRef is
		 * returned. The WComponent
		 *
		 * @return the WComponent instance that is registered with the registry.
		 * @throws ObjectStreamException never, but Serializable requires this method signature to declare it.
		 * @see java.io.Serializable
		 */
		private Object readResolve() throws ObjectStreamException {
<span class="pc bpc" id="L1860" title="2 of 4 branches missed.">			if (repositoryKey == null || nodeLocation == null) {</span>
				// Should not happen
<span class="nc" id="L1862">				throw new IllegalStateException(</span>
						&quot;Unable to resolve component in repository '&quot; + repositoryKey + '\'');
			}

<span class="fc" id="L1866">			WComponent comp = UIRegistry.getInstance().getUI(repositoryKey);</span>

<span class="pc bpc" id="L1868" title="1 of 4 branches missed.">			for (int i = 0; comp != null &amp;&amp; i &lt; nodeLocation.length; i++) {</span>
<span class="fc" id="L1869">				comp = ((Container) comp).getChildAt(nodeLocation[i]);</span>
			}

			// Component not found - BAD!
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">			if (comp == null) {</span>
<span class="nc" id="L1874">				throw new IllegalStateException(&quot;Unable to resolve component: &quot; + toString());</span>
			}

<span class="fc" id="L1877">			return comp;</span>
		}

		/**
		 * {@inheritDoc}
		 */
		@Override
		public String toString() {
<span class="nc" id="L1885">			StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L1886">			buf.append(repositoryKey);</span>

<span class="nc bnc" id="L1888" title="All 2 branches missed.">			for (int i = 0; i &lt; nodeLocation.length; i++) {</span>
<span class="nc" id="L1889">				buf.append(',').append(nodeLocation[i]);</span>
			}

<span class="nc" id="L1892">			return buf.toString();</span>
		}
	}

	/**
	 * Implement writeReplace so that on serialization, WComponents that are registered in the UIRegistry write a
	 * reference to the registered component rather than the component itself. This ensures that, on deserialization,
	 * only one copy of the registered component will be present in the VM.
	 *
	 * @return the WComponent instance that is registered with the registry.
	 * @throws ObjectStreamException never, but Serializable requires this method signature to declare it.
	 * @see java.io.Serializable
	 */
	protected Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L1906">		WComponent top = WebUtilities.getTop(this);</span>
<span class="fc" id="L1907">		String repositoryKey = top.getClass().getName();</span>

<span class="fc bfc" id="L1909" title="All 2 branches covered.">		if (UIRegistry.getInstance().isRegistered(repositoryKey)</span>
<span class="pc bpc" id="L1910" title="1 of 2 branches missed.">				&amp;&amp; top == UIRegistry.getInstance().getUI(repositoryKey)) {</span>
			// Calculate the node location.
			// The node location is a list of &quot;shared&quot; child indexes of each
			// ancestor going right back to the top node.
<span class="fc" id="L1914">			ArrayList&lt;Integer&gt; reversedIndexList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1915">			WComponent node = this;</span>
<span class="fc" id="L1916">			Container parent = node.getParent();</span>

			try {
<span class="fc bfc" id="L1919" title="All 2 branches covered.">				while (parent != null) {</span>
<span class="fc" id="L1920">					int index = getIndexOfChild(parent, node);</span>
<span class="fc" id="L1921">					reversedIndexList.add(index);</span>
<span class="fc" id="L1922">					node = parent;</span>
<span class="fc" id="L1923">					parent = node.getParent();</span>
<span class="fc" id="L1924">				}</span>
<span class="nc" id="L1925">			} catch (Exception ex) {</span>
<span class="nc" id="L1926">				LOG.error(&quot;Unable to determine component index relative to top.&quot;, ex);</span>
<span class="fc" id="L1927">			}</span>

<span class="fc" id="L1929">			final int depth = reversedIndexList.size();</span>
<span class="fc" id="L1930">			int[] nodeLocation = new int[depth];</span>

<span class="fc bfc" id="L1932" title="All 2 branches covered.">			for (int i = 0; i &lt; depth; i++) {</span>
<span class="fc" id="L1933">				Integer index = reversedIndexList.get(depth - i - 1);</span>
<span class="fc" id="L1934">				nodeLocation[i] = index.intValue();</span>
			}

<span class="fc" id="L1937">			WComponentRef ref = new WComponentRef(repositoryKey, nodeLocation);</span>

<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1940">				LOG.debug(</span>
<span class="nc" id="L1941">						&quot;WComponent converted to reference. Ref = &quot; + ref + &quot;. Component = &quot; + getClass().</span>
<span class="nc" id="L1942">						getName());</span>
			}

<span class="fc" id="L1945">			return ref;</span>
		} else {
<span class="fc" id="L1947">			LOG.debug(</span>
					&quot;WComponent not accessible via the repository, so it will be serialised. Component = &quot;
<span class="fc" id="L1949">					+ getClass().getName());</span>

<span class="fc" id="L1951">			return this;</span>
		}
	}

	/**
	 * A Utility method which returns the (replaced) serialized form of a WComponent. This method is only exposed for
	 * internal instrumentation (by UicStats).
	 *
	 * @param component the component to serialize.
	 * @return the serialized form of the component.
	 */
	public static Object replaceWComponent(final AbstractWComponent component) {
		try {
<span class="fc" id="L1964">			return component.writeReplace();</span>
<span class="nc" id="L1965">		} catch (ObjectStreamException ignored) {</span>
			// Will not occur, but writeReplace method signature must contain it
<span class="nc" id="L1967">			return component;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>