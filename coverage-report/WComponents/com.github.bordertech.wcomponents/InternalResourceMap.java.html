<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>InternalResourceMap.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">InternalResourceMap.java</span></div><h1>InternalResourceMap.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.util.SystemException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.CRC32;
import java.util.zip.Checksum;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * &lt;p&gt;
 * The ImageResourceMap map keeps a reference to all internal resources within an application. It is used by the
 * WContentHelperServlet to efficiently serve binary data without having to go through normal WComponent processing.&lt;/p&gt;
 *
 * Two things stop this map from consuming excessive amounts of memory:
 * &lt;ol&gt;
 * &lt;li&gt;InternalResources are files which are present in the classpath. There will be a finite set.&lt;/li&gt;
 * &lt;li&gt;The InternalResource implementation does not hold the file data, just a reference to the file.&lt;/li&gt;
 * &lt;/ol&gt;
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
public final class InternalResourceMap {

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L31">	private static final Log LOG = LogFactory.getLog(InternalResourceMap.class);</span>

	/**
	 * The map of internal resources by resource path.
	 */
<span class="fc" id="L36">	private static final Map&lt;String, InternalResource&gt; RESOURCES = new HashMap&lt;&gt;();</span>

	/**
	 * A map of internal resources cache keys by path. This is used to bust the browser cache when a resource changes
	 * after a new deployment of the application.
	 */
<span class="fc" id="L42">	private static final Map&lt;String, String&gt; RESOURCE_CACHE_KEYS = new HashMap&lt;&gt;();</span>

	/**
	 * Hide utility class constructor.
	 */
<span class="nc" id="L47">	private InternalResourceMap() {</span>
<span class="nc" id="L48">	}</span>

	/**
	 * Adds a resource to the resource map.
	 *
	 * @param resource the resource.
	 */
	public static void registerResource(final InternalResource resource) {
<span class="fc" id="L56">		String resourceName = resource.getResourceName();</span>

<span class="fc bfc" id="L58" title="All 2 branches covered.">		if (!RESOURCES.containsKey(resourceName)) {</span>
<span class="fc" id="L59">			RESOURCES.put(resourceName, resource);</span>
<span class="fc" id="L60">			RESOURCE_CACHE_KEYS.put(resourceName, computeHash(resource));</span>
		}
<span class="fc" id="L62">	}</span>

	/**
	 * Retrieves a resource from the resource map.
	 *
	 * @param path the path to the resource.
	 * @return the resource path.
	 */
	public static InternalResource getResource(final String path) {
<span class="nc" id="L71">		return RESOURCES.get(path);</span>
	}

	/**
	 * Retrieves the cache key for a resource path.
	 *
	 * @param path the path to the resource.
	 * @return the resource cache key.
	 */
	public static String getResourceCacheKey(final String path) {
<span class="fc" id="L81">		return RESOURCE_CACHE_KEYS.get(path);</span>
	}

	/**
	 * Computes a simple hash of the resource contents.
	 *
	 * @param resource the resource to hash.
	 * @return a hash of the resource contents.
	 */
	public static String computeHash(final InternalResource resource) {

<span class="pc" id="L92">		try (InputStream stream = resource.getStream()) {</span>

<span class="fc bfc" id="L94" title="All 2 branches covered.">			if (stream == null) {</span>
<span class="fc" id="L95">				return null;</span>
			}

			// Compute CRC-32 checksum
			// TODO: Is a 1 in 2^32 chance of a cache bust fail good enough?
			// Checksum checksumEngine = new Adler32();
<span class="fc" id="L101">			Checksum checksumEngine = new CRC32();</span>
<span class="fc" id="L102">			byte[] buf = new byte[1024];</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">			for (int read = stream.read(buf); read != -1; read = stream.read(buf)) {</span>
<span class="fc" id="L105">				checksumEngine.update(buf, 0, read);</span>
			}

<span class="fc" id="L108">			return Long.toHexString(checksumEngine.getValue());</span>
<span class="pc bpc" id="L109" title="9 of 12 branches missed.">		} catch (Exception e) {</span>
<span class="nc" id="L110">			throw new SystemException(&quot;Error calculating resource hash&quot;, e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>