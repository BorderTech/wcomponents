<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>ComponentModel.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">ComponentModel.java</span></div><h1>ComponentModel.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.ReflectionUtil;
import com.github.bordertech.wcomponents.util.Util;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Holds the extrinsic state information of a WComponent. Subclasses can extend this class and add extra model
 * attributes.
 *
 * &lt;p&gt;
 * Subclasses must adhere to the following rules:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;They must define a public no-args constructor (requirement of {@link Externalizable}).&lt;/li&gt;
 * &lt;li&gt;They must not contain any final fields (needed for initialising from shared model).&lt;/li&gt;
 * &lt;li&gt;They must not contain any non-serializable data.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
<span class="fc" id="L42">public class ComponentModel implements WebModel, Externalizable {</span>

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L47">	private static final Log LOG = LogFactory.getLog(ComponentModel.class);</span>

	/**
	 * Cache fields obtained using ReflectionUtils - HashMap&amp;lt;Class, Field[]&amp;gt;.
	 */
<span class="fc" id="L52">	private static final Map&lt;Class&lt;?&gt;, Field[]&gt; FIELDS_BY_CLASS = new HashMap&lt;&gt;();</span>

	/**
	 * The bit-mask for the flag that indicates whether a component is visible.
	 */
	public static final int VISIBLE_FLAG = 1 &lt;&lt; 0;

	/**
	 * The bit-mask for the flag that indicates whether a component is initialised.
	 */
	public static final int INITIALISED_FLAG = 1 &lt;&lt; 1;

	/**
	 * The bit-mask for the flag that indicates whether a component is disabled.
	 */
	public static final int DISABLED_FLAG = 1 &lt;&lt; 2;

	/**
	 * The bit-mask for the flag that indicates whether a component is read only.
	 */
	public static final int READONLY_FLAG = 1 &lt;&lt; 3;

	/**
	 * The bit-mask for the flag that indicates whether a component is mandatory.
	 */
	public static final int MANDATORY_FLAG = 1 &lt;&lt; 4;

	/**
	 * The bit-mask for the flag that indicates whether a component needs validation.
	 */
	public static final int VALIDATE_FLAG = 1 &lt;&lt; 5;

	/**
	 * The bit-mask for the flag that indicates whether a component is submitted on change/click (client side).
	 */
	public static final int SUBMIT_ON_CHANGE_FLAG = 1 &lt;&lt; 6;

	/**
	 * The bit-mask for the flag that indicates whether a component is rendered as &quot;hidden&quot; on the client side.
	 */
	public static final int HIDE_FLAG = 1 &lt;&lt; 7;

	/**
	 * &lt;p&gt;
	 * The bit-mask for the flag that indicates whether that user data has been set. This is necessary, as some
	 * components do not contain enough values to determine this automatically. For example, WCheckBox only has two
	 * states (on/off), and could already contain two different &quot;default&quot; values from the shared model and a bean.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This bit mask must never be set on a component's shared model.&lt;/p&gt;
	 */
	public static final int USER_DATA_SET = 1 &lt;&lt; 8;

	/**
	 * The bit-mask for the flag that indicates whether a component's text needs to be encoded before output.
	 */
	public static final int ENCODE_TEXT_FLAG = 1 &lt;&lt; 9;

	/**
	 * The bit-mask for the flag that indicates whether a component is trackable via analytics.
	 */
	public static final int TRACKABLE_FLAG = 1 &lt;&lt; 10;

	/**
	 * The bit-mask for the flag that indicates whether a component is a naming context.
	 */
	public static final int NAMING_CONTEXT_FLAG = 1 &lt;&lt; 11;

	/**
	 * The bit-mask for the default set of flags: visible, validation required and text encoded.
	 */
	protected static final int FLAGS_DEFAULT = VISIBLE_FLAG | VALIDATE_FLAG | ENCODE_TEXT_FLAG;

	/**
	 * When initially constructed or deserialized, some of our fields may be defaulted to the shared model, but we don't
	 * yet have a reference to it. When a reference is supplied using the setSharedModel method, this list controls
	 * which fields should have the values set to the shared model's values.
	 */
<span class="fc" id="L130">	private transient List&lt;Field&gt; unsetFields = Arrays.asList(getFields(this));</span>

	/**
	 * A reference to the sharedModel. This is not serialized, and must therefore be supplied after deserialization.
	 */
	private transient ComponentModel sharedModel;

	/**
	 * Are we visible and/or enabled?
	 */
<span class="fc" id="L140">	private int flags = FLAGS_DEFAULT;</span>

	/**
	 * You can override the children on a per session basis. When children is set to null we know there is no override.
	 * An empty array indicates no children.
	 */
	private List&lt;WComponent&gt; children;

	/**
	 * You can override the parent on a per session basis. When PARENT_OVERRIDDEN_FLAG is not set, we know there is no
	 * override. This is important because setting the parent to java null is a valid override.
	 */
	private Container parent;

	/**
	 * Optional tag used to identify the child by the parent. This is particularly good in templating layout managers.
	 */
	private String tag;

	/**
	 * Components can be given an explicit template to render rather than their default output.
	 */
	private String templateUrl;

	/**
	 * Components can be given an explicit template to render rather than their default output.
	 */
	private String templateMarkUp;

	/**
	 * Adds a toolTip to the component. Browsers will display this value when the element is hovered-over or is in
	 * focus.
	 */
	private Serializable toolTip;

	/**
	 * Adds extra textual information to describe a component. This is intended for screen-readers only.
	 * @deprecated use toolTip
	 */
	private Serializable accessibleText;

	/**
	 * Adds extra value to the HTML class of the output component.
	 */
	private Serializable htmlClass;

	/**
	 * General placeholder for subclasses of WComponent to place model attributes. This is mostly for convenience so
	 * that subclasses do not need to extend the &lt;code&gt;ComponentModel&lt;/code&gt; and override the extrinsic state management
	 * (eg, newComponentModel(), etc).
	 */
	private Map&lt;String, Serializable&gt; attributes;

	/**
	 * The label associated with the component.
	 */
	private WLabel label;

	/**
	 * Hold the id name of component.
	 */
	private String idName;

	/**
	 * Hold the id names used in a name context. Used by NamingContext components.
	 */
	private Map&lt;String, WComponent&gt; contextIds;

	/**
	 * Sets an attribute.
	 *
	 * @param key the attribute key
	 * @param value the attribute value
	 */
	public void setAttribute(final String key, final Serializable value) {
<span class="fc bfc" id="L215" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L216">			attributes = new HashMap&lt;&gt;();</span>
		}

<span class="fc" id="L219">		attributes.put(key, value);</span>
<span class="fc" id="L220">	}</span>

	/**
	 * Retrieves an attribute.
	 *
	 * @param key the attribute key
	 * @return the value of the attribute, or null if the attribute does not exist.
	 */
	public Serializable getAttribute(final String key) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L230">			return null;</span>
		}

<span class="fc" id="L233">		return attributes.get(key);</span>
	}

	/**
	 * Removes an attribute.
	 *
	 * @param key the attribute key
	 * @return the value of the attribute that was removed, or null if the attribute did not exist.
	 */
	public Serializable removeAttribute(final String key) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L244">			return null;</span>
		}

<span class="fc" id="L247">		return attributes.remove(key);</span>
	}

	/**
	 * Indicates whether this ComponentModel is equal to the given object.
	 *
	 * Subclasses should not need to override this method, as reflection is used to read in all fields.
	 *
	 * @param obj the object to check for equality.
	 * @return true if the other object is a ComponentModel and is equal to this model.
	 */
	@Override
	public boolean equals(final Object obj) {
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L261">			return false;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">		} else if (obj == this) {</span>
			// Trivial case
<span class="fc" id="L264">			return true;</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">		} else if (!getClass().equals(obj.getClass())) {</span>
			// Can't be equal if we're not the same model class
<span class="nc" id="L267">			return false;</span>
		} else {
			// Check all fields - this saves subclasses having to override
			// equals and remembering to call super.equals.
<span class="fc" id="L271">			final Field[] fields = getFields(this);</span>

			try {
<span class="fc bfc" id="L274" title="All 2 branches covered.">				for (int i = fields.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L275">					Object value = fields[i].get(this);</span>
<span class="fc" id="L276">					Object otherValue = fields[i].get(obj);</span>

<span class="fc bfc" id="L278" title="All 2 branches covered.">					if (!Util.equals(value, otherValue)) {</span>
<span class="fc" id="L279">						return false;</span>
					}
				}
<span class="nc" id="L282">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L283">				LOG.error(&quot;Failed to read field&quot;, e);</span>
<span class="nc" id="L284">				return false;</span>
<span class="fc" id="L285">			}</span>

<span class="fc" id="L287">			return true;</span>
		}
	}

	/**
	 * @return this model's hash code.
	 */
	@Override
	public int hashCode() {
		//TODO: Do we need a better implementation of hashCode using all fields from subclasses?

<span class="nc bnc" id="L298" title="All 2 branches missed.">		return getClass().getName().hashCode()</span>
				+ flags
<span class="nc bnc" id="L300" title="All 2 branches missed.">				+ (children == null ? 0 : children.hashCode())</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">				+ (attributes == null ? 0 : attributes.hashCode())</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">				+ (parent == null ? 0 : parent.hashCode())</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				+ (tag == null ? 0 : tag.hashCode())</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">				+ (toolTip == null ? 0 : toolTip.hashCode())</span>
<span class="nc" id="L305">				+ (templateUrl == null ? 0 : templateUrl.hashCode());</span>
	}

	/**
	 * Sets the shared component model. If there are any unset fields, they are set from the values in the shared model.
	 *
	 * @param sharedModel the shared ComponentModel
	 */
	protected final void setSharedModel(final ComponentModel sharedModel) {
<span class="fc" id="L314">		this.sharedModel = sharedModel;</span>

<span class="pc bpc" id="L316" title="1 of 2 branches missed.">		if (unsetFields != null) {</span>
			// Copy the data from the shared model
<span class="fc bfc" id="L318" title="All 2 branches covered.">			for (Field field : unsetFields) {</span>
				try {
<span class="fc" id="L320">					Object sharedValue = field.get(sharedModel);</span>
<span class="fc" id="L321">					Object sessionValue = copyData(sharedValue);</span>
<span class="fc" id="L322">					field.set(this, sessionValue);</span>
<span class="nc" id="L323">				} catch (IllegalAccessException e) {</span>
<span class="nc" id="L324">					LOG.error(&quot;Failed to set field &quot; + field.getName() + &quot; on &quot; + getClass().</span>
<span class="nc" id="L325">							getName(), e);</span>
<span class="nc" id="L326">				} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L327">					LOG.error(&quot;Failed to set field &quot; + field.getName() + &quot; on &quot; + getClass().</span>
<span class="nc" id="L328">							getName(), e);</span>
<span class="pc" id="L329">				}</span>
<span class="fc" id="L330">			}</span>

<span class="fc" id="L332">			unsetFields = null;</span>
		}
<span class="fc" id="L334">	}</span>

	/**
	 * Creates a copy of mutable data, to ensure updates to one component model do not update the other.
	 *
	 * TODO: We might need to add other collections/arrays later
	 *
	 * @param data the data to copy
	 * @return a copy of the data, if it is mutable, otherwise the original data.
	 */
	protected Object copyData(final Object data) {
		// For mutable objects, we perform a shallow copy
		// so that we don't change the state of the shared value
<span class="fc bfc" id="L347" title="All 2 branches covered.">		if (data instanceof List) {</span>
<span class="fc" id="L348">			return new ArrayList((List) data);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		} else if (data instanceof Hashtable) {</span>
<span class="nc" id="L350">			return new Hashtable((Hashtable) data);</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">		} else if (data instanceof Map) {</span>
<span class="fc" id="L352">			return new HashMap((Map) data);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">		} else if (data instanceof Set) {</span>
<span class="fc" id="L354">			return new HashSet((Set) data);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">		} else if (data instanceof String[]) {</span>
<span class="fc" id="L356">			String[] array = (String[]) data;</span>
<span class="fc" id="L357">			String[] copy = new String[array.length];</span>
<span class="fc" id="L358">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="fc" id="L359">			return copy;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">		} else if (data instanceof int[]) {</span>
<span class="fc" id="L361">			int[] array = (int[]) data;</span>
<span class="fc" id="L362">			int[] copy = new int[array.length];</span>
<span class="fc" id="L363">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="fc" id="L364">			return copy;</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">		} else if (data instanceof long[]) {</span>
<span class="nc" id="L366">			long[] array = (long[]) data;</span>
<span class="nc" id="L367">			long[] copy = new long[array.length];</span>
<span class="nc" id="L368">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L369">			return copy;</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">		} else if (data instanceof float[]) {</span>
<span class="nc" id="L371">			float[] array = (float[]) data;</span>
<span class="nc" id="L372">			float[] copy = new float[array.length];</span>
<span class="nc" id="L373">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L374">			return copy;</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">		} else if (data instanceof double[]) {</span>
<span class="nc" id="L376">			double[] array = (double[]) data;</span>
<span class="nc" id="L377">			double[] copy = new double[array.length];</span>
<span class="nc" id="L378">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L379">			return copy;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">		} else if (data instanceof boolean[]) {</span>
<span class="nc" id="L381">			boolean[] array = (boolean[]) data;</span>
<span class="nc" id="L382">			boolean[] copy = new boolean[array.length];</span>
<span class="nc" id="L383">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L384">			return copy;</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">		} else if (data instanceof char[]) {</span>
<span class="nc" id="L386">			char[] array = (char[]) data;</span>
<span class="nc" id="L387">			char[] copy = new char[array.length];</span>
<span class="nc" id="L388">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L389">			return copy;</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">		} else if (data instanceof Object[]) {</span>
<span class="nc" id="L391">			Class&lt;?&gt; componentClass = data.getClass().getComponentType();</span>
<span class="nc" id="L392">			Object[] copy = (Object[]) Array.newInstance(componentClass, ((Object[]) data).length);</span>
<span class="nc" id="L393">			System.arraycopy(data, 0, copy, 0, copy.length);</span>
<span class="nc" id="L394">			return copy;</span>
		}

<span class="fc" id="L397">		return data;</span>
	}

	/**
	 * @return Returns the attributes.
	 */
	protected Map&lt;String, Serializable&gt; getAttributes() {
<span class="nc" id="L404">		return attributes;</span>
	}

	/**
	 * @param attributes The attributes to set.
	 */
	protected void setAttributes(final Map&lt;String, Serializable&gt; attributes) {
<span class="nc" id="L411">		this.attributes = attributes;</span>
<span class="nc" id="L412">	}</span>

	/**
	 * @return Returns the children.
	 */
	protected List&lt;WComponent&gt; getChildren() {
<span class="fc" id="L418">		return children;</span>
	}

	/**
	 * @param children The children to set.
	 */
	protected void setChildren(final List&lt;WComponent&gt; children) {
<span class="fc" id="L425">		this.children = children;</span>
<span class="fc" id="L426">	}</span>

	/**
	 * @return Returns the flags.
	 */
	protected int getFlags() {
<span class="fc" id="L432">		return flags;</span>
	}

	/**
	 * @param flags The flags to set.
	 */
	protected void setFlags(final int flags) {
<span class="fc" id="L439">		this.flags = flags;</span>
<span class="fc" id="L440">	}</span>

	/**
	 * @return Returns the parent.
	 */
	protected Container getParent() {
<span class="fc" id="L446">		return parent;</span>
	}

	/**
	 * @param parent The parent to set.
	 */
	protected void setParent(final Container parent) {
<span class="fc" id="L453">		this.parent = parent;</span>
<span class="fc" id="L454">	}</span>

	/**
	 * @return Returns the tag.
	 */
	protected String getTag() {
<span class="fc" id="L460">		return tag;</span>
	}

	/**
	 * @param tag The tag to set.
	 */
	protected void setTag(final String tag) {
<span class="fc" id="L467">		this.tag = tag;</span>
<span class="fc" id="L468">	}</span>

	/**
	 * @return Returns the templateUrl.
	 */
	public String getTemplateUrl() {
<span class="fc" id="L474">		return templateUrl;</span>
	}

	/**
	 * @param templateUrl The templateUrl to set.
	 */
	public void setTemplateUrl(final String templateUrl) {
<span class="fc" id="L481">		this.templateUrl = templateUrl;</span>
<span class="fc" id="L482">	}</span>

	/**
	 * @return Returns the template mark-up.
	 */
	public String getTemplateMarkUp() {
<span class="fc" id="L488">		return templateMarkUp;</span>
	}

	/**
	 * @param templateMarkUp The template mark-up to set.
	 */
	public void setTemplateMarkUp(final String templateMarkUp) {
<span class="nc" id="L495">		this.templateMarkUp = templateMarkUp;</span>
<span class="nc" id="L496">	}</span>

	/**
	 * @return Returns the tool tip text.
	 */
	protected Serializable getToolTip() {
<span class="fc" id="L502">		return toolTip;</span>
	}

	/**
	 * @param text The tool tip to set.
	 * @param args optional message format arguments.
	 */
	protected void setToolTip(final String text, final Serializable... args) {
<span class="fc" id="L510">		this.toolTip = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L511">	}</span>

	/**
	 * @return Returns the accessible text.
	 * @deprecated use getToolTip
	 */
	protected Serializable getAccessibleText() {
<span class="fc" id="L518">		return accessibleText;</span>
	}

	/**
	 * @param text The accessible text to set.
	 * @param args optional message format arguments.
	 * @deprecated use setToolTip
	 */
	protected void setAccessibleText(final String text, final Serializable... args) {
<span class="fc" id="L527">		this.accessibleText = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L528">	}</span>

	/**
	 * @return Returns the HTML class.
	 */
	protected Serializable getHtmlClass() {
<span class="fc" id="L534">		return htmlClass;</span>
	}

	/**
	 * @param text The HTML class name text to set.
	 * @param args optional message format arguments.
	 */
	protected void setHtmlClass(final String text, final Serializable... args) {
<span class="fc" id="L542">		this.htmlClass = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L543">	}</span>

	/**
	 * @return the label associated with this component.
	 */
	public WLabel getLabel() {
<span class="fc" id="L549">		return label;</span>
	}

	/**
	 * Sets the label associated with this component.
	 *
	 * @param label the label to associate with this component.
	 */
	public void setLabel(final WLabel label) {
<span class="fc" id="L558">		this.label = label;</span>
<span class="fc" id="L559">	}</span>

	/**
	 * @return Returns the sharedModel.
	 */
	protected ComponentModel getSharedModel() {
<span class="fc" id="L565">		return sharedModel;</span>
	}

	/**
	 * @return the id name.
	 */
	protected String getIdName() {
<span class="fc" id="L572">		return idName;</span>
	}

	/**
	 * @param idName the id name to set.
	 */
	protected void setIdName(final String idName) {
<span class="fc" id="L579">		this.idName = idName;</span>
<span class="fc" id="L580">	}</span>

	/**
	 * @return the map of registered ids for the naming context
	 */
	protected Map&lt;String, WComponent&gt; getContextIds() {
<span class="fc" id="L586">		return this.contextIds;</span>
	}

	/**
	 * @param contextIds the map holding the registered ids for the naming context
	 */
	protected void setContextIds(final Map&lt;String, WComponent&gt; contextIds) {
<span class="fc" id="L593">		this.contextIds = contextIds;</span>
<span class="fc" id="L594">	}</span>

	/**
	 * &lt;p&gt;
	 * Implementation of the Externalizable interface to ensure that we don't serialize redundant data (anything
	 * contained by the {@link #sharedModel}.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Data is obtained using reflection so that subclasses don't need concern themselves with the ComponentModel
	 * serialization mechanism.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * After the ComponentModel data is read in, some fields may be in a &quot;unset&quot; state. The static model needs to be
	 * supplied using {@link #setSharedModel(ComponentModel)}
	 *
	 * @param in the ObjectInput to read from.
	 *
	 * @throws IOException if there is an error reading from the ObjectInput
	 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
	 */
	@Override
	public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {
<span class="fc" id="L616">		Field[] fields = getFields(this);</span>
<span class="fc" id="L617">		unsetFields = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L619" title="All 2 branches covered.">		for (Field field : fields) {</span>
			try {
<span class="fc" id="L621">				Object value = in.readObject();</span>

<span class="fc bfc" id="L623" title="All 2 branches covered.">				if (value instanceof NoOverride) {</span>
					// No override, so remember for later
<span class="fc" id="L625">					unsetFields.add(field);</span>
				} else {
<span class="fc" id="L627">					field.set(this, value);</span>
				}
<span class="nc" id="L629">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L630">				LOG.error(&quot;Failed to read field &quot; + field.getName(), e);</span>
<span class="fc" id="L631">			}</span>
		}
<span class="fc" id="L633">	}</span>

	/**
	 * &lt;p&gt;
	 * Implementation of the Externalizable interface to ensure that we don't serialize redundant data (anything
	 * contained by the {@link #sharedModel}.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Data is obtained using reflection so that subclasses don't need concern themselves with the ComponentModel
	 * serialization mechanism.&lt;/p&gt;
	 *
	 * @param out the ObjectOutput to write to.
	 *
	 * @throws IOException if there is an error writing to the ObjectOutput
	 */
	@Override
	public void writeExternal(final ObjectOutput out) throws IOException {
<span class="fc" id="L650">		Field[] fields = getFields(this);</span>

<span class="fc bfc" id="L652" title="All 2 branches covered.">		for (Field field : fields) {</span>
			try {
<span class="fc bfc" id="L654" title="All 2 branches covered.">				if (sharedModel == null) {</span>
					// Support serialization of the static model,
					// even though this should not occur.
<span class="fc" id="L657">					Object value = field.get(this);</span>
<span class="fc" id="L658">					out.writeObject(value);</span>
<span class="pc bpc" id="L659" title="3 of 4 branches missed.">				} else if (unsetFields != null &amp;&amp; unsetFields.contains(field)) {</span>
					// Support the unlikely case being deserialized/serialized
					// in short succession without the shared model being set.
<span class="nc" id="L662">					out.writeObject(NoOverride.INSTANCE);</span>
				} else {
<span class="fc" id="L664">					Object sharedValue = field.get(sharedModel);</span>
<span class="fc" id="L665">					Object value = field.get(this);</span>

<span class="fc bfc" id="L667" title="All 2 branches covered.">					if (Util.equals(value, sharedValue)) {</span>
<span class="fc" id="L668">						out.writeObject(NoOverride.INSTANCE);</span>
					} else {
<span class="fc" id="L670">						out.writeObject(value);</span>
					}
				}
<span class="nc" id="L673">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L674">				LOG.error(&quot;Failed to write field &quot; + field.getName(), e);</span>
<span class="fc" id="L675">			}</span>
		}
<span class="fc" id="L677">	}</span>

	/**
	 * Returns the list of fields for the given ComponentModel.
	 *
	 * @param model the ComponentModel to read fields for.
	 * @return an array of fields for the given model.
	 */
	private static Field[] getFields(final ComponentModel model) {
<span class="fc" id="L686">		Class modelClass = model.getClass();</span>
		Field[] fields;

<span class="fc" id="L689">		synchronized (FIELDS_BY_CLASS) {</span>
<span class="fc" id="L690">			fields = FIELDS_BY_CLASS.get(modelClass);</span>

<span class="fc bfc" id="L692" title="All 2 branches covered.">			if (fields == null) {</span>
<span class="fc" id="L693">				List fieldList = ReflectionUtil.getAllFields(model, true, true);</span>
<span class="fc" id="L694">				Collections.sort(fieldList, new FieldComparator());</span>

<span class="fc" id="L696">				fields = (Field[]) fieldList.toArray(new Field[fieldList.size()]);</span>
<span class="fc" id="L697">				FIELDS_BY_CLASS.put(modelClass, fields);</span>
			}
<span class="pc" id="L699">		}</span>

<span class="fc" id="L701">		return fields;</span>
	}

	/**
	 * When serializing the model, we need to be distinguish a null override of the static model's value vs a field that
	 * hasn't been written because it hasn't been overridden. This object is used as a marker.
	 *
	 * @author Yiannis Paschalidis
	 */
	private static final class NoOverride implements Serializable {

		/**
		 * Singleton instance.
		 */
<span class="fc" id="L715">		public static final NoOverride INSTANCE = new NoOverride();</span>

		/**
		 * Don't allow instantiation from outside of this class.
		 */
<span class="fc" id="L720">		private NoOverride() {</span>
<span class="fc" id="L721">		}</span>
	}

	/**
	 * The reflection API doesn't guarantee that fields will be returned in any particular order. To ensure that fields
	 * are deserialized in the same order that they were serialized, we need to sort the field list.
	 *
	 * @author Yiannis Paschalidis
	 */
<span class="fc" id="L730">	private static final class FieldComparator implements Comparator&lt;Field&gt;, Serializable {</span>

		/**
		 * Compares two objects for order. Returns a negative integer, zero, or a positive integer as the first object
		 * is less than, equal to, or greater than the second.&lt;p&gt;
		 *
		 * @param field1 the first field to compare.
		 * @param field2 the second field to compare.
		 * @return a negative integer, zero, or a positive integer as the first object is less than, equal to, or
		 * greater than the second.
		 */
		@Override
		public int compare(final Field field1, final Field field2) {
<span class="fc" id="L743">			String field1Str = field1.getDeclaringClass().getName() + '.' + field1.getName();</span>
<span class="fc" id="L744">			String field2Str = field2.getDeclaringClass().getName() + '.' + field2.getName();</span>

<span class="fc" id="L746">			return field1Str.compareTo(field2Str);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>