<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>ComponentModel.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents</a> &gt; <span class="el_source">ComponentModel.java</span></div><h1>ComponentModel.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents;

import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.ReflectionUtil;
import com.github.bordertech.wcomponents.util.Util;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Holds the extrinsic state information of a WComponent. Subclasses can extend this class and add extra model
 * attributes.
 *
 * &lt;p&gt;
 * Subclasses must adhere to the following rules:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;They must define a public no-args constructor (requirement of {@link Externalizable}).&lt;/li&gt;
 * &lt;li&gt;They must not contain any final fields (needed for initialising from shared model).&lt;/li&gt;
 * &lt;li&gt;They must not contain any non-serializable data.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Yiannis Paschalidis
 * @since 1.0.0
 */
<span class="fc" id="L42">public class ComponentModel implements WebModel, Externalizable {</span>

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L47">	private static final Log LOG = LogFactory.getLog(ComponentModel.class);</span>

	/**
	 * Cache fields obtained using ReflectionUtils - HashMap&amp;lt;Class, Field[]&amp;gt;.
	 */
<span class="fc" id="L52">	private static final Map&lt;Class&lt;?&gt;, Field[]&gt; FIELDS_BY_CLASS = new HashMap&lt;&gt;();</span>

	/**
	 * The bit-mask for the flag that indicates whether a component is visible.
	 */
	public static final int VISIBLE_FLAG = 1 &lt;&lt; 0;

	/**
	 * The bit-mask for the flag that indicates whether a component is initialised.
	 */
	public static final int INITIALISED_FLAG = 1 &lt;&lt; 1;

	/**
	 * The bit-mask for the flag that indicates whether a component is disabled.
	 */
	public static final int DISABLED_FLAG = 1 &lt;&lt; 2;

	/**
	 * The bit-mask for the flag that indicates whether a component is read only.
	 */
	public static final int READONLY_FLAG = 1 &lt;&lt; 3;

	/**
	 * The bit-mask for the flag that indicates whether a component is mandatory.
	 */
	public static final int MANDATORY_FLAG = 1 &lt;&lt; 4;

	/**
	 * The bit-mask for the flag that indicates whether a component needs validation.
	 */
	public static final int VALIDATE_FLAG = 1 &lt;&lt; 5;

	/**
	 * The bit-mask for the flag that indicates whether a component is submitted on change/click (client side).
	 */
	public static final int SUBMIT_ON_CHANGE_FLAG = 1 &lt;&lt; 6;

	/**
	 * The bit-mask for the flag that indicates whether a component is rendered as &quot;hidden&quot; on the client side.
	 */
	public static final int HIDE_FLAG = 1 &lt;&lt; 7;

	/**
	 * &lt;p&gt;
	 * The bit-mask for the flag that indicates whether that user data has been set. This is necessary, as some
	 * components do not contain enough values to determine this automatically. For example, WCheckBox only has two
	 * states (on/off), and could already contain two different &quot;default&quot; values from the shared model and a bean.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This bit mask must never be set on a component's shared model.&lt;/p&gt;
	 */
	public static final int USER_DATA_SET = 1 &lt;&lt; 8;

	/**
	 * The bit-mask for the flag that indicates whether a component's text needs to be encoded before output.
	 */
	public static final int ENCODE_TEXT_FLAG = 1 &lt;&lt; 9;

	/**
	 * The bit-mask for the flag that indicates whether a component is trackable via analytics.
	 */
	public static final int TRACKABLE_FLAG = 1 &lt;&lt; 10;

	/**
	 * The bit-mask for the flag that indicates whether a component is a naming context.
	 */
	public static final int NAMING_CONTEXT_FLAG = 1 &lt;&lt; 11;

	/**
	 * The bit-mask for the default set of flags: visible, validation required and text encoded.
	 */
	protected static final int FLAGS_DEFAULT = VISIBLE_FLAG | VALIDATE_FLAG | ENCODE_TEXT_FLAG;

	/**
	 * When initially constructed or deserialized, some of our fields may be defaulted to the shared model, but we don't
	 * yet have a reference to it. When a reference is supplied using the setSharedModel method, this list controls
	 * which fields should have the values set to the shared model's values.
	 */
<span class="fc" id="L130">	private transient List&lt;Field&gt; unsetFields = Arrays.asList(getFields(this));</span>

	/**
	 * A reference to the sharedModel. This is not serialized, and must therefore be supplied after deserialization.
	 */
	private transient ComponentModel sharedModel;

	/**
	 * Are we visible and/or enabled?
	 */
<span class="fc" id="L140">	private int flags = FLAGS_DEFAULT;</span>

	/**
	 * You can override the children on a per session basis. When children is set to null we know there is no override.
	 * An empty array indicates no children.
	 */
	private List&lt;WComponent&gt; children;

	/**
	 * You can override the parent on a per session basis. When PARENT_OVERRIDDEN_FLAG is not set, we know there is no
	 * override. This is important because setting the parent to java null is a valid override.
	 */
	private Container parent;

	/**
	 * Optional tag used to identify the child by the parent. This is particularly good in templating layout managers.
	 */
	private String tag;

	/**
	 * Components can be given an explicit template to render rather than their default output.
	 */
	private String templateUrl;

	/**
	 * Components can be given an explicit template to render rather than their default output.
	 */
	private String templateMarkUp;

	/**
	 * Adds a toolTip to the component. Browsers will display this value when the element is hovered-over or is in
	 * focus.
	 */
	private Serializable toolTip;

	/**
	 * Adds extra textual information to describe a component. This is intended for screen-readers only.
	 *
	 * @deprecated use toolTip
	 */
	private Serializable accessibleText;

	/**
	 * Adds extra value to the HTML class of the output component.
	 */
	private Serializable htmlClass;

	/**
	 * General placeholder for subclasses of WComponent to place model attributes. This is mostly for convenience so
	 * that subclasses do not need to extend the &lt;code&gt;ComponentModel&lt;/code&gt; and override the extrinsic state management
	 * (eg, newComponentModel(), etc).
	 */
	private Map&lt;String, Serializable&gt; attributes;

	/**
	 * The label associated with the component.
	 */
	private WLabel label;

	/**
	 * Hold the id name of component.
	 */
	private String idName;

	/**
	 * Hold the id names used in a name context. Used by NamingContext components.
	 */
	private Map&lt;String, WComponent&gt; contextIds;

	/**
	 * Sets an attribute.
	 *
	 * @param key the attribute key
	 * @param value the attribute value
	 */
	public void setAttribute(final String key, final Serializable value) {
<span class="fc bfc" id="L216" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L217">			attributes = new HashMap&lt;&gt;();</span>
		}

<span class="fc" id="L220">		attributes.put(key, value);</span>
<span class="fc" id="L221">	}</span>

	/**
	 * Retrieves an attribute.
	 *
	 * @param key the attribute key
	 * @return the value of the attribute, or null if the attribute does not exist.
	 */
	public Serializable getAttribute(final String key) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L231">			return null;</span>
		}

<span class="fc" id="L234">		return attributes.get(key);</span>
	}

	/**
	 * Removes an attribute.
	 *
	 * @param key the attribute key
	 * @return the value of the attribute that was removed, or null if the attribute did not exist.
	 */
	public Serializable removeAttribute(final String key) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">		if (attributes == null) {</span>
<span class="fc" id="L245">			return null;</span>
		}

<span class="fc" id="L248">		return attributes.remove(key);</span>
	}

	/**
	 * Indicates whether this ComponentModel is equal to the given object.
	 *
	 * Subclasses should not need to override this method, as reflection is used to read in all fields.
	 *
	 * @param obj the object to check for equality.
	 * @return true if the other object is a ComponentModel and is equal to this model.
	 */
	@Override
	public boolean equals(final Object obj) {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">		if (obj == null) {</span>
<span class="nc" id="L262">			return false;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">		} else if (obj == this) {</span>
			// Trivial case
<span class="fc" id="L265">			return true;</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">		} else if (!getClass().equals(obj.getClass())) {</span>
			// Can't be equal if we're not the same model class
<span class="nc" id="L268">			return false;</span>
		} else {
			// Check all fields - this saves subclasses having to override
			// equals and remembering to call super.equals.
<span class="fc" id="L272">			final Field[] fields = getFields(this);</span>

			try {
<span class="fc bfc" id="L275" title="All 2 branches covered.">				for (int i = fields.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L276">					Object value = fields[i].get(this);</span>
<span class="fc" id="L277">					Object otherValue = fields[i].get(obj);</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">					if (!Util.equals(value, otherValue)) {</span>
<span class="fc" id="L280">						return false;</span>
					}
				}
<span class="nc" id="L283">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L284">				LOG.error(&quot;Failed to read field&quot;, e);</span>
<span class="nc" id="L285">				return false;</span>
<span class="fc" id="L286">			}</span>

<span class="fc" id="L288">			return true;</span>
		}
	}

	/**
	 * @return this model's hash code.
	 */
	@Override
	public int hashCode() {
		//TODO: Do we need a better implementation of hashCode using all fields from subclasses?

<span class="nc bnc" id="L299" title="All 2 branches missed.">		return getClass().getName().hashCode()</span>
				+ flags
<span class="nc bnc" id="L301" title="All 2 branches missed.">				+ (children == null ? 0 : children.hashCode())</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">				+ (attributes == null ? 0 : attributes.hashCode())</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				+ (parent == null ? 0 : parent.hashCode())</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">				+ (tag == null ? 0 : tag.hashCode())</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">				+ (toolTip == null ? 0 : toolTip.hashCode())</span>
<span class="nc" id="L306">				+ (templateUrl == null ? 0 : templateUrl.hashCode());</span>
	}

	/**
	 * Sets the shared component model. If there are any unset fields, they are set from the values in the shared model.
	 *
	 * @param sharedModel the shared ComponentModel
	 */
	protected final void setSharedModel(final ComponentModel sharedModel) {
<span class="fc" id="L315">		this.sharedModel = sharedModel;</span>

<span class="pc bpc" id="L317" title="1 of 2 branches missed.">		if (unsetFields != null) {</span>
			// Copy the data from the shared model
<span class="fc bfc" id="L319" title="All 2 branches covered.">			for (Field field : unsetFields) {</span>
				try {
<span class="fc" id="L321">					Object sharedValue = field.get(sharedModel);</span>
<span class="fc" id="L322">					Object sessionValue = copyData(sharedValue);</span>
<span class="fc" id="L323">					field.set(this, sessionValue);</span>
<span class="nc" id="L324">				} catch (IllegalAccessException e) {</span>
<span class="nc" id="L325">					LOG.error(&quot;Failed to set field &quot; + field.getName() + &quot; on &quot; + getClass().</span>
<span class="nc" id="L326">							getName(), e);</span>
<span class="nc" id="L327">				} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L328">					LOG.error(&quot;Failed to set field &quot; + field.getName() + &quot; on &quot; + getClass().</span>
<span class="nc" id="L329">							getName(), e);</span>
<span class="pc" id="L330">				}</span>
<span class="fc" id="L331">			}</span>

<span class="fc" id="L333">			unsetFields = null;</span>
		}
<span class="fc" id="L335">	}</span>

	/**
	 * Creates a copy of mutable data, to ensure updates to one component model do not update the other.
	 *
	 * @param data the data to copy
	 * @return a copy of the data, if it is mutable, otherwise the original data.
	 */
	protected Object copyData(final Object data) {
		// For mutable objects, we perform a shallow copy
		// so that we don't change the state of the shared value
<span class="fc bfc" id="L346" title="All 2 branches covered.">		if (data instanceof List) {</span>
<span class="fc" id="L347">			return new ArrayList((List) data);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">		} else if (data instanceof Hashtable) {</span>
<span class="nc" id="L349">			return new Hashtable((Hashtable) data);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">		} else if (data instanceof Map) {</span>
<span class="fc" id="L351">			return new HashMap((Map) data);</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">		} else if (data instanceof Set) {</span>
<span class="fc" id="L353">			return new HashSet((Set) data);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">		} else if (data instanceof String[]) {</span>
<span class="fc" id="L355">			String[] array = (String[]) data;</span>
<span class="fc" id="L356">			String[] copy = new String[array.length];</span>
<span class="fc" id="L357">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="fc" id="L358">			return copy;</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">		} else if (data instanceof int[]) {</span>
<span class="fc" id="L360">			int[] array = (int[]) data;</span>
<span class="fc" id="L361">			int[] copy = new int[array.length];</span>
<span class="fc" id="L362">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="fc" id="L363">			return copy;</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">		} else if (data instanceof long[]) {</span>
<span class="nc" id="L365">			long[] array = (long[]) data;</span>
<span class="nc" id="L366">			long[] copy = new long[array.length];</span>
<span class="nc" id="L367">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L368">			return copy;</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">		} else if (data instanceof float[]) {</span>
<span class="nc" id="L370">			float[] array = (float[]) data;</span>
<span class="nc" id="L371">			float[] copy = new float[array.length];</span>
<span class="nc" id="L372">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L373">			return copy;</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">		} else if (data instanceof double[]) {</span>
<span class="nc" id="L375">			double[] array = (double[]) data;</span>
<span class="nc" id="L376">			double[] copy = new double[array.length];</span>
<span class="nc" id="L377">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L378">			return copy;</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		} else if (data instanceof boolean[]) {</span>
<span class="nc" id="L380">			boolean[] array = (boolean[]) data;</span>
<span class="nc" id="L381">			boolean[] copy = new boolean[array.length];</span>
<span class="nc" id="L382">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L383">			return copy;</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">		} else if (data instanceof char[]) {</span>
<span class="nc" id="L385">			char[] array = (char[]) data;</span>
<span class="nc" id="L386">			char[] copy = new char[array.length];</span>
<span class="nc" id="L387">			System.arraycopy(array, 0, copy, 0, copy.length);</span>
<span class="nc" id="L388">			return copy;</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">		} else if (data instanceof Object[]) {</span>
<span class="nc" id="L390">			Class&lt;?&gt; componentClass = data.getClass().getComponentType();</span>
<span class="nc" id="L391">			Object[] copy = (Object[]) Array.newInstance(componentClass, ((Object[]) data).length);</span>
<span class="nc" id="L392">			System.arraycopy(data, 0, copy, 0, copy.length);</span>
<span class="nc" id="L393">			return copy;</span>
		}

<span class="fc" id="L396">		return data;</span>
	}

	/**
	 * @return Returns the attributes.
	 */
	protected Map&lt;String, Serializable&gt; getAttributes() {
<span class="nc" id="L403">		return attributes;</span>
	}

	/**
	 * @param attributes The attributes to set.
	 */
	protected void setAttributes(final Map&lt;String, Serializable&gt; attributes) {
<span class="nc" id="L410">		this.attributes = attributes;</span>
<span class="nc" id="L411">	}</span>

	/**
	 * @return Returns the children.
	 */
	protected List&lt;WComponent&gt; getChildren() {
<span class="fc" id="L417">		return children;</span>
	}

	/**
	 * @param children The children to set.
	 */
	protected void setChildren(final List&lt;WComponent&gt; children) {
<span class="fc" id="L424">		this.children = children;</span>
<span class="fc" id="L425">	}</span>

	/**
	 * @return Returns the flags.
	 */
	protected int getFlags() {
<span class="fc" id="L431">		return flags;</span>
	}

	/**
	 * @param flags The flags to set.
	 */
	protected void setFlags(final int flags) {
<span class="fc" id="L438">		this.flags = flags;</span>
<span class="fc" id="L439">	}</span>

	/**
	 * @return Returns the parent.
	 */
	protected Container getParent() {
<span class="fc" id="L445">		return parent;</span>
	}

	/**
	 * @param parent The parent to set.
	 */
	protected void setParent(final Container parent) {
<span class="fc" id="L452">		this.parent = parent;</span>
<span class="fc" id="L453">	}</span>

	/**
	 * @return Returns the tag.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	protected String getTag() {
<span class="fc" id="L461">		return tag;</span>
	}

	/**
	 * @param tag The tag to set.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	protected void setTag(final String tag) {
<span class="fc" id="L470">		this.tag = tag;</span>
<span class="fc" id="L471">	}</span>

	/**
	 * @return Returns the templateUrl.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public String getTemplateUrl() {
<span class="fc" id="L479">		return templateUrl;</span>
	}

	/**
	 * @param templateUrl The templateUrl to set.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public void setTemplateUrl(final String templateUrl) {
<span class="fc" id="L488">		this.templateUrl = templateUrl;</span>
<span class="fc" id="L489">	}</span>

	/**
	 * @return Returns the template mark-up.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public String getTemplateMarkUp() {
<span class="fc" id="L497">		return templateMarkUp;</span>
	}

	/**
	 * @param templateMarkUp The template mark-up to set.
	 * @deprecated Use {@link WTemplate} instead
	 */
	@Deprecated
	public void setTemplateMarkUp(final String templateMarkUp) {
<span class="nc" id="L506">		this.templateMarkUp = templateMarkUp;</span>
<span class="nc" id="L507">	}</span>

	/**
	 * @return Returns the tool tip text.
	 */
	protected Serializable getToolTip() {
<span class="fc" id="L513">		return toolTip;</span>
	}

	/**
	 * @param text The tool tip to set.
	 * @param args optional message format arguments.
	 */
	protected void setToolTip(final String text, final Serializable... args) {
<span class="fc" id="L521">		this.toolTip = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L522">	}</span>

	/**
	 * @return Returns the accessible text.
	 * @deprecated use getToolTip
	 */
	protected Serializable getAccessibleText() {
<span class="fc" id="L529">		return accessibleText;</span>
	}

	/**
	 * @param text The accessible text to set.
	 * @param args optional message format arguments.
	 * @deprecated use setToolTip
	 */
	protected void setAccessibleText(final String text, final Serializable... args) {
<span class="fc" id="L538">		this.accessibleText = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L539">	}</span>

	/**
	 * @return Returns the HTML class.
	 */
	protected Serializable getHtmlClass() {
<span class="fc" id="L545">		return htmlClass;</span>
	}

	/**
	 * @param text The HTML class name text to set.
	 * @param args optional message format arguments.
	 */
	protected void setHtmlClass(final String text, final Serializable... args) {
<span class="fc" id="L553">		this.htmlClass = I18nUtilities.asMessage(text, args);</span>
<span class="fc" id="L554">	}</span>

	/**
	 * @return the label associated with this component.
	 */
	public WLabel getLabel() {
<span class="fc" id="L560">		return label;</span>
	}

	/**
	 * Sets the label associated with this component.
	 *
	 * @param label the label to associate with this component.
	 */
	public void setLabel(final WLabel label) {
<span class="fc" id="L569">		this.label = label;</span>
<span class="fc" id="L570">	}</span>

	/**
	 * @return Returns the sharedModel.
	 */
	protected ComponentModel getSharedModel() {
<span class="fc" id="L576">		return sharedModel;</span>
	}

	/**
	 * @return the id name.
	 */
	protected String getIdName() {
<span class="fc" id="L583">		return idName;</span>
	}

	/**
	 * @param idName the id name to set.
	 */
	protected void setIdName(final String idName) {
<span class="fc" id="L590">		this.idName = idName;</span>
<span class="fc" id="L591">	}</span>

	/**
	 * @return the map of registered ids for the naming context
	 */
	protected Map&lt;String, WComponent&gt; getContextIds() {
<span class="fc" id="L597">		return this.contextIds;</span>
	}

	/**
	 * @param contextIds the map holding the registered ids for the naming context
	 */
	protected void setContextIds(final Map&lt;String, WComponent&gt; contextIds) {
<span class="fc" id="L604">		this.contextIds = contextIds;</span>
<span class="fc" id="L605">	}</span>

	/**
	 * &lt;p&gt;
	 * Implementation of the Externalizable interface to ensure that we don't serialize redundant data (anything
	 * contained by the {@link #sharedModel}.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Data is obtained using reflection so that subclasses don't need concern themselves with the ComponentModel
	 * serialization mechanism.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * After the ComponentModel data is read in, some fields may be in a &quot;unset&quot; state. The static model needs to be
	 * supplied using {@link #setSharedModel(ComponentModel)}
	 *
	 * @param in the ObjectInput to read from.
	 *
	 * @throws IOException if there is an error reading from the ObjectInput
	 * @throws ClassNotFoundException If the class of a serialized object cannot be found.
	 */
	@Override
	public void readExternal(final ObjectInput in) throws IOException, ClassNotFoundException {
<span class="fc" id="L627">		Field[] fields = getFields(this);</span>
<span class="fc" id="L628">		unsetFields = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L630" title="All 2 branches covered.">		for (Field field : fields) {</span>
			try {
<span class="fc" id="L632">				Object value = in.readObject();</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">				if (value instanceof NoOverride) {</span>
					// No override, so remember for later
<span class="fc" id="L636">					unsetFields.add(field);</span>
				} else {
<span class="fc" id="L638">					field.set(this, value);</span>
				}
<span class="nc" id="L640">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L641">				LOG.error(&quot;Failed to read field &quot; + field.getName(), e);</span>
<span class="fc" id="L642">			}</span>
		}
<span class="fc" id="L644">	}</span>

	/**
	 * &lt;p&gt;
	 * Implementation of the Externalizable interface to ensure that we don't serialize redundant data (anything
	 * contained by the {@link #sharedModel}.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Data is obtained using reflection so that subclasses don't need concern themselves with the ComponentModel
	 * serialization mechanism.&lt;/p&gt;
	 *
	 * @param out the ObjectOutput to write to.
	 *
	 * @throws IOException if there is an error writing to the ObjectOutput
	 */
	@Override
	public void writeExternal(final ObjectOutput out) throws IOException {
<span class="fc" id="L661">		Field[] fields = getFields(this);</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">		for (Field field : fields) {</span>
			try {
<span class="fc bfc" id="L665" title="All 2 branches covered.">				if (sharedModel == null) {</span>
					// Support serialization of the static model,
					// even though this should not occur.
<span class="fc" id="L668">					Object value = field.get(this);</span>
<span class="fc" id="L669">					out.writeObject(value);</span>
<span class="pc bpc" id="L670" title="3 of 4 branches missed.">				} else if (unsetFields != null &amp;&amp; unsetFields.contains(field)) {</span>
					// Support the unlikely case being deserialized/serialized
					// in short succession without the shared model being set.
<span class="nc" id="L673">					out.writeObject(NoOverride.INSTANCE);</span>
				} else {
<span class="fc" id="L675">					Object sharedValue = field.get(sharedModel);</span>
<span class="fc" id="L676">					Object value = field.get(this);</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">					if (Util.equals(value, sharedValue)) {</span>
<span class="fc" id="L679">						out.writeObject(NoOverride.INSTANCE);</span>
					} else {
<span class="fc" id="L681">						out.writeObject(value);</span>
					}
				}
<span class="nc" id="L684">			} catch (IllegalAccessException e) {</span>
<span class="nc" id="L685">				LOG.error(&quot;Failed to write field &quot; + field.getName(), e);</span>
<span class="fc" id="L686">			}</span>
		}
<span class="fc" id="L688">	}</span>

	/**
	 * Returns the list of fields for the given ComponentModel.
	 *
	 * @param model the ComponentModel to read fields for.
	 * @return an array of fields for the given model.
	 */
	private static Field[] getFields(final ComponentModel model) {
<span class="fc" id="L697">		Class modelClass = model.getClass();</span>
		Field[] fields;

<span class="fc" id="L700">		synchronized (FIELDS_BY_CLASS) {</span>
<span class="fc" id="L701">			fields = FIELDS_BY_CLASS.get(modelClass);</span>

<span class="fc bfc" id="L703" title="All 2 branches covered.">			if (fields == null) {</span>
<span class="fc" id="L704">				List fieldList = ReflectionUtil.getAllFields(model, true, true);</span>
<span class="fc" id="L705">				Collections.sort(fieldList, new FieldComparator());</span>

<span class="fc" id="L707">				fields = (Field[]) fieldList.toArray(new Field[fieldList.size()]);</span>
<span class="fc" id="L708">				FIELDS_BY_CLASS.put(modelClass, fields);</span>
			}
<span class="pc" id="L710">		}</span>

<span class="fc" id="L712">		return fields;</span>
	}

	/**
	 * When serializing the model, we need to be distinguish a null override of the static model's value vs a field that
	 * hasn't been written because it hasn't been overridden. This object is used as a marker.
	 *
	 * @author Yiannis Paschalidis
	 */
	private static final class NoOverride implements Serializable {

		/**
		 * Singleton instance.
		 */
<span class="fc" id="L726">		public static final NoOverride INSTANCE = new NoOverride();</span>

		/**
		 * Don't allow instantiation from outside of this class.
		 */
<span class="fc" id="L731">		private NoOverride() {</span>
<span class="fc" id="L732">		}</span>
	}

	/**
	 * The reflection API doesn't guarantee that fields will be returned in any particular order. To ensure that fields
	 * are deserialized in the same order that they were serialized, we need to sort the field list.
	 *
	 * @author Yiannis Paschalidis
	 */
<span class="fc" id="L741">	private static final class FieldComparator implements Comparator&lt;Field&gt;, Serializable {</span>

		/**
		 * Compares two objects for order. Returns a negative integer, zero, or a positive integer as the first object
		 * is less than, equal to, or greater than the second.&lt;p&gt;
		 *
		 * @param field1 the first field to compare.
		 * @param field2 the second field to compare.
		 * @return a negative integer, zero, or a positive integer as the first object is less than, equal to, or
		 * greater than the second.
		 */
		@Override
		public int compare(final Field field1, final Field field2) {
<span class="fc" id="L754">			String field1Str = field1.getDeclaringClass().getName() + '.' + field1.getName();</span>
<span class="fc" id="L755">			String field2Str = field2.getDeclaringClass().getName() + '.' + field2.getName();</span>

<span class="fc" id="L757">			return field1Str.compareTo(field2Str);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>