<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../resources/report.gif" type="image/gif"/><title>ServletUtil.java</title><link rel="stylesheet" href="../../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">WComponents Coverage</a> &gt; <a href="../index.html" class="el_bundle">WComponents</a> &gt; <a href="index.source.html" class="el_package">com.github.bordertech.wcomponents.servlet</a> &gt; <span class="el_source">ServletUtil.java</span></div><h1>ServletUtil.java</h1><pre class="source lang-java linenums">package com.github.bordertech.wcomponents.servlet;

import com.github.bordertech.wcomponents.AjaxHelper;
import com.github.bordertech.wcomponents.Environment;
import com.github.bordertech.wcomponents.InternalResource;
import com.github.bordertech.wcomponents.InternalResourceMap;
import com.github.bordertech.wcomponents.UIContext;
import com.github.bordertech.wcomponents.WComponent;
import com.github.bordertech.wcomponents.WContent;
import com.github.bordertech.wcomponents.WebUtilities;
import com.github.bordertech.wcomponents.container.AjaxCleanupInterceptor;
import com.github.bordertech.wcomponents.container.AjaxDebugStructureInterceptor;
import com.github.bordertech.wcomponents.container.AjaxErrorInterceptor;
import com.github.bordertech.wcomponents.container.AjaxInterceptor;
import com.github.bordertech.wcomponents.container.AjaxPageShellInterceptor;
import com.github.bordertech.wcomponents.container.AjaxSetupInterceptor;
import com.github.bordertech.wcomponents.container.ContextCleanupInterceptor;
import com.github.bordertech.wcomponents.container.DataListInterceptor;
import com.github.bordertech.wcomponents.container.DebugStructureInterceptor;
import com.github.bordertech.wcomponents.container.FormInterceptor;
import com.github.bordertech.wcomponents.container.InterceptorComponent;
import com.github.bordertech.wcomponents.container.PageShellInterceptor;
import com.github.bordertech.wcomponents.container.ResponseCacheInterceptor;
import com.github.bordertech.wcomponents.container.ResponseCacheInterceptor.CacheType;
import com.github.bordertech.wcomponents.container.SessionTokenAjaxInterceptor;
import com.github.bordertech.wcomponents.container.SessionTokenContentInterceptor;
import com.github.bordertech.wcomponents.container.SessionTokenInterceptor;
import com.github.bordertech.wcomponents.container.SubordinateControlInterceptor;
import com.github.bordertech.wcomponents.container.TargetableErrorInterceptor;
import com.github.bordertech.wcomponents.container.TargetableInterceptor;
import com.github.bordertech.wcomponents.container.TransformXMLInterceptor;
import com.github.bordertech.wcomponents.container.UIContextDumpInterceptor;
import com.github.bordertech.wcomponents.container.ValidateXMLInterceptor;
import com.github.bordertech.wcomponents.container.WWindowInterceptor;
import com.github.bordertech.wcomponents.container.WhitespaceFilterInterceptor;
import com.github.bordertech.wcomponents.container.WrongStepAjaxInterceptor;
import com.github.bordertech.wcomponents.container.WrongStepContentInterceptor;
import com.github.bordertech.wcomponents.container.WrongStepServerInterceptor;
import com.github.bordertech.wcomponents.util.Config;
import com.github.bordertech.wcomponents.util.I18nUtilities;
import com.github.bordertech.wcomponents.util.InternalMessages;
import com.github.bordertech.wcomponents.util.RequestUtil;
import com.github.bordertech.wcomponents.util.StreamUtil;
import com.github.bordertech.wcomponents.util.SystemException;
import com.github.bordertech.wcomponents.util.ThemeUtil;
import com.github.bordertech.wcomponents.util.Util;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Utility class to provide http servlet functionality.
 *
 * @author Jonathan Austin
 * @since 1.0.0
 */
public final class ServletUtil {

	/**
	 * Don't let anyone instantiate this class.
	 */
<span class="nc" id="L79">	private ServletUtil() {</span>
<span class="nc" id="L80">	}</span>

	/**
	 * The logger instance for this class.
	 */
<span class="fc" id="L85">	private static final Log LOG = LogFactory.getLog(ServletUtil.class);</span>

	/**
	 * Theme resource path parameter.
	 */
	private static final String THEME_RESOURCE_PATH_PARAM = &quot;/&quot; + Environment.THEME_RESOURCE_PATH_NAME + &quot;/&quot;;

	/**
	 * The parameters extracted from multi part saved on the request.
	 */
	private static final String REQUEST_PARAMETERS_KEY = &quot;wc_req_params&quot;;

	/**
	 * The parameters extracted from multi part saved on the request.
	 */
	private static final String REQUEST_FILES_KEY = &quot;wc_req_files&quot;;

	/**
	 * The flag that the request has been processed allowing for multi part forms.
	 */
	private static final String REQUEST_PROCESSED_KEY = &quot;wc_req_processed&quot;;

	/**
	 * The key used to look up the {@link Config WComponent Configuration} flag for whether we should use enable
	 * sub-session support.
	 */
	public static final String ENABLE_SUBSESSIONS = &quot;bordertech.wcomponents.servlet.subsessions.enabled&quot;;

	/**
	 * The key used to look up the {@link Config WComponent Configuration} flag for developer mode error handling.
	 */
	public static final String DEVELOPER_MODE_ERROR_HANDLING = &quot;bordertech.wcomponents.developer.errorHandling.enabled&quot;;

	/**
	 * The key used to look up the {@link Config WComponent Configuration} flag for whether we should use the
	 * ErrorPageFactory.
	 */
<span class="fc" id="L122">	public static final String HANDLE_ERROR_WITH_FATAL_ERROR_PAGE_FACTORY = WServlet.class.getName()</span>
			+ &quot;.handleErrorWithFatalErrorPageFactory&quot;;

	/**
	 * @return true if enable sub sessions
	 */
	public static boolean isEnableSubSessions() {
<span class="fc" id="L129">		boolean enableSubSessions = Config.getInstance().getBoolean(ENABLE_SUBSESSIONS, false);</span>
<span class="fc" id="L130">		return enableSubSessions;</span>
	}

	/**
	 * Check if the request is for a resource (eg static, theme...).
	 *
	 * @param request the http servlet request.
	 * @param response the http servlet response.
	 * @return true to continue processing
	 * @throws ServletException a servlet exception
	 * @throws IOException an IO Exception
	 */
	public static boolean checkResourceRequest(final HttpServletRequest request,
			final HttpServletResponse response)
			throws ServletException, IOException {
		// Static resource
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">		if (isStaticResourceRequest(request)) {</span>
<span class="nc" id="L147">			handleStaticResourceRequest(request, response);</span>
<span class="nc" id="L148">			return false;</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">		} else if (isThemeResourceRequest(request)) {  // Theme resource</span>
<span class="nc" id="L150">			handleThemeResourceRequest(request, response);</span>
<span class="nc" id="L151">			return false;</span>
		}

<span class="fc" id="L154">		String method = request.getMethod();</span>

<span class="fc bfc" id="L156" title="All 2 branches covered.">		if (&quot;HEAD&quot;.equals(method)) {</span>
<span class="fc" id="L157">			response.setContentType(WebUtilities.CONTENT_TYPE_XML);</span>
<span class="fc" id="L158">			return false;</span>
<span class="fc bfc" id="L159" title="All 4 branches covered.">		} else if (!&quot;POST&quot;.equals(method) &amp;&amp; !&quot;GET&quot;.equals(method)) {</span>
<span class="fc" id="L160">			response.setStatus(HttpServletResponse.SC_NOT_IMPLEMENTED);</span>
<span class="fc" id="L161">			return false;</span>
		}

<span class="fc" id="L164">		return true;</span>
	}

	/**
	 * This method does the real work in servicing the http request. It integrates wcomponents into a servlet
	 * environment via a servlet specific helper class.
	 *
	 * @param helper the servlet helper
	 * @param ui the application ui
	 * @param interceptorChain the chain of interceptors
	 * @throws ServletException a servlet exception
	 * @throws IOException an IO Exception
	 */
	public static void processRequest(final HttpServletHelper helper, final WComponent ui,
			final InterceptorComponent interceptorChain) throws ServletException, IOException {

		try {
			// Tell the support container about the top most web component
			// that will service the request/response.
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">			if (interceptorChain == null) {</span>
<span class="nc" id="L184">				helper.setWebComponent(ui);</span>
			} else {
<span class="fc" id="L186">				interceptorChain.attachUI(ui);</span>
<span class="fc" id="L187">				helper.setWebComponent(interceptorChain);</span>
			}

			// Prepare user context
<span class="fc" id="L191">			UIContext uic = helper.prepareUserContext();</span>

<span class="fc" id="L193">			synchronized (uic) {</span>
				// Process the action phase.
<span class="fc" id="L195">				helper.processAction();</span>

				// Process the render phase.
<span class="fc" id="L198">				helper.render();</span>
<span class="pc" id="L199">			}</span>
		} finally {
			// We need to ensure that the AJAX operation is cleared
			// The interceptors can not guarantee this
			// TODO: Investigate changing to not use a thread-local
<span class="pc" id="L204">			AjaxHelper.clearCurrentOperationDetails();</span>
<span class="fc" id="L205">		}</span>
<span class="fc" id="L206">	}</span>

	/**
	 * @param req the request being processed
	 * @return true if requesting a static resource
	 */
	public static boolean isStaticResourceRequest(final HttpServletRequest req) {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">		return req.getParameter(WServlet.STATIC_RESOURCE_PARAM_NAME) != null;</span>
	}

	/**
	 * Handles a request for static resources.
	 *
	 * @param request the http request.
	 * @param response the http response.
	 */
	public static void handleStaticResourceRequest(final HttpServletRequest request,
			final HttpServletResponse response) {
<span class="nc" id="L224">		String staticRequest = request.getParameter(WServlet.STATIC_RESOURCE_PARAM_NAME);</span>

		try {
<span class="nc" id="L227">			InternalResource staticResource = InternalResourceMap.getResource(staticRequest);</span>
<span class="nc" id="L228">			boolean headersOnly = &quot;HEAD&quot;.equals(request.getMethod());</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">			if (staticResource == null) {</span>
<span class="nc" id="L231">				LOG.warn(&quot;Static resource [&quot; + staticRequest + &quot;] not found.&quot;);</span>
<span class="nc" id="L232">				response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L233">				return;</span>
			}

<span class="nc" id="L236">			InputStream resourceStream = staticResource.getStream();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">			if (resourceStream == null) {</span>
<span class="nc" id="L238">				LOG.warn(</span>
						&quot;Static resource [&quot; + staticRequest + &quot;] not found. Stream for content is null.&quot;);
<span class="nc" id="L240">				response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L241">				return;</span>
			}

<span class="nc" id="L244">			int size = resourceStream.available();</span>
<span class="nc" id="L245">			String fileName = WebUtilities.encodeForContentDispositionHeader(staticRequest.</span>
<span class="nc" id="L246">					substring(staticRequest</span>
<span class="nc" id="L247">							.lastIndexOf('/') + 1));</span>

<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (size &gt; 0) {</span>
<span class="nc" id="L250">				response.setContentLength(size);</span>
			}

<span class="nc" id="L253">			response.setContentType(WebUtilities.getContentType(staticRequest));</span>
<span class="nc" id="L254">			response.setHeader(&quot;Cache-Control&quot;, CacheType.CONTENT_CACHE.getSettings());</span>

<span class="nc" id="L256">			String param = request.getParameter(WContent.URL_CONTENT_MODE_PARAMETER_KEY);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			if (&quot;inline&quot;.equals(param)) {</span>
<span class="nc" id="L258">				response.setHeader(&quot;Content-Disposition&quot;, &quot;inline; filename=&quot; + fileName);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">			} else if (&quot;attach&quot;.equals(param)) {</span>
<span class="nc" id="L260">				response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + fileName);</span>
			} else {
				// added &quot;filename=&quot; to comply with https://tools.ietf.org/html/rfc6266
<span class="nc" id="L263">				response.setHeader(&quot;Content-Disposition&quot;, &quot;filename=&quot; + fileName);</span>
			}

<span class="nc bnc" id="L266" title="All 2 branches missed.">			if (!headersOnly) {</span>
<span class="nc" id="L267">				StreamUtil.copy(resourceStream, response.getOutputStream());</span>
			}
<span class="nc" id="L269">		} catch (IOException e) {</span>
<span class="nc" id="L270">			LOG.warn(&quot;Could not process static resource [&quot; + staticRequest + &quot;]. &quot;, e);</span>
<span class="nc" id="L271">			response.reset();</span>
<span class="nc" id="L272">			response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="nc" id="L273">		}</span>
<span class="nc" id="L274">	}</span>

	/**
	 * @param req the request being processed
	 * @return true if requesting a theme resource
	 */
	public static boolean isThemeResourceRequest(final HttpServletRequest req) {
<span class="fc" id="L281">		String path = req.getPathInfo();</span>
<span class="pc bpc" id="L282" title="3 of 4 branches missed.">		return path != null &amp;&amp; path.startsWith(THEME_RESOURCE_PATH_PARAM);</span>
	}

	/**
	 * Serves up a file from the theme. In practice it is generally a bad idea to use this servlet to serve up static
	 * resources. Instead it would make more sense to move CSS, JS, HTML resources to a CDN or similar.
	 *
	 *
	 * @param req the request with the file name in parameter &quot;f&quot;, or following the servlet path.
	 * @param resp the response to write to.
	 * @throws ServletException on error.
	 * @throws IOException if there is an error reading the file / writing the response.
	 */
	public static void handleThemeResourceRequest(final HttpServletRequest req,
			final HttpServletResponse resp)
			throws ServletException, IOException {

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (req.getHeader(&quot;If-Modified-Since&quot;) != null) {</span>
<span class="nc" id="L300">			resp.reset();</span>
<span class="nc" id="L301">			resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span>
<span class="nc" id="L302">			return;</span>
		}

<span class="fc" id="L305">		String fileName = req.getParameter(&quot;f&quot;);</span>

<span class="fc" id="L307">		String path = req.getPathInfo();</span>
<span class="pc bpc" id="L308" title="1 of 4 branches missed.">		if (fileName == null &amp;&amp; !Util.empty(path)) {</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">			int offset = path.startsWith(THEME_RESOURCE_PATH_PARAM) ? THEME_RESOURCE_PATH_PARAM.</span>
<span class="pc" id="L310">					length() : 1;</span>
<span class="fc" id="L311">			fileName = path.substring(offset);</span>
		}

<span class="pc bpc" id="L314" title="1 of 4 branches missed.">		if (fileName == null || !checkThemeFile(fileName)) {</span>
<span class="fc" id="L315">			resp.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
<span class="fc" id="L316">			return;</span>
		}

<span class="fc" id="L319">		InputStream resourceStream = null;</span>

		try {
<span class="fc" id="L322">			String resourceName = ThemeUtil.getThemeBase() + fileName;</span>
<span class="fc" id="L323">			URL url = ServletUtil.class.getResource(resourceName);</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">			if (url == null) {</span>
<span class="fc" id="L326">				resp.setStatus(HttpServletResponse.SC_NOT_FOUND);</span>
			} else {
<span class="fc" id="L328">				URLConnection connection = url.openConnection();</span>
<span class="fc" id="L329">				resourceStream = connection.getInputStream();</span>
<span class="fc" id="L330">				int size = resourceStream.available();</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">				if (size &gt; 0) {</span>
<span class="fc" id="L332">					resp.setContentLength(size);</span>
				}

				/*
				I have commented out the setting of the Content-Disposition on static theme resources because, well why is it there?
				If this needs to be reinstated please provide a thorough justification comment here so the reasons are clear.

				Note that setting this header breaks Polymer 1.0 when it is present on HTML imports.

				String encodedName = WebUtilities.encodeForContentDispositionHeader(fileName.
						substring(fileName
								.lastIndexOf('/') + 1));
				resp.setHeader(&quot;Content-Disposition&quot;, &quot;filename=&quot; + encodedName);  // &quot;filename=&quot; to comply with https://tools.ietf.org/html/rfc6266
				 */
<span class="fc" id="L346">				resp.setContentType(WebUtilities.getContentType(fileName));</span>
<span class="fc" id="L347">				resp.setHeader(&quot;Cache-Control&quot;, CacheType.THEME_CACHE.getSettings());</span>

<span class="fc" id="L349">				resp.setHeader(&quot;Expires&quot;, &quot;31536000&quot;);</span>
<span class="fc" id="L350">				resp.setHeader(&quot;ETag&quot;, &quot;\&quot;&quot; + WebUtilities.getProjectVersion() + &quot;\&quot;&quot;);</span>
				// resp.setHeader(&quot;Last-Modified&quot;, &quot;Mon, 02 Jan 2015 01:00:00 GMT&quot;);
<span class="fc" id="L352">				long modified = connection.getLastModified();</span>
<span class="fc" id="L353">				resp.setDateHeader(&quot;Last-Modified&quot;, modified);</span>
<span class="fc" id="L354">				StreamUtil.copy(resourceStream, resp.getOutputStream());</span>
			}
		} finally {
<span class="pc" id="L357">			StreamUtil.safeClose(resourceStream);</span>
<span class="fc" id="L358">		}</span>
<span class="fc" id="L359">	}</span>

	/**
	 * Performs basic sanity checks on the file being requested.
	 *
	 * @param name the file name
	 * @return true if the requested file name is ok, false if not.
	 */
	private static boolean checkThemeFile(final String name) {
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">		return !(Util.empty(name) // name must exist</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">				|| name.contains(&quot;..&quot;) // prevent directory traversal</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">				|| name.charAt(0) == '/' // all theme references should be relative</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">				|| name.indexOf(':') != -1 // forbid use of protocols such as jar:, http: etc.</span>
				);
	}

	/**
	 * Creates a new interceptor chain to handle the given request.
	 *
	 * @param request the request to handle
	 * @return a new interceptor chain for the request.
	 */
	public static InterceptorComponent createInterceptorChain(final HttpServletRequest request) {

		// Allow for multi part parameters
<span class="fc" id="L384">		Map&lt;String, String[]&gt; parameters = getRequestParameters(request);</span>

		InterceptorComponent[] chain;

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">		if (parameters.get(WServlet.DATA_LIST_PARAM_NAME) != null) { // Datalist</span>
<span class="nc" id="L389">			chain = new InterceptorComponent[]{new DataListInterceptor()};</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">		} else if (parameters.get(WServlet.AJAX_TRIGGER_PARAM_NAME) != null) { // AJAX</span>
<span class="nc" id="L392">			chain = new InterceptorComponent[]{</span>
				new AjaxErrorInterceptor(),
				new SessionTokenAjaxInterceptor(),
				new ResponseCacheInterceptor(CacheType.NO_CACHE),
				new UIContextDumpInterceptor(),
				new AjaxSetupInterceptor(),
				new WWindowInterceptor(true),
				new WrongStepAjaxInterceptor(),
				new ContextCleanupInterceptor(),
				new TransformXMLInterceptor(),
				new ValidateXMLInterceptor(),
				new WhitespaceFilterInterceptor(),
				new SubordinateControlInterceptor(),
				new AjaxPageShellInterceptor(),
				new AjaxDebugStructureInterceptor(),
				new AjaxInterceptor()};

<span class="pc bpc" id="L409" title="1 of 2 branches missed.">		} else if (parameters.get(WServlet.TARGET_ID_PARAM_NAME) != null) { // Targetted Content</span>
<span class="nc" id="L410">			chain = new InterceptorComponent[]{</span>
				new TargetableErrorInterceptor(),
				new SessionTokenContentInterceptor(),
				new UIContextDumpInterceptor(),
				new TargetableInterceptor(),
				new WWindowInterceptor(false),
				new WrongStepContentInterceptor()};

		} else {
<span class="fc" id="L419">			chain = new InterceptorComponent[]{ // Page submit</span>
				new SessionTokenInterceptor(),
				new ResponseCacheInterceptor(CacheType.NO_CACHE),
				new UIContextDumpInterceptor(),
				new WWindowInterceptor(true),
				new WrongStepServerInterceptor(),
				new AjaxCleanupInterceptor(),
				new ContextCleanupInterceptor(),
				new TransformXMLInterceptor(),
				new ValidateXMLInterceptor(),
				new WhitespaceFilterInterceptor(),
				new SubordinateControlInterceptor(),
				new PageShellInterceptor(),
				new FormInterceptor(),
				new DebugStructureInterceptor()};
		}

		// Link the interceptors together in a chain.
<span class="fc bfc" id="L437" title="All 2 branches covered.">		for (int i = 0; i &lt; chain.length - 1; i++) {</span>
<span class="fc" id="L438">			chain[i].setBackingComponent(chain[i + 1]);</span>
		}

		// Return the top of the chain.
<span class="fc" id="L442">		return chain[0];</span>
	}

	/**
	 * Called if a Throwable is caught by the top-level service method. By default we display an error and terminate the
	 * session.
	 *
	 * @param helper the current servlet helper
	 * @param throwable the throwable
	 * @throws ServletException a servlet exception
	 * @throws IOException an IO Exception
	 */
	public static void handleError(final HttpServletHelper helper, final Throwable throwable) throws
			ServletException,
			IOException {
<span class="nc" id="L457">		HttpServletRequest httpServletRequest = helper.getBackingRequest();</span>
<span class="nc" id="L458">		HttpServletResponse httpServletResponse = helper.getBackingResponse();</span>

		// Allow for multi part requests
<span class="nc" id="L461">		Map&lt;String, String[]&gt; parameters = getRequestParameters(httpServletRequest);</span>

		// Set error code for AJAX, Content or data requests
<span class="nc bnc" id="L464" title="All 2 branches missed.">		boolean dataRequest = parameters.get(WServlet.DATA_LIST_PARAM_NAME) != null;</span>
<span class="nc" id="L465">		Object target = parameters.get(WServlet.AJAX_TRIGGER_PARAM_NAME);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">		if (target == null) {</span>
<span class="nc" id="L467">			target = parameters.get(WServlet.TARGET_ID_PARAM_NAME);</span>
		}
<span class="nc bnc" id="L469" title="All 4 branches missed.">		if (target != null || dataRequest) {</span>
<span class="nc" id="L470">			httpServletResponse.sendError(500, &quot;Internal Error&quot;);</span>
<span class="nc" id="L471">			return;</span>
		}

		// Decide whether we should use the ErrorPageFactory.
<span class="nc" id="L475">		boolean handleErrorWithFatalErrorPageFactory = Config.getInstance()</span>
<span class="nc" id="L476">				.getBoolean(HANDLE_ERROR_WITH_FATAL_ERROR_PAGE_FACTORY, false);</span>

		// use the new technique and delegate to the ErrorPageFactory.
<span class="nc bnc" id="L479" title="All 2 branches missed.">		if (handleErrorWithFatalErrorPageFactory) {</span>
<span class="nc" id="L480">			helper.handleError(throwable);</span>
<span class="nc" id="L481">			helper.dispose();</span>
		} else { // use the old technique and just display a raw message.
			// First, decide whether we are in friendly mode or not.
<span class="nc" id="L484">			boolean friendly = Config.getInstance().getBoolean(DEVELOPER_MODE_ERROR_HANDLING, false);</span>

<span class="nc" id="L486">			String message = InternalMessages.DEFAULT_SYSTEM_ERROR;</span>

			// If we are unfriendly, terminate the session
<span class="nc bnc" id="L489" title="All 2 branches missed.">			if (!friendly) {</span>
<span class="nc" id="L490">				HttpSession session = httpServletRequest.getSession(true);</span>
<span class="nc" id="L491">				session.invalidate();</span>

<span class="nc" id="L493">				message = InternalMessages.DEFAULT_SYSTEM_ERROR_SEVERE;</span>
			}

			// Display an error to the user.
<span class="nc" id="L497">			UIContext uic = helper.getUIContext();</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">			Locale locale = uic == null ? null : uic.getLocale();</span>
<span class="nc" id="L499">			message = I18nUtilities.format(locale, message);</span>
<span class="nc" id="L500">			httpServletResponse.getWriter().println(message);</span>
		}
<span class="nc" id="L502">	}</span>

	/**
	 * @param request the request being processed
	 * @return true if a multi part form request
	 */
	public static boolean isMultipart(final HttpServletRequest request) {
<span class="fc" id="L509">		String contentType = request.getContentType();</span>
<span class="pc bpc" id="L510" title="1 of 4 branches missed.">		boolean isMultipart = (contentType != null &amp;&amp; contentType.toLowerCase().startsWith(</span>
				&quot;multipart/form-data&quot;));
<span class="fc" id="L512">		return isMultipart;</span>
	}

	/**
	 * Get a map of request parameters allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @return a map of parameters on the request
	 */
	public static Map&lt;String, String[]&gt; getRequestParameters(final HttpServletRequest request) {
<span class="fc bfc" id="L522" title="All 2 branches covered.">		if (request.getAttribute(REQUEST_PROCESSED_KEY) == null) {</span>
<span class="fc" id="L523">			setupRequestParameters(request);</span>
		}
<span class="fc" id="L525">		return (Map&lt;String, String[]&gt;) request.getAttribute(REQUEST_PARAMETERS_KEY);</span>
	}

	/**
	 * Get a value for a request parameter allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @param key the parameter key to return
	 * @return the parameter value
	 */
	public static String getRequestParameterValue(final HttpServletRequest request, final String key) {
<span class="nc" id="L536">		String[] values = getRequestParameterValues(request, key);</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">		return values == null || values.length == 0 ? null : values[0];</span>
	}

	/**
	 * Get the values for a request parameter allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @param key the parameter key to return
	 * @return the parameter values
	 */
	public static String[] getRequestParameterValues(final HttpServletRequest request, final String key) {
<span class="nc" id="L548">		return getRequestParameters(request).get(key);</span>
	}

	/**
	 * Get a map of file items in the request allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @return a map of files on the request
	 */
	public static Map&lt;String, FileItem[]&gt; getRequestFileItems(final HttpServletRequest request) {
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">		if (request.getAttribute(REQUEST_PROCESSED_KEY) == null) {</span>
<span class="nc" id="L559">			setupRequestParameters(request);</span>
		}
<span class="fc" id="L561">		return (Map&lt;String, FileItem[]&gt;) request.getAttribute(REQUEST_FILES_KEY);</span>
	}

	/**
	 * Get a file item value from the request allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @param key the file parameter key to return
	 * @return the file item value
	 */
	public static FileItem getRequestFileItemValue(final HttpServletRequest request, final String key) {
<span class="nc" id="L572">		FileItem[] values = getRequestFileItemValues(request, key);</span>
<span class="nc bnc" id="L573" title="All 4 branches missed.">		return values == null || values.length == 0 ? null : values[0];</span>
	}

	/**
	 * Get file item values from the request allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @param key the file parameter key to return
	 * @return the file item values
	 */
	public static FileItem[] getRequestFileItemValues(final HttpServletRequest request, final String key) {
<span class="nc" id="L584">		return getRequestFileItems(request).get(key);</span>
	}

	/**
	 * Process the request parameters allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 */
	public static void setupRequestParameters(final HttpServletRequest request) {

		// Check already processed
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">		if (request.getAttribute(REQUEST_PROCESSED_KEY) != null) {</span>
<span class="nc" id="L596">			return;</span>
		}

<span class="fc" id="L599">		Map&lt;String, String[]&gt; parameters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L600">		Map&lt;String, FileItem[]&gt; files = new HashMap&lt;&gt;();</span>

<span class="fc" id="L602">		extractParameterMap(request, parameters, files);</span>

<span class="fc" id="L604">		request.setAttribute(REQUEST_PROCESSED_KEY, &quot;Y&quot;);</span>
<span class="fc" id="L605">		request.setAttribute(REQUEST_PARAMETERS_KEY, Collections.unmodifiableMap(parameters));</span>
<span class="fc" id="L606">		request.setAttribute(REQUEST_FILES_KEY, Collections.unmodifiableMap(files));</span>
<span class="fc" id="L607">	}</span>

	/**
	 * Extract the parameters and file items allowing for multi part form fields.
	 *
	 * @param request the request being processed
	 * @param parameters the map to store non-file request parameters in.
	 * @param files the map to store the uploaded file parameters in.
	 */
	public static void extractParameterMap(final HttpServletRequest request, final Map&lt;String, String[]&gt; parameters, final Map&lt;String, FileItem[]&gt; files) {

<span class="fc bfc" id="L618" title="All 2 branches covered.">		if (isMultipart(request)) {</span>
<span class="fc" id="L619">			ServletFileUpload upload = new ServletFileUpload();</span>
<span class="fc" id="L620">			upload.setFileItemFactory(new DiskFileItemFactory());</span>
			try {
<span class="fc" id="L622">				List fileItems = upload.parseRequest(request);</span>

<span class="fc" id="L624">				uploadFileItems(fileItems, parameters, files);</span>
<span class="nc" id="L625">			} catch (FileUploadException ex) {</span>
<span class="nc" id="L626">				throw new SystemException(ex);</span>
<span class="fc" id="L627">			}</span>
			// Include Query String Parameters (only if parameters were not included in the form fields)
<span class="fc bfc" id="L629" title="All 2 branches covered.">			for (Object entry : request.getParameterMap().entrySet()) {</span>
<span class="fc" id="L630">				Map.Entry&lt;String, String[]&gt; param = (Map.Entry&lt;String, String[]&gt;) entry;</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">				if (!parameters.containsKey(param.getKey())) {</span>
<span class="fc" id="L632">					parameters.put(param.getKey(), param.getValue());</span>
				}
<span class="fc" id="L634">			}</span>
<span class="fc" id="L635">		} else {</span>
<span class="fc" id="L636">			parameters.putAll(request.getParameterMap());</span>
		}
<span class="fc" id="L638">	}</span>

	/**
	 * &lt;p&gt;
	 * {@link FileItem} classes (if attachements) will be kept as part of the request. The default behaviour of the file
	 * item is to store the upload in memory until it reaches a certain size, after which the content is streamed to a
	 * temp file.&lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * If, in the future, performance of uploads becomes a focus we can instead look into using the Jakarta Commons
	 * Streaming API. In this case, the content of the upload isn't stored anywhere. It will be up to the user to
	 * read/store the content of the stream.&lt;/p&gt;
	 *
	 * @param fileItems a list of {@link FileItem}s corresponding to POSTed form data.
	 * @param parameters the map to store non-file request parameters in.
	 * @param files the map to store the uploaded file parameters in.
	 */
	public static void uploadFileItems(final List&lt;FileItem&gt; fileItems, final Map&lt;String, String[]&gt; parameters,
			final Map&lt;String, FileItem[]&gt; files) {

<span class="fc bfc" id="L658" title="All 2 branches covered.">		for (FileItem item : fileItems) {</span>
<span class="fc" id="L659">			String name = item.getFieldName();</span>
<span class="fc" id="L660">			boolean formField = item.isFormField();</span>

<span class="pc bpc" id="L662" title="1 of 2 branches missed.">			if (LOG.isDebugEnabled()) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">				LOG.debug(</span>
						&quot;Uploading form &quot; + (formField ? &quot;field&quot; : &quot;attachment&quot;) + &quot; \&quot;&quot; + name + &quot;\&quot;&quot;);
			}

<span class="fc bfc" id="L667" title="All 2 branches covered.">			if (formField) {</span>
				String value;
				try {
					// Without specifying UTF-8, apache commons DiskFileItem defaults to ISO-8859-1.
<span class="fc" id="L671">					value = item.getString(&quot;UTF-8&quot;);</span>
<span class="nc" id="L672">				} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L673">					throw new SystemException(&quot;Encoding error on formField item&quot;, e);</span>
<span class="fc" id="L674">				}</span>
<span class="fc" id="L675">				RequestUtil.addParameter(parameters, name, value);</span>
<span class="fc" id="L676">			} else {</span>
				// Form attachment
<span class="fc" id="L678">				RequestUtil.addFileItem(files, name, item);</span>
<span class="fc" id="L679">				String value = item.getName();</span>
<span class="fc" id="L680">				RequestUtil.addParameter(parameters, name, value);</span>
			}
<span class="fc" id="L682">		}</span>

<span class="fc" id="L684">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>